# 《过滤器&监听器-笔记》

# 回顾

## JSP的页面脚本元素

| 组成部分    | 语法格式                     |
| :---------- | ---------------------------- |
| JSP代码片段 | <% %> 写Java代码             |
| JSP声明     | <%! %> 声明成员变量和方法    |
| JSP表达式   | <%= %> 输出，相当于out.print |
| 注释        | <%-- --%> 网页上不能看到注释 |



## EL表达式如何获取不同类型的数据

| EL表达式获取不同数据 | 说明                       |
| -------------------- | -------------------------- |
| 获取JavaBean的属性值 | ${javabean对象.属性名}     |
| 获取数组和List中的值 | ${集合[索引]}              |
| 获取Map中的值        | ${map.键} 或 \${map["键"]} |



##  判断标签 if

| 属性名 | 属性类型 | 属 性 描 述          |
| ------ | -------- | -------------------- |
| test   | boolean  | 如果为真就执行标签体 |

## 多分支标签choose

| 标签名    | 作用                   |
| --------- | ---------------------- |
| choose    | 容器，类似于switch     |
| when      | 相当于case，可以有多个 |
| otherwise | 相当于default          |

##  遍历标签 forEach

| 属性名    | 属 性 描 述                                      |
| --------- | ------------------------------------------------ |
| var       | 变量名放在页面域中，代表一个元素                 |
| varStatus | 状态对象，包含4个属性：index, count, first, last |
| items     | 要遍历的集合或数组                               |
| begin     | 开始的元素，默认从0开始                          |
| end       | 结束的元素                                       |
| step      | 步长                                             |



##  什么是MVC

| MVC  | 描述       | Java Web的实现技术 |
| ---- | ---------- | ------------------ |
| M    | Model      | JavaBean           |
| V    | View       | JSP+JSTL+EL        |
| C    | Controller | Servlet            |

 

# 学习目标

1. 过滤器
   1. 能够说出过滤器的作用
   2. <font color="red">能够编写过滤器</font>
   3. <font color="red">能够说出过滤器生命周期相关方法</font>
   4. 能够根据过滤路径判断指定的过滤器是否起作用
   5. 能够说出什么是过滤器链
   6. 能够编写过滤器解决全局乱码
2. 监听器
   1. 能够说出监听器的作用
   2. 能够使用ServletContextListener监听器

# 学习内容

## 过滤器的基本概念

### 目标

1. 过滤器的概念

2. JavaWeb的三种组件

3. 过滤器的使用场景

### Java Web的三种组件

| 组件            | 作用                                                         |
| --------------- | ------------------------------------------------------------ |
| Servlet         | 运行在服务器端的Java小程序，处理用户的请求并且做出响应，生成动态网页。 |
| Filter 过滤器   | 运行在Web资源之前，用来处理公共的功能。对用户发送的请求进行拦截或修改 |
| Listener 监听器 | 监听作用域对象，作用域创建和销毁，作用域中属性变化           |

### 过滤器所处的位置

![1572572078246](https://raw.githubusercontent.com/Kid-On-The-Road/Resources/main/笔记图片/过滤器&监听器/1572572078246.png)

### 过滤器的使用场景：

1. 解决全局汉字乱码的问题

2. 用户是否登录进行判断，如果已经登录就可以访问，没有登录就拦截。

3. 对发送的信息进行过滤

### 小结

1. JavaWeb的三种组件
   1. Servlet
   2. Filter 过滤器
   3. Listener 监听器
2. 过滤器的使用场景



## <font color="red">案例：编写第1个过滤器</font>

### 目标

1. 过滤器的开发步骤

2. 编写第1个过滤器

### 开发过滤器的步骤

1. 创建一个类，实现javax.servlet.Filter接口
2. 重写接口中所有的方法，其中doFilter()用于执行过滤任务
3. 通过web.xml配置过滤器，或使用注解@WebFilter("/拦截地址")

### 过滤器的演示案例：

#### 需求

创建一个过滤器HelloFilter，在运行HelloServlet前和后分别输出一句话，在HelloServlet中也输出一句话，观察控制台的运行效果。

#### 执行效果：

​    ![1552917350933](https://raw.githubusercontent.com/Kid-On-The-Road/Resources/main/笔记图片/过滤器&监听器/1552917350933.png)                                               

#### 注解说明

| @WebFilter注解属性 | 说明         |
| ------------------ | ------------ |
| filterName         | 过滤器的名字 |
| urlPatterns        | 拦截的地址   |
| value              | 拦截的地址   |

####  Servlet的代码 

```java
package com.itheima.servlet;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.sql.Timestamp;

/*
demo1是web资源，是web资源的访问地址
 */
@WebServlet("/demo1")
public class Demo1HelloServlet extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        System.out.println(new Timestamp(System.currentTimeMillis()) + " Web资源：访问到了Servlet");
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        this.doPost(request, response);
    }
}

```

#### 使用注解的方式 

```java
package com.itheima.filter;

import javax.servlet.*;
import javax.servlet.annotation.WebFilter;
import java.io.IOException;
import java.sql.Timestamp;

/**
1. 创建一个类，实现javax.servlet.Filter接口
2. 重写接口中所有的方法，其中doFilter()用于执行过滤任务
3. 通过web.xml配置过滤器，或使用注解@WebFilter("/拦截地址")
 */
@WebFilter("/demo1")
public class Demo1HelloFilter implements Filter {
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {

    }

    /**
     * 执行过滤任务
     * @param request 请求对象，是HttpServletRequest的父接口
     * @param response 响应对象，是HttpServletResponse的父接口
     * @param chain 过滤器链对象
     */
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
        System.out.println(new Timestamp(System.currentTimeMillis()) + " 过滤器：请求的时候执行");
        //如果执行这句话就放行，否则就是拦截
        chain.doFilter(request,response);
        System.out.println(new Timestamp(System.currentTimeMillis()) + " 过滤器：响应的时候执行");
    }

    @Override
    public void destroy() {

    }
}
```

#### 使用配置文件的方式 

```xml
    <!--配置过滤器-->
    <filter>
        <!--过滤器名字-->
        <filter-name>demo1</filter-name>
        <!--过滤器的类全名-->
        <filter-class>com.itheima.filter.Demo1HelloFilter</filter-class>
    </filter>
    <!--拦截地址-->
    <filter-mapping>
        <!--名字与上面相同-->
        <filter-name>demo1</filter-name>
        <!--拦截地址，如果访问的地址与拦截地址匹配就会经过过滤器 -->
        <url-pattern>/demo1</url-pattern>
    </filter-mapping>
```

### 小结

1. 过滤器的编写要实现哪个接口

   ```
   javax.servlet.Filter
   ```

   

2. 过滤的方法是哪个

   ```
   doFilter(request,response,filterChain)
   ```

   



## 过滤器的执行流程

### 目标

过滤器的执行流程

### 过滤器的执行流程

![1552917794230](https://raw.githubusercontent.com/Kid-On-The-Road/Resources/main/笔记图片/过滤器&监听器/1552917794230.png)

### 小结

过滤器的执行流程如下：

1. 用户发送请求，请求的是Web资源。如果过滤器匹配访问的地址就会对地址进行拦截。
2. 用户的请求首先会访问过滤器，执行doFilter()
3. 在doFilter中又会调用chain.doFilter(request, response)方法放行
4. 到达Web资源，访问完Web资源之后响应回来，返回到过滤器中。
5. 再次执行过滤器，到达浏览器。



## <font color="red">过滤器的生命周期</font>

### 目标

过滤器的生命周期有哪些方法

### 回顾Servlet生命周期有哪些方法

```
init() 初始化，第1次访问执行1次
service() 服务，每次用户请求都会执行
destroy() 销毁，服务器关闭的时候执行1次
```

### Filter生命周期的方法 

| Filter接口中的方法                                           | 作用和执行次数                      |
| ------------------------------------------------------------ | ----------------------------------- |
| void   init(FilterConfig filterConfig)                       | 初始化，服务器启动就加载了，执行1次 |
| void   doFilter(ServletRequest request, <br />ServletResponse response, <br />FilterChain chain) | 匹配拦截地址，每次用户请求都会执行  |
| public void   destroy()                                      | 销毁，服务器关闭的时候执行1次       |



### 过滤器加载的时机： 

- 回顾：以前Servlet是什么时间加载的?

  ```
  用户第1次访问加载
  ```

  

- Filter什么时候加载呢?

  ```
  服务器在启动的时候就会加载所有的过滤器
  ```

  



## 示例：生命周期的过程

#### 执行效果

![1572575071203](https://raw.githubusercontent.com/Kid-On-The-Road/Resources/main/笔记图片/过滤器&监听器/1572575071203.png)

#### 案例代码

```java
package com.itheima.filter;

import javax.servlet.*;
import javax.servlet.annotation.WebFilter;
import java.io.IOException;
import java.sql.Timestamp;

@WebFilter(filterName = "Demo2LifeCycleFilter", urlPatterns = "/demo1")
public class Demo2LifeCycleFilter implements Filter {
    /*
    服务器启动就加载
     */
    public void init(FilterConfig config) throws ServletException {
        System.out.println(new Timestamp(System.currentTimeMillis()) + " 过滤器初始化 " + this);
    }

    /*
    只要匹配拦截地址，每次访问都会执行
     */
    public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException {
        System.out.println(new Timestamp(System.currentTimeMillis()) + "，请求");
        chain.doFilter(req, resp); //放行，访问下一个Web资源
        System.out.println(new Timestamp(System.currentTimeMillis()) + "，响应");
    }

    /*
    服务器关闭的时候执行1次
     */
    public void destroy() {
        System.out.println(new Timestamp(System.currentTimeMillis()) + " 过滤器销毁 " + this);
    }

}
```



### 小结

1. 过滤器什么时候执行初始化？

   ```
   服务器启动
   ```

2. 过滤的方法执行多少次？

   ```
   每次请求都会执行
   ```

3. 过滤器什么时候销毁？

   ```
   服务器关闭的时候执行1次
   ```



## 过滤器映射的访问路径

### 目标

理解过滤器的映射路径的写法

### Servlet中与过滤器中映射路径的区别

- Servlet：配置地址是它的访问地址

- Filter：配置地址是它的拦截地址，并不是它的访问地址，过滤器不能直接访问，只要匹配过滤地址就会自动访问。

- 疑问：浏览器访问目标资源的路径，如果目标地址不存在，过滤器会不会运行？

  ```
  无论web资源是否存在，只要匹配过滤的地址，过滤器就会执行。
  ```

  

### 在Filter中URL的过滤方式

2种格式：

| 匹配方式     | 匹配哪些资源                          | 示例        |
| ------------ | ------------------------------------- | ----------- |
| 以/开头      | 精确匹配：访问地址与过滤地址完全一样  | /demo1      |
|              | 目录匹配：拦截某个目录下所有的web资源 | /admin/*    |
|              | 拦截整个Web服务器中所有的资源         | /*          |
| 以扩展名结尾 | 拦截某种资源的扩展名                  | *.do *.html |

- 疑问：以/开关的匹配模式和以扩展名结尾的配置，同时出现会怎样？

  ```
  Caused by: java.lang.IllegalArgumentException: Invalid <url-pattern> /*.html in filter mapping
  不能同时出现，否则会导致服务器加载当前项目失败，项目中所有的资源都不能访问。
  ```

 

### 过滤多个地址的写法

无论是value，还是urlPatterns参数值都是一个String[] 数组，可以指定多个字符串

| 过滤器匹配多个地址                | 说明                                                         |
| --------------------------------- | ------------------------------------------------------------ |
| @WebFilter({"/demo1", "/demo2"})  | 同时过滤demo1和demo2                                         |
| @WebFilter({"/admin/*", "*.jsp"}) | 过滤admin目录下所有的资源和所有的JSP页面<br />过滤的地址是所有过滤地址的并集，不是交集 |



####  小结：根据过滤路径判断指定的过滤器是否起作用

| 浏览器的访问地址                              | 过滤器的配置  | 是否起作用               |
| --------------------------------------------- | ------------- | ------------------------ |
| http://localhost:8080/项目地址/aaa            | /*            | 是，过滤所有的资源       |
| http://localhost:8080/项目地址/aaa            | /aaa          | 是，精确匹配             |
| http://localhost:8080/项目地址/aaa.do         | *.do          | 是，扩展名匹配           |
| http://localhost:8080/项目地址/aaa/bbb        | /aaa/*        | 是，过滤指定的目录下资源 |
| http://localhost:8080/项目地址/bbb.do         | /*.do         | 否，错误的               |
| http://localhost:8080/项目地址/aaa/bbb.action | /aaa/*.action | 否，错误的               |



## 过滤器的三种拦截方式

### 目标

过滤器常用的两种拦截方式

### 默认的拦截方式 

过滤器在默认的情况下，只对直接来自浏览器的请求进行拦截。如果是转发，不会经过过滤器

### 案例

1). 在index.jsp转发到HelloServlet

2). 过滤器的配置

#### index.jsp

```jsp
<%--转发到demo1这个Servlet--%>
<%--<jsp:forward page="/demo1"></jsp:forward>--%>
<%--包含另一个Servlet--%>
<jsp:include page="/demo1"></jsp:include>
```

####  配置方式1：注解的方式：

``` java
/**
 * dispatcherTypes：指定拦截的方式
 * DispatcherType.FORWARD 对转发进行拦截
 * DispatcherType.REQUEST 对请求进行拦截
 * DispatcherType.INCLUDE 对包含进行拦截
 */
@WebFilter(urlPatterns = "/demo1", dispatcherTypes = {DispatcherType.FORWARD, DispatcherType.REQUEST, DispatcherType.INCLUDE} )
public class Demo2LifeCycleFilter implements Filter
```

####  配置方式2：web.xml文件

```xml
<filter>
    <filter-name>demo2</filter-name>
    <filter-class>com.itheima.filter.Demo2LifeCycleFilter</filter-class>
</filter>
<filter-mapping>
    <filter-name>demo2</filter-name>
    <!--过滤地址-->
    <url-pattern>/demo1</url-pattern>
    <!--拦截类型-->
    <dispatcher>FORWARD</dispatcher>
    <dispatcher>REQUEST</dispatcher>
    <dispatcher>INCLUDE</dispatcher>
</filter-mapping>
```

###  小结：过滤器的拦截类型

| 过滤类型 | 作用                 |
| -------- | -------------------- |
| FORWARD  | 对转发进行拦截       |
| REQUEST  | 对直接的请求进行拦截 |
| INCLUDE  | 对包含进行拦截       |

 

## <font color="red">案例：使用过滤器过滤全局汉字乱码问题</font>

### 目标

编写过滤器，过滤所有Servlet中使用POST方法提交的汉字的编码。

### 分析

![1572578546401](https://raw.githubusercontent.com/Kid-On-The-Road/Resources/main/笔记图片/过滤器&监听器/1572578546401.png) 

### 开发步骤

1. 有2个Servlet，一个是LoginServlet登录，一个是RegisterServlet注册
2. 有2个JSP页面，1个是login.jsp，有表单，登录名。1个register.jsp，有表单，有注册的名字。都使用POST提交用户名使用汉字提交。
3. 使用过滤器，对所有的Servlet的POST方法进行过滤。
4. 在没有使用过滤器之前，每个Servlet必须加上汉字编码：request.setCharacterEncoding(字符集); 字符集与网页的编码要一致

###   代码

#### login.jsp

``` jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>登录</title>
</head>
<body>
<form action="login" method="post">
    登录名：<input type="text" name="user"><br>
    <input type="submit" value="登录">
</form>
</body>
</html>
```

####  register.jsp

``` jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>用户注册</title>
</head>
<body>
<h2>用户注册</h2>
<form action="register" method="post">
    注册名：<input type="text" name="name"><br>
    <input type="submit" value="注册">
</form>
</body>
</html>
```

####  LoginServlet.java

```java
package com.itheima.servlet;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.PrintWriter;

@WebServlet("/login")
public class LoginServlet extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        //获取用户名
        String user = request.getParameter("user");
        //输出用户名
        response.setContentType("text/html;charset=utf-8");
        PrintWriter out = response.getWriter();
        out.print("登录成功，欢迎您：" + user);
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        this.doPost(request, response);
    }
}

```

####  RegisterServlet.java

```java
package com.itheima.servlet;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.PrintWriter;

@WebServlet("/register")
public class RegisterServlet extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        //得到注册名
        String name = request.getParameter("name");
        //输出到网页
        response.setContentType("text/html;charset=utf-8");
        PrintWriter out = response.getWriter();
        out.print("注册成功，用户名是：" + name);
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        this.doPost(request, response);
    }
}

```

####  EncodeFilter.java

```java
package com.itheima.filter;

import javax.servlet.*;
import javax.servlet.annotation.WebFilter;
import javax.servlet.http.HttpServletRequest;
import java.io.IOException;

/*
过滤所有的Web资源
 */
@WebFilter(filterName = "EncodingFilter", urlPatterns = "/*")
public class EncodingFilter implements Filter {
    public void destroy() {
    }

    public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException {
        //只对POST请求编码
        HttpServletRequest request = (HttpServletRequest) req;  //转成子接口
        if (request.getMethod().equals("POST")) { //这个字符串必须大写
            //设置请求的编码
            request.setCharacterEncoding("utf-8");
        }
        chain.doFilter(req, resp);  //放行，过滤器是运行在Servlet之前
    }

    public void init(FilterConfig config) throws ServletException {

    }

}
```

### 小结

编写一个过滤器就可以对所有的Servlet进行汉字编码

1. 使用哪个方法：setCharacterEncoding()
2. 过滤的地址：  /* 所有的地址
3. 放行使用哪个方法：  chain.doFilter()



## 过滤器链FilterChain的使用

### 目标

1. 什么是过滤器链

2. 过滤器链的执行顺序是怎样的

### 过滤器链的概念

如果一个用户请求同时匹配多个过滤器的拦截地址，那么依次经过多个过滤器，请求到达第1个过滤器的时候，将请求向后传递，如果下一个还是过滤器就将请求给过滤器，如果下一个没有过滤器了，就将请求传递给Web资源。这多个过滤器就组成了一个过滤器链。

请求的时候执行顺序：1->2->3

响应的时候执行顺序：3->2->1

写成多个过滤器的原因是有利于模块化的设计，每个过滤器实现一个功能。

 

![1552919196802](https://raw.githubusercontent.com/Kid-On-The-Road/Resources/main/笔记图片/过滤器&监听器/1552919196802.png)                                                 

### FilterChain接口中的方法

```
void doFilter(ServletRequest request, ServletResponse response)  
如果调用这个方法就放行，否则就拦截
```



### 示例：过滤器链 ![1552919236666](https://raw.githubusercontent.com/Kid-On-The-Road/Resources/main/笔记图片/过滤器&监听器/1552919236666.png)

#### 需求

创建两个过滤器OneFilter和TwoFilter，访问ResourceServlet，每个过滤器的请求和响应各输出一句话，观察过滤器的执行过程。

#### 执行效果：

  &nbsp;![1552919267302](https://raw.githubusercontent.com/Kid-On-The-Road/Resources/main/笔记图片/过滤器&监听器/1552919267302.png) 

#### 第一个过滤器

```java
package com.itheima.filter;

import javax.servlet.*;
import javax.servlet.annotation.WebFilter;
import java.io.IOException;

//@WebFilter(filterName = "OneFilter", urlPatterns = "/resource")
public class OneFilter implements Filter {
    public void destroy() {
    }

    public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException {
        System.out.println("过滤器1：请求");
        chain.doFilter(req, resp);  //放行
        System.out.println("过滤器1：响应");
    }

    public void init(FilterConfig config) throws ServletException {

    }

}

```

####  第二个过滤器

```java
package com.itheima.filter;

import javax.servlet.*;
import javax.servlet.annotation.WebFilter;
import java.io.IOException;

//@WebFilter(filterName = "TwoFilter", urlPatterns = "/resource")
public class TwoFilter implements Filter {
    public void destroy() {
    }

    public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException {
        System.out.println("过滤器2：请求");
        chain.doFilter(req, resp);  //放行
        System.out.println("过滤器2：响应");
    }

    public void init(FilterConfig config) throws ServletException {

    }

}

```

#### Web资源

```java
package com.itheima.servlet;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@WebServlet("/resource")
public class ResourceServlet extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        System.out.println("Web资源：到达Servlet");
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        this.doPost(request, response);
    }
}

```

 

### 疑问：过滤器链的执行顺序是怎样的？

1. 使用web.xml的配置方式: 

``` xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">


    <!--过滤器链：第1个过滤器-->
    <filter>
        <filter-name>one</filter-name>
        <filter-class>com.itheima.filter.OneFilter</filter-class>
    </filter>
    <filter-mapping>
        <filter-name>one</filter-name>
        <url-pattern>/resource</url-pattern>
    </filter-mapping>

    <!--第2个过滤-->
    <filter>
        <filter-name>two</filter-name>
        <filter-class>com.itheima.filter.TwoFilter</filter-class>
    </filter>
    <filter-mapping>
        <filter-name>two</filter-name>
        <url-pattern>/resource</url-pattern>
    </filter-mapping>

</web-app>
```

2. 使用注解的配置方式:

```
按类名的字母顺序，哪个在前面就先执行
```



### 小结

过滤器链的执行顺序是？

1. 配置：按配置的先后顺序

2. 注解：按类名的字母顺序(按字符串的大小比较)



## 上午的回顾

### 过滤器的应用场景

1. 解决全局乱码问题
2. 用户权限控制，没有登录的用户不能访问某些资源
3. 对请求的数据进行过滤，屏蔽一些敏感的数据

### 如何编写过滤器

1. 编写一个类实现接口：javax.servlet.Filter
2. 重写接口中所有的方法，其中doFilter()，过滤的方法
3. 在web.xml中配置或使用注解@WebFilter来配置

### 过滤器生命周期中方法

```
init() 初始化方法，服务器启动就执行1次
doFilter(request, response, filterChain) 如果匹配拦截的路径，每次请求都会执行
destroy() 销毁方法，服务器关闭的时候执行
```



### 访问路径写法

```
/demo1  精确匹配
/* 拦截所有的资源
/目录/* 拦截指定目录下资源
*.扩展名  拦截某种类型文件
注：/开头和扩展名结尾的路径不能同时出现，否则会报错
```



### 三种拦截方式

| 拦截方式 | 说明           |
| -------- | -------------- |
| FORWARD  | 拦截转发       |
| REQUEST  | 拦截请求(默认) |
| INCLUDE  | 拦截包含       |



### 案例：全局汉字乱码问题

```
核心代码：在过滤器使用setCharacterEncoding("utf-8")
拦截路径： /*
```



## FilterConfig接口

### 目标

学习FilterConfig接口的方法

### 方法

使用配置文件的方式中

| FilterConfig接口中的方法                     | 功能                                                         |
| -------------------------------------------- | ------------------------------------------------------------ |
| String getInitParameter("参数名")            | 通过参数名来读取相应的参数值 <br />参数名和参数值都在web.xml配置文件中 |
| Enumeration\<String> getInitParameterNames() | 获取所有配置参数的名字，返回枚举集合                         |

### 代码

过滤器代码

```java
public void init(FilterConfig config) throws ServletException {
    //使用config对象读取web.xml配置文件中参数值，通过参数名得到参数值
    String user = config.getInitParameter("user");
    System.out.println("初始化参数：" + user);
    //得到所有参数名
    Enumeration<String> names = config.getInitParameterNames();
    while(names.hasMoreElements()) {
        String name = names.nextElement();
        String value = config.getInitParameter(name);
        System.out.println("参数名：" + name + "，参数值：" + value);
    }
}
```

web.xml

```xml
<!--过滤器链：第1个过滤器-->
<filter>
    <filter-name>one</filter-name>
    <filter-class>com.itheima.filter.OneFilter</filter-class>
    <init-param>
        <param-name>user</param-name>
        <param-value>孙悟空</param-value>
    </init-param>
    <init-param>
        <param-name>age</param-name>
        <param-value>20</param-value>
    </init-param>
</filter>
<filter-mapping>
    <filter-name>one</filter-name>
    <url-pattern>/resource</url-pattern>
</filter-mapping>
```

### 效果

![1572590980894](https://raw.githubusercontent.com/Kid-On-The-Road/Resources/main/笔记图片/过滤器&监听器/1572590980894.png) 

### 小结

```
getInitParameter("user")：通过参数名读取web.xml中参数值
getInitParameterNames()：得到所有的参数名
```



## 案例：用户权限的过滤器

### 目标

使用过滤器进行权限的控制，实现正确的访问

- add.jsp 添加数据，需要登录才可访问
- update.jsp 修改数据，需要登录才可访问
- list.jsp 查询数据，不用登录
- login.jsp 登录页面

### 项目结构

 &nbsp;![1552919494358](https://raw.githubusercontent.com/Kid-On-The-Road/Resources/main/笔记图片/过滤器&监听器/1552919494358.png)                                                         

###  实现步骤：

1. 在Web下创建4个页面 login.jsp上使用${msg}，显示信息。
2. 创建LoginServlet， 判断用户名密码是否正确，如果正确，则在会话域中保存用户信息。登录成功跳转到add.jsp，登录失败则在域中写入登录失败的信息，并且跳转到login.jsp。
3. 使用过滤器解决：创建AuthorFilter
   1.  得到HttpServletRequest、HttpSession对象
   2.  如果会话中没有用户信息，则转到登录页面，并return。
   3.  否则继续访问后续的Web资源

### 案例代码：

#### LoginServlet

```java
package com.itheima.servlet;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@WebServlet("/login")
public class LoginServlet extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        //1.得到用户名和密码
        String username = request.getParameter("username");
        String password = request.getParameter("password");

        //2.判断用户名和密码是否正确
        if ("admin".equals(username) && "123".equals(password)) {
            //3. 登录成功，将用户的信息保存在会话域中
            request.getSession().setAttribute("user", username);
            response.sendRedirect(request.getContextPath() + "/admin/add.jsp");
        }
        //4. 登录失败，跳转到登录，并且显示错误信息
        else {
            //将错误信息放在请求域中
            request.setAttribute("msg","用户名或密码不正确");
            request.getRequestDispatcher("/login.jsp").forward(request, response);
        }
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        this.doPost(request, response);
    }
}

```

#### AuthorFilter

```java
package com.itheima.filter;

import javax.servlet.*;
import javax.servlet.annotation.WebFilter;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import java.io.IOException;

/*
注：这里不能过滤所有的资源，
因为没有登录就会重定向到login.jsp
会导致不停的跳转，提示重定向次数过多。

1. 如果登录就放行
2. 否则就拦截，并且重定向到login.jsp
 */
@WebFilter(filterName = "AuthorFilter", urlPatterns = "/admin/*")
public class AuthorFilter implements Filter {
    public void destroy() {
    }

    public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException {
        //1. 判断会话域中是否有用户的信息
        //1.1 转换成子接口
        HttpServletRequest request = (HttpServletRequest) req;
        HttpServletResponse response = (HttpServletResponse) resp;
        //1.2得到会话域
        HttpSession session = request.getSession();
        String user = (String) session.getAttribute("user");
        //2. 如果有表示已经登录，放行。
        if (user != null) {
            chain.doFilter(req, resp);
        }
        //3. 否则表示没有登录，重定向到login.jsp页面
        else {
            //输出客户端的IP地址
            System.out.println("拦截到非法的请求 " + request.getRemoteAddr());
            response.sendRedirect(request.getContextPath() + "/login.jsp");
        }
    }

    public void init(FilterConfig config) throws ServletException {

    }

}

```



### 小结

1. 过滤的地址是：/admin/*

2. 过滤器中使用的是父接口

   ```
   如果要使用子接口，必须要先强转才能使用子接口中方法
   ```

   



## 监听器的概述

### 目标

1. 监听器的作用

2. 常用的监听器有哪些

### 作用

1. 监听作用域的创建和销毁
2. 监听作用域中属性的变化

### 回顾：三种作用域的创建与销毁时机

| 作用域   | 接口名             | 作用范围           | 生命周期       |
| -------- | ------------------ | ------------------ | -------------- |
| 请求域   | HttpServletRequest | 1个用户的1次请求   | 一次请求       |
| 会话域   | HttpSession        | 1个用户的多次请求  | 服务器会话过期 |
| 上下文域 | ServletContext     | 所有用户的所有请求 | 服务器关闭     |

### 会话域监听器应用场景

获取当前在线的人数

1. 每次用户登录成功，会向会话域中添加用户的信息
2. 监听器就可以监听到会话域发生了变化
3. 每创建一个会话，计数加1。如果会话过期，计数减1

### 监听器接口

![1552919771117](https://raw.githubusercontent.com/Kid-On-The-Road/Resources/main/笔记图片/过滤器&监听器/1552919771117.png)

### 小结

1. 上下文域创建和销毁的监听接口：ServletContextListener
2. 上下文域属性修改的监听接口：ServletContextAttributeListener



## ServletContextListener监听器

### 目标

1. ServletContextListener接口有哪些方法

2. 编写ServletContextListener监听器

### ServletContextListener监听器的概述

1. 作用：监听上下文对象的创建和销毁
2. 创建时机：服务器启动的时候
3. 销毁时机：服务器关闭的时候

### 接口中的方法

| 接口中的方法                                       | 功能               | 执行次数 |
| -------------------------------------------------- | ------------------ | -------- |
| void contextDestroyed(ServletContextEvent   sce)   | 监听上下文域的销毁 | 1次      |
| void contextInitialized(ServletContextEvent   sce) | 监听上下文域的创建 | 1次      |

### ServletContextEvent事件对象的方法

| ServletContextEvent中的方法          | 功能           |
| ------------------------------------ | -------------- |
| ServletContext   getServletContext() | 获取上下文对象 |

### 案例：ServletContextListener的应用

#### 需求：

在Web项目加载和结束的时候在控制台各打印输出现在的时间戳，并且输出一句话

#### 监听器的开发步骤：

1. 创建一个类实现监听器接口
2. 重写接口中所有的方法
3. 在web.xml中配置监听器或使用注解@WebListener

####  代码

##### 监听器

```java
package com.itheima.listener;

import javax.servlet.ServletContextEvent;
import javax.servlet.ServletContextListener;
import javax.servlet.annotation.WebListener;
import java.sql.Timestamp;

/**
 * 1. 创建一个类实现监听器接口
 * 2. 重写接口中所有的方法
 * 3. 在web.xml中配置监听器或使用注解@WebListener
 */
//@WebListener
public class MyListener implements ServletContextListener {
    //监听创建
    @Override
    public void contextInitialized(ServletContextEvent event) {
        System.out.println(new Timestamp(System.currentTimeMillis()) + " 创建了上下文对象：" + event.getServletContext());
    }

    //监听销毁
    @Override
    public void contextDestroyed(ServletContextEvent event) {
        System.out.println(new Timestamp(System.currentTimeMillis()) + " 上下文对象销毁：" + event.getServletContext());
    }
}

```

##### web.xml

```xml
<!--配置监听器-->
<listener>
    <listener-class>com.itheima.listener.MyListener</listener-class>
</listener>
```

#### 执行效果

```
2019-11-01 15:41:12.183 创建了上下文对象：org.apache.catalina.core.ApplicationContextFacade@172ebeb1

2019-11-01 15:41:38.785 上下文对象销毁：org.apache.catalina.core.ApplicationContextFacade@172ebeb1
```



### 小结

1. 接口中有几个方法: 2个方法

2. 方法的作用是什么

   1. 监听上下文对象的创建
   2. 监听上下文对象的销毁

   



## ServletContextAttributeListener监听器

### 目标

1. ServletContextAttributeListener监听器触发的时机

2. ServletContextAttributeListener接口方法中的方法

###  ServletContextAttributeListener监听器的作用

1. 作用：监听上下文域中属性的增删改

2. 时机：
   1. 增加属性：setAttribute()
   2. 删除属性：removeAttribute()
   3. 修改属性：setAttribute()

###  ServletContextAttributeListener接口中的方法

| 接口中的方法                                                | 功能                 |
| ----------------------------------------------------------- | -------------------- |
| void  attributeAdded(ServletContextAttributeEvent event)    | 添加属性时执行的方法 |
| void attributeRemoved(ServletContextAttributeEvent   event) | 删除属性时执行的方法 |
| void  attributeReplaced(ServletContextAttributeEvent event) | 修改属性时执行的方法 |

### ServletContextAttributeEvent对象中的方法

| ServletContextAttributeEvent对象中的方法 | 功能           |
| ---------------------------------------- | -------------- |
| String   getName()                       | 获取属性的名字 |
| Object   getValue()                      | 获取属性的值   |

### ServletContextAttributeListener监听器的示例

#### 案例需求

1. 创建一个ServletContextAttributeListener监听器的实现类，重写接口中所有的方法，输出属性名和属性值

2. 创建一个Servlet，向context上下文中添加一个属性，修改一个属性，删除一个属性。

- 注：修改后的属性值，要通过上下文对象来取得。

#### 案例效果

&nbsp;![1572595007084](https://raw.githubusercontent.com/Kid-On-The-Road/Resources/main/笔记图片/过滤器&监听器/1572595007084.png) 

#### 案例代码

```java
package com.itheima.listener;

import javax.servlet.ServletContextAttributeEvent;
import javax.servlet.ServletContextAttributeListener;
import javax.servlet.ServletContextEvent;
import javax.servlet.ServletContextListener;
import javax.servlet.annotation.WebListener;
import java.sql.Timestamp;

/**
 * 1. 创建一个类实现监听器接口
 * 2. 重写接口中所有的方法
 * 3. 在web.xml中配置监听器或使用注解@WebListener
 */
//@WebListener
public class MyListener implements ServletContextListener, ServletContextAttributeListener {
    //监听创建
    @Override
    public void contextInitialized(ServletContextEvent event) {
        System.out.println(new Timestamp(System.currentTimeMillis()) + " 创建了上下文对象：" + event.getServletContext());
    }

    //监听销毁
    @Override
    public void contextDestroyed(ServletContextEvent event) {
        System.out.println(new Timestamp(System.currentTimeMillis()) + " 上下文对象销毁：" + event.getServletContext());
    }

    //添加属性时执行方法
    @Override
    public void attributeAdded(ServletContextAttributeEvent event) {
        System.out.println("添加了属性名：" + event.getName() + "，属性值：" + event.getValue());
    }

    //删除属性时执行方法
    @Override
    public void attributeRemoved(ServletContextAttributeEvent event) {
        System.out.println("删除了属性名：" + event.getName() + "，属性值：" + event.getValue());
    }

    //修改属性时执行方法
    @Override
    public void attributeReplaced(ServletContextAttributeEvent event) {
        System.out.println("修改了属性名：" + event.getName() + "，修改前属性值：" + event.getValue() + "，修改后属性值：" + event.getServletContext().getAttribute(event.getName()));
    }
}
```

###  小结

​	属性监听器有几个方法?

```
1. 监听添加
2. 监听修改
3. 监听删除
```



## 案例：ServletContextListener的应用

### 目标 

​	项目一开始需要创建一些数据表，在项目的使用过程中会添加一些测试数据。使用完了以后，希望下一次测试打开的项目，还是一个全新的表。

 1) 项目启动：创建新的空表

 2) 项目关闭：测试或使用完毕表以后，删除表。

### 执行效果

#### 控制台

&nbsp;![1552952406798](https://raw.githubusercontent.com/Kid-On-The-Road/Resources/main/笔记图片/过滤器&监听器/1552952406798.png)

#### 生成的MySQL

&nbsp;![1552952453673](https://raw.githubusercontent.com/Kid-On-The-Road/Resources/main/笔记图片/过滤器&监听器/1552952453673.png)

### 编写的类

1. 工具类，得到会话工厂
2. SystemDao类，表的创建与销毁
3. MyServletContextListener类，调用SystemDao类 

### 项目结构

![1565166622597](https://raw.githubusercontent.com/Kid-On-The-Road/Resources/main/笔记图片/过滤器&监听器/1565166622597.png) 

### 技术点

```
在url中要设置allowMultiQueries=true参数
表示可以在一个配置中执行多条SQL语句,多条SQL语句使用分号隔开
```

### 步骤

1. 创建SystemDao类，创建initTables()初始化表的方法，clearTables()删除所有表的操作。

2. 创建所有表和删除所有表

   ```mysql
   create table dept (id int primary key auto_increment, dept_name varchar(10));
   create table emp (id int primary key auto_increment, name varchar(20),  birthday date, dep_id int, foreign key (dep_id) references dept(id));
   
   drop table emp;
   drop table dept;
   ```

3. 在initTables中运行每一条DDL SQL语句。在clearTables()表中删除员工和部门表。

4. 在监听器中创建成员变量SystemDao，在Web创建的时候调用initTables方法，并输出信息。

5. 在Web退出的时候调用clearTables方法，删除表，并输出信息。 

### 代码

#### 测试数据

```mysql
-- 插入部门信息
insert into dept values(null,'开发部');
insert into dept values(null,'销售部');

-- 插入员工信息
insert into emp values(null,'张三','2001-01-11',1);
insert into emp values(null,'李四','2002-02-12',1);
insert into emp values(null,'王五','2003-03-13',2);
insert into emp values(null,'刘六','2004-04-14',null);
```

#### SystemDao

```java
package com.itheima.dao;

/**
 * 持久层
 */
public interface SystemDao {

    /**
     * 创建所有的表
     */
    void initTables();

    /**
     * 删除所有的表
     */
    void clearTables();
}

```

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd" >
<mapper namespace="com.itheima.dao.SystemDao">

    <update id="initTables">
        create table dept (id int primary key auto_increment, dept_name varchar(10));
        create table emp (id int primary key auto_increment, name varchar(20),  birthday date, dep_id int, foreign key (dep_id) references dept(id));
    </update>

    <update id="clearTables">
        drop table emp;
        drop table dept;
    </update>
</mapper>
```

```java
package com.itheima.dao.impl;

import com.itheima.dao.SystemDao;
import com.itheima.utils.SqlSessionUtils;
import org.apache.ibatis.session.SqlSession;

/**
 * DAO的实现类
 */
public class SystemDaoImpl implements SystemDao {
    @Override
    public void initTables() {
        //1. 得到会话对象
        SqlSession session = SqlSessionUtils.getSession();
        //2. 得到接口的代理对象
        SystemDao systemDao = session.getMapper(SystemDao.class);
        //3. 执行接口中方法
        systemDao.initTables();
        //4. 提交事务
        session.commit();
        //5. 关闭会话
        session.close();
    }

    @Override
    public void clearTables() {
        //1. 得到会话对象
        SqlSession session = SqlSessionUtils.getSession();
        //2. 得到接口的代理对象
        SystemDao systemDao = session.getMapper(SystemDao.class);
        //3. 执行接口中方法
        systemDao.clearTables();
        //4. 提交事务
        session.commit();
        //5. 关闭会话
        session.close();
    }
}
```



#### MyServletContextListener

```java
package com.itheima.listener;

import com.itheima.dao.SystemDao;
import com.itheima.dao.impl.SystemDaoImpl;

import javax.servlet.ServletContextEvent;
import javax.servlet.ServletContextListener;
import javax.servlet.annotation.WebListener;

/**
 * 监听上下文的创建和销毁
 */
@WebListener
public class MyListener  implements ServletContextListener {

    private SystemDao systemDao = new SystemDaoImpl();

    @Override
    public void contextInitialized(ServletContextEvent servletContextEvent) {
        System.out.println("服务器启动，创建所有的表");
        systemDao.initTables();
    }

    @Override
    public void contextDestroyed(ServletContextEvent servletContextEvent) {
        System.out.println("服务器关闭，删除所有的表");
        systemDao.clearTables();
    }
}

```



### 小结

1. 用到DAO，编写两个方法，一个用来创建所有的表，一个用来删除所有的表
2. 在监听器中调用DAO的方法，在系统启动就创建所有的表，在系统关闭删除所有的表



## 案例part1：修改联系人的数据回显

### 目标

![1563196032972](https://raw.githubusercontent.com/Kid-On-The-Road/Resources/main/笔记图片/过滤器&监听器/1563196032972.png)

### 时序图

![1572597683598](https://raw.githubusercontent.com/Kid-On-The-Road/Resources/main/笔记图片/过滤器&监听器/1572597683598.png)

### 代码

DAO

```java
/**
 * 通过ID查询1个联系人
 */
@Select("select * from contact where id=#{id}")
Contact findById(int id);
```

```
@Override
public Contact findById(int id) {
    //1.得到会话对象
    SqlSession session = SqlSessionUtils.getSession();
    //2. 通过会话对象得到代理对象
    ContactDao contactDao = session.getMapper(ContactDao.class);
    //3. 调用接口中方法
    Contact contact = contactDao.findById(id);
    //4. 关闭会话
    session.close();
    //5. 返回查询的联系人
    return contact;
}
```

Service

```java
/**
 * 通过id查询联系人
 */
public Contact findById(int id) {
    return contactDao.findById(id);
}
```

Servlet

```java
package com.itheima.servlet;

import com.itheima.entity.Contact;
import com.itheima.service.ContactService;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

/**
 * 通过id查询1个联系人
 */
@WebServlet("/query")
public class QueryContactServlet extends HttpServlet {

    private ContactService contactService = new ContactService();

    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        //1. 得到id的值，转成int类型
        int id = Integer.parseInt(request.getParameter("id"));

        //2. 调用业务层得到一个联系人
        Contact contact = contactService.findById(id);

        //3. 将联系人放在请求域
        request.setAttribute("contact", contact);

        //定义一个城市的数组
        String[] cities = {"广东", "广西", "湖南", "福建", "海南"};
        request.setAttribute("cities", cities);

        //4. 转发到update.jsp
        request.getRequestDispatcher("/update.jsp").forward(request, response);
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        this.doPost(request, response);
    }
}

```

list.jsp

```jsp
<td><a class="btn btn-default btn-sm" href="query?id=${contact.id}">修改</a>
```

update.jsp

```jsp
<%@ page language="java" pageEncoding="UTF-8" %>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>
<%
    String path = request.getContextPath();
    String basePath = request.getScheme() + "://" + request.getServerName() + ":" + request.getServerPort() + path + "/";
%>
<!DOCTYPE html>
<!-- 网页使用的语言 -->
<html lang="zh-CN">
<head>
    <base href="<%=basePath%>"/>
    <!-- 指定字符集 -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>修改用户</title>

    <link href="css/bootstrap.min.css" rel="stylesheet">
    <script src="js/jquery-2.1.0.min.js"></script>
    <script src="js/bootstrap.min.js"></script>

</head>
<body>
<div class="container" style="width: 400px;">
    <h3 style="text-align: center;">修改联系人</h3>
    <form action="update" method="post">
        <div class="form-group">
            <label for="name">姓名：</label>
            <input type="text" class="form-control" id="name" name="name" placeholder="请输入姓名" value="${contact.name}"/>
        </div>

        <div class="form-group">
            <label>性别：</label>
            <input type="radio" name="sex" value="男"  ${contact.sex=="男"?'checked="checked"':""}/>男
            <input type="radio" name="sex" value="女"  ${contact.sex=="女"?'checked="checked"':""}/>女
        </div>

        <div class="form-group">
            <label for="age">年龄：</label>
            <input type="number" class="form-control" id="age" name="age" placeholder="请输入年龄" value="${contact.age}"/>
        </div>

        <div class="form-group">
            <label for="address">籍贯：</label>
            <select name="address" class="form-control" id="address">
                <c:forEach items="${cities}" var="city">
                    <option value="${city}" ${contact.address==city?'selected="selected"':""}>${city}</option>
                </c:forEach>
            </select>
        </div>

        <div class="form-group">
            <label for="qq">QQ：</label>
            <input type="number" class="form-control" name="qq" placeholder="请输入QQ号码" id="qq" value="${contact.qq}"/>
        </div>

        <div class="form-group">
            <label for="email">Email：</label>
            <input type="text" class="form-control" name="email" placeholder="请输入邮箱地址" id="email" value="${contact.email}"/>
        </div>

        <div class="form-group" style="text-align: center">
            <input class="btn btn-primary" type="submit" value="提交"/>
            <input class="btn btn-default" type="reset" value="重置"/>
            <input class="btn btn-default" type="button" value="返回" onclick="history.back()"/>
        </div>
    </form>
</div>
</body>
</html>
```

### 小结

1. 提交id给servlet
2. servlet调用业务层
3. 业务层调用dao
4. 查询到1个联系人
5. 返回到页面显示出来



## 案例part2：修改联系人的操作

### 目标

1. 将修改后的数据写到数据库中
2. 再显示所有的联系人

### 时序图

![1572599155202](https://raw.githubusercontent.com/Kid-On-The-Road/Resources/main/笔记图片/过滤器&监听器/1572599155202.png)

### 代码

DAO

```java
/**
 * 更新联系人
 */
@Update("update contact set name = #{name},sex = #{sex},age = #{age},address = #{address},qq = #{qq},email = #{email} where id = #{id}")
int updateContact(Contact contact);
```

```
@Override
public int updateContact(Contact contact) {
    //1.得到会话对象
    SqlSession session = SqlSessionUtils.getSession();
    //2. 通过会话对象得到代理对象
    ContactDao contactDao = session.getMapper(ContactDao.class);
    //3. 调用接口中方法
    int row = contactDao.updateContact(contact);
    //4. 关闭会话
    session.commit();
    session.close();
    return row;
}
```

Service

```java
/**
 * 更新1个联系人
 */
public void updateContact(Contact contact) {
    contactDao.updateContact(contact);
}
```

Servlet

```java
package com.itheima.servlet;

import com.itheima.entity.Contact;
import com.itheima.service.ContactService;
import org.apache.commons.beanutils.BeanUtils;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.util.Map;

@WebServlet("/update")
public class UpdateContactServlet extends HttpServlet {

    private ContactService contactService = new ContactService();

    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        //1. 得到表单提交的参数
        Map<String, String[]> map = request.getParameterMap();
        //2. 把表单的数据封装成Contact对象
        Contact contact = new Contact();
        try {
            BeanUtils.populate(contact,map);
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        } catch (InvocationTargetException e) {
            e.printStackTrace();
        }
        //3. 调用业务层更新
        contactService.updateContact(contact);
        //4. 重定向到list
        response.sendRedirect(request.getContextPath() + "/list");
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        this.doPost(request, response);
    }
}
```

update.jsp

```jsp
<%@ page language="java" pageEncoding="UTF-8" %>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>
<%
    String path = request.getContextPath();
    String basePath = request.getScheme() + "://" + request.getServerName() + ":" + request.getServerPort() + path + "/";
%>
<!DOCTYPE html>
<!-- 网页使用的语言 -->
<html lang="zh-CN">
<head>
    <base href="<%=basePath%>"/>
    <!-- 指定字符集 -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>修改用户</title>

    <link href="css/bootstrap.min.css" rel="stylesheet">
    <script src="js/jquery-2.1.0.min.js"></script>
    <script src="js/bootstrap.min.js"></script>

</head>
<body>
<div class="container" style="width: 400px;">
    <h3 style="text-align: center;">修改联系人</h3>
    <form action="update" method="post">
        <%--隐藏表单域--%>
        <input type="hidden" name="id" value="${contact.id}">
        <div class="form-group">
            <label for="name">姓名：</label>
            <input type="text" class="form-control" id="name" name="name" placeholder="请输入姓名" value="${contact.name}"/>
        </div>

        <div class="form-group">
            <label>性别：</label>
            <input type="radio" name="sex" value="男"  ${contact.sex=="男"?'checked="checked"':""}/>男
            <input type="radio" name="sex" value="女"  ${contact.sex=="女"?'checked="checked"':""}/>女
        </div>

        <div class="form-group">
            <label for="age">年龄：</label>
            <input type="number" class="form-control" id="age" name="age" placeholder="请输入年龄" value="${contact.age}"/>
        </div>

        <div class="form-group">
            <label for="address">籍贯：</label>
            <select name="address" class="form-control" id="address">
                <c:forEach items="${cities}" var="city">
                    <option value="${city}" ${contact.address==city?'selected="selected"':""}>${city}</option>
                </c:forEach>
            </select>
        </div>

        <div class="form-group">
            <label for="qq">QQ：</label>
            <input type="number" class="form-control" name="qq" placeholder="请输入QQ号码" id="qq" value="${contact.qq}"/>
        </div>

        <div class="form-group">
            <label for="email">Email：</label>
            <input type="text" class="form-control" name="email" placeholder="请输入邮箱地址" id="email" value="${contact.email}"/>
        </div>

        <div class="form-group" style="text-align: center">
            <input class="btn btn-primary" type="submit" value="提交"/>
            <input class="btn btn-default" type="reset" value="重置"/>
            <input class="btn btn-default" type="button" value="返回" onclick="history.back()"/>
        </div>
    </form>
</div>
</body>
</html>
```





## 案例part3：删除联系人

### DAO层

```java
/**
 * 删除联系人
 */
@Delete("delete from contact where id = #{id}")
int deleteContact(int id);
```

```java
@Override
public int deleteContact(int id) {
    //1.得到会话对象
    SqlSession session = SqlSessionUtils.getSession();
    //2. 通过会话对象得到代理对象
    ContactDao contactDao = session.getMapper(ContactDao.class);
    //3. 调用接口中方法
    int row = contactDao.deleteContact(id);
    //4. 关闭会话
    session.commit();
    session.close();
    return row;
}
```

### 业务层

```java
/**
 * 删除联系人
 */
public int deleteContact(int id) {
    return contactDao.deleteContact(id);
}
```

### Servlet

```java
package com.itheima.servlet;

import com.itheima.service.ContactService;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@WebServlet("/delete")
public class DeleteContactServlet extends HttpServlet {

    private ContactService contactService = new ContactService();

    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        //1.得到id
        int id = Integer.parseInt(request.getParameter("id"));

        //2. 调用业务层删除
        contactService.deleteContact(id);

        //3. 跳转到list
        response.sendRedirect(request.getContextPath() + "/list");
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        this.doPost(request, response);
    }
}
```

### list.jsp

```jsp
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<!DOCTYPE html>
<!-- 网页使用的语言 -->
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>显示联系人</title>

    <!-- 1. 导入CSS的全局样式 -->
    <link href="css/bootstrap.min.css" rel="stylesheet">
    <!-- 2. jQuery导入，建议使用1.9以上的版本 -->
    <script src="js/jquery-2.1.0.min.js"></script>
    <!-- 3. 导入bootstrap的js文件 -->
    <script src="js/bootstrap.min.js"></script>
    <style type="text/css">
        td, th {
            text-align: center;
        }
    </style>
</head>
<body>
<div class="container">
    <h3 style="text-align: center">显示所有联系人</h3>
    <table border="1" class="table table-bordered table-hover">
        <tr class="success">
            <th>编号</th>
            <th>姓名</th>
            <th>性别</th>
            <th>年龄</th>
            <th>籍贯</th>
            <th>QQ</th>
            <th>邮箱</th>
            <th>操作</th>
        </tr>
        <c:forEach items="${contacts}" var="contact">
        <tr>
            <td>${contact.id}</td>
            <td>${contact.name}</td>
            <td>${contact.sex}</td>
            <td>${contact.age}</td>
            <td>${contact.address}</td>
            <td>${contact.qq}</td>
            <td>${contact.email}</td>
            <%-- 访问Servlet，并且提供id的参数--%>
            <td><a class="btn btn-default btn-sm" href="query?id=${contact.id}">修改</a>&nbsp;
                <%--因为href是要跳转的地址，现在是调用JS代码，所以前面使用javascript:--%>
                <a class="btn btn-default btn-sm" href="javascript:deleteContact(${contact.id})">删除</a></td>
        </tr>
        </c:forEach>
        <tr>
            <td colspan="8" align="center"><a class="btn btn-primary" href="add.jsp">添加联系人</a></td>
        </tr>
    </table>
</div>
<script type="text/javascript">
    function deleteContact(id) {
        if (confirm("真的要删除这条记录吗?")) {
            location.href = "delete?id=" + id;
        }
    }
</script>
</body>
</html>

```





# 学习总结

1. 能够说出过滤器的作用

   1. 解决全局乱码问题
   2. 拦截非法的请求
   3. 过滤敏感的数据

   

2. 能够编写过滤器

   1. 创建一个类实现Filter接口
   2. 重写接口中所有的方法，其中doFilter()执行过滤的任务
   3. 使用web.xml进行配置，或@WebFilter("/url")注解

   

3. 能够说出过滤器生命周期相关方法

   | Filter接口中的方法                                           | 作用和执行次数        |
   | ------------------------------------------------------------ | --------------------- |
   | void   init(FilterConfig filterConfig)                       | 初始化的方法，执行1次 |
   | void   doFilter(ServletRequest request, <br />ServletResponse response, FilterChain chain) | 每次请求都会执行      |
   | public void   destroy()                                      | 销毁，服务器关闭      |

4. 能够根据过滤路径判断指定的过滤器是否起作用

   | 匹配方式     | 匹配哪些资源          |
   | ------------ | --------------------- |
   | 以/开头      | 精确匹配 /demo1       |
   |              | 目录匹配 /admin/*  /* |
   | 以扩展名结尾 | *.jsp  *.do           |

5. 能够说出什么是过滤器链

   1. web.xml配置：按配置的先后顺序
   2. 注解：按类名的字符串大小

   ![](https://raw.githubusercontent.com/Kid-On-The-Road/Resources/main/笔记图片/过滤器&监听器/1552919236666.png)

6. 能够编写过滤器解决全局乱码

   ![1552918911663](https://raw.githubusercontent.com/Kid-On-The-Road/Resources/main/笔记图片/过滤器&监听器/1552918911663.png)

7. 能够说出监听器的作用

   1. 监听作用域的创建和销毁
   2. 监听作用域中属性的增删改操作

8. 能够使用ServletContextListener监听器

   1. 创建一个类实现ServletContextListener接口
   2. 重写接口中2个方法：创建，销毁
   3. 在web.xml配置中或@WebListener注解