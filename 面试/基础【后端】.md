# 面向对象

## 什么是面向对象

```markdown
用代码去高度模拟现实世界的事物，从而让软件来解决人类的业务，为人类服务。 面向对象的代码是高度接近人类自然语言。 Java是面向对象的高级编程语言。 面向对象是用类和对象去描述万千事物的。
```

## 什么是对象？

```markdown
对象是真实存在的实例。 实例==对象。

总结： 
    有了类和对象就可以描述全部的事物。 必须先有类才能有对象。
```

## 面向对象的三大特征：封装，继承，多态。

### 封装：

```markdown
思想：
    合理隐藏，合理暴露。 
规范：
    成员变量一般要私有，方法一般要暴露，提供成套的getter+setter方法来暴露成员变量的取值和赋值。
封装的作用：
    提高安全性,提高代码的组件化思想。 
封装已经成为Java代码的规范，即使毫无意义，代码还是要按照封装的规范来书写。
```

### 继承：

```markdown
继承是Java中一般到特殊的关系，是一种子类到父类的关系。 
例如：学生类继承了人类。 猫类继承了动物类。

被继承的类称为：
    父类/超类。 
继承父类的类称为：
    子类。
```

#### 继承的作用：

```markdown
可以提高代码的复用，相同代码可以定义在父类中。 然后子类直接继承父类，就可以直接使用父类的这些代码了。 （相同代码重复利用）

子类更强大：
    子类不仅得到了父类的功能，它还有自己的功能。
```

#### 继承的特点：

```markdown
子类继承了一个父类，子类就可以直接得到父类的属性和行为了。
```

#### 继承的格式:

```java
子类 extends 父类{

        }
```

```markdown
小结:
    继承是子类到到父类的一种关系。 子类继承了一个父类，子类就可以直接得到父类的属性和行为了。 在Java中继承是 “is a ” 的关系。Cat extends Animal：猫是一个动物
在Java中，子类是更强大的，子类不仅继承了父类的功能，自己还可以定义自己的功能。
```

```java
public class ExtendsDemo {
}

// 父类
class Animal {
    public void run() {

    }
}

// 子类
class Cat extends Animal {

}
```

#### 继承的案例：

```markdown
案例（教务系统） 
    学生类（姓名，年龄，吃饭，特有功能：学习） 
    老师类（姓名，年龄，吃饭，特有功能：授课） 
    班主任（姓名，年龄，吃饭，特有功能：管理）

如果直接定义类会出现大量相同属性相同行为的重复代码。企业开发中不允许太多冗余代码。 
解决思路：
    把相同的属性和行为定义在一个父类中，然后让子类继承即可。

父类：People类(姓名，年龄，吃饭)
学生类（特有功能：学习） 老师类（特有功能：授课） 班主任（特有功能：管理）

小结：
    子类继续了父类，子类就直接得到了父类的属性和行为，直接可以直接用了。 
继承的作用：
    可以提高代码的复用性，节约代码，相同代码可以放在父类中定义。子类直接继续即可使用。
```

```java
//测试类
public class TestMain {
    public static void main(String[] args) {
        // 创建一个老师对象：
        Teacher boZai = new Teacher();
        boZai.setName("播仔老师");// 父类的
        boZai.setAge(35);// 父类的
        boZai.eat(); // 父类的
        boZai.teach(); // 子类的
    }
}

/**
 * 人类
 */
// 父类：人类
// 姓名，年龄，吃饭
public class People {
    private String name;
    private int age;

    public void eat() {
        System.out.println("人都要吃饭~~");
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}

/**
 * 学生类
 */
public class Student extends People {
    // 独有功能：
    public void study() {
        System.out.println(getName() + "正在认真听课~~~");
    }
}

/**
 * 老师类
 */
public class Teacher extends People {
    // 特有功能：授课
    public void teach() {
        System.out.println(getName() + "在认真的授课~");
    }
}
```

#### 子类不能继承的内容：

```markdown
确定观点： 
    子类是不能继承父类的构造器的。 子类有自己的构造器，父类的构造器是用来初始化父类对象的，子类无需继承。

争议观点： 
    子类是否可以继承父类的私有成员（成员变量，成员方法）？
    我认为子类是可以继承父类私有的成员的，只是不能直接访问而已。 
    子类是否可以继承父类的静态成员呢？
    我认为子类是不能继承父类的静态成员的，子类只是可以访问而已。
父类的静态成员可以被子类共享访问，共享并非继承。
```

```java
public class ExtendsDemo {
    public static void main(String[] args) {
        Dog d = new Dog();
//      d.name = "狗";
//      d.run();

        System.out.println(Dog.schoolName);
        Dog.inAddr();
    }
}

// 父类
class Animal {
    private String name;

    private void run() {

    }

    public static String schoolName = "黑马";

    public static void inAddr() {
        System.out.println("吉山区");
    }
}

// 子类
class Dog extends Animal {

}
```

#### 继承后成员变量的特点:

```markdown
就近原则： 
    子类有找子类 
    子类没有找父类 
    父类没有就报错
```

```java
public class TestDemo {
    public static void main(String[] args) {
        Cat cat = new Cat();
        System.out.println(cat.name); // 子类的
        System.out.println(cat.age); // 父类的
        //System.out.println(cat.sex); // 报错
    }
}

// 父类
class Animal {
    public String name = "动物";
    public int age = 100;
}

// 子类
class Cat extends Animal {
    public String name = "猫";
}
```

```markdown
继承后——super关键字访问父类成员变量:
super:
    代表了父类对象引用。 
this:
    代表了当前对象引用。

小结： 
    this可以访问当前子类对象的成员变量。 super可以在子类方法中访问父类的成员变量。
```

```java
public class TestDemo02 {
    public static void main(String[] args) {
        Student s = new Student();
        s.showName();
    }
}

class Human {
    public String name = "父类人";
}

class Student extends Human {
    public String name = "学生名称";

    public void showName() {
        String name = "局部名称";
        System.out.println(name);// 局部的name
        System.out.println(this.name);// 子类的name
        System.out.println(super.name);// 父类的name
    }
}
```

#### 继承后成员方法的特点：

```markdown
就近原则： 
    子类有找子类 
    子类没有找父类 
    父类没有就报错
```

```java
public class TestDemo {
    public static void main(String[] args) {
        Cat ddm = new Cat();
        ddm.run(); // 子类
        ddm.go(); // 父类
        // ddm.eat(); // 报错
    }
}

// 父类
class Animal {
    public void run() {
        System.out.println("动物可以跑~~");
    }

    public void go() {
        System.out.println("开始跑~~");
    }
}

// 子类
class Cat extends Animal {
    public void run() {
        System.out.println("猫跑的贼溜~~~");
    }
}
```

#### 方法重写:

##### 什么是方法重写？

```markdown
子类继承了父类，子类就得到了父类的某个方法。 但是子类觉得父类的该方法不够好或者无法满足自己的需求子类重写一个与父类该方法名称形参一样的方法来覆盖父类的该方法，这就是方法重写。
```
##### 方法重写的校验注解：@Override

```markdown
一个方法如果加上了@Override注解，这个方法必须是重写自父类的方法，且要成功重写，否则报错！ 
@Override作用就是约束该方法必须是重写的方法。 建议重写方法上都加上@Override：代码安全，可读性好，优雅。
```
##### 方法重写的要求：

```markdown
1.重写方法的方法名称和形参列表必须与父类被重写方法一样。 
2.重写方法的返回值类型必须与父类被重写方法的返回值类型相同或者范围更小。 
3.重写方法的访问权限修饰符必须与父类被重写方法的访问权限修饰符一样或者权限更大。
4.重写方法申明抛出的异常，应该与父类被重写方法申明抛出的异常一样或者范围更小。

按照规范，重写方法建议：申明不变，重新实现。
```

```markdown
小结： 
    方法重写，子类写一个与父类一样的方法覆盖父类的方法。 
方法重写的校验注解：
    @Override 
一般重写方法：
    申明不变，重新实现。
```

```java
public class TestDemo {
    public static void main(String[] args) {
        Cat ddm = new Cat();
        ddm.run(); // 子类
    }
}

// 父类
class Animal {
    public void run() {
        System.out.println("动物可以跑~~");
    }
}

// 子类
class Cat extends Animal {
    @Override
    public void run() {
        System.out.println("猫跑的贼溜~~~");
    }
}
```

#### 继承后super访问父类方法:

```markdown
可以在子类的实例方法中通过super去访问父类的被重写的方法。
```

```java
public class TestDemo {
    public static void main(String[] args) {
        Cat ddm = new Cat();
        ddm.go();
    }
}

// 父类
class Animal {
    public void run() {
        System.out.println("动物可以跑~~");
    }
}

// 子类
class Cat extends Animal {
    @Override
    public void run() {
        System.out.println("猫跑的贼溜~~~");
    }

    public void go() {
        super.run(); // 父类的
        run(); // 子类的
    }
}
```

#### 继承后构造器的特点:

```markdown
特点： 
    子类的全部构造器默认一定会先调用一次父类的无参数构造器再执行自己。 
为什么子类构造器一定要先调用父类的无参数构造器？
    1.子类的构造器的第一行默认有一个super()调用父类的无参数构造器，这行代码默认就存在，不写也有
    2.先有爸爸才有儿子 子类继承了父类，调用子类构造器初始化子类对象的时候，必须先调用父类构造器初始化继承 自父类的成员。
```

```java
public class TestDemo {
    public static void main(String[] args) {
        Dog dog = new Dog();
        Dog dog1 = new Dog("泰迪");
    }
}

class Dog extends Animal {
    public Dog() {
        super();// 根据参数匹配默认调用父类的无参数构造器，这行代码默认就存在，不写也有
        System.out.println("子类Dog的无参数构造器被执行");
    }

    public Dog(String name) {
        super();// 根据参数匹配默认调用父类的无参数构造器，这行代码默认就存在，不写也有
        System.out.println("子类Dog的有参数构造器被执行");
    }
}

class Animal {
    public Animal() {
        System.out.println("父类Animal的无参数构造器被执行");
    }
}

```

#### 子类构造器中通过super(....)调用父类构造器:

```markdown
子类构造器的第一行可以通过super(...)根据参数匹配调用父类的构造器。初始化继承自父类的成员变量数据。
```

```java
public class TestDemo {
    public static void main(String[] args) {
        Student zhaoMing = new Student("赵敏", 23, '女');
        zhaoMing.study();
    }
}

class Student extends People {
    public Student(String name, int age, char sex) {
        super(name, age, sex); // 子类构造器调用父类构造器初始化继承自父类的成员变量数据。
    }

    public void study() {
        System.out.println(getName() + "-->"
                + getAge() + "-->" + getSex() + ":在认真的学习！");
    }
}

// 父类
class People {
    private String name;
    private int age;
    private char sex;

    public People(String name, int age, char sex) {
        this.name = name;
        this.age = age;
        this.sex = sex;
    }

    public People() {
    }


    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public char getSex() {
        return sex;
    }

    public void setSex(char sex) {
        this.sex = sex;
    }
}
```

#### this\_super使用总结:

```markdown
this：
    代表当前本类对象(子类)
super:
    代表父类对象引用。

this用在本类中可以访问本类对象的成员： 
    this.本类成员变量。(this可以省略不写,假如不冲突!!)
    this.本类成员方法。(this可以省略不写)
this(...):
    在本类构造器中访问本类其他构造器。

super用在本类中访问父类的成员:
    super.父类成员变量。 
    super.父类成员方法。 
super(...): 
    在本类构造器中访问父类其他构造器。

拓展：
    this(...):在本类构造器中访问本类其他构造器:借用兄弟构造器的功能。

小结： 
    this(...)在本类构造器中根据参数匹配调用本类中其他构造器。借用兄弟构造器的功能。 this的目的在于借用本类兄弟构造器的功能。

注意：
    this(...)调用构造器必须写在代码第一行。 
    super(...)必须放在构造器的第一行 
    super(...)和this(...)不能同时出现在构造器中，因为都要在第一行。
```

```java
public class ThisDemo01 {
    public static void main(String[] args) {
        // 希望不给学校信息，默认就是黑马的学生
        Student s3 = new Student("孙悟空", 1000);
        System.out.println(s3.getName());
        System.out.println(s3.getAge());
        System.out.println(s3.getSchoolName());

        Student s5 = new Student("蜘蛛精", 2000, "清华大学");
        System.out.println(s5.getName());
        System.out.println(s5.getAge());
        System.out.println(s5.getSchoolName());
    }
}

class Student {
    private String name;
    private int age;
    private String schoolName;

    public Student() {
    }

    public Student(String name, int age) {
        this(name, age, "黑马");// 调用本类兄弟构造器
    }

    public Student(String name, int age, String schoolName) {
        this.name = name;
        this.age = age;
        this.schoolName = schoolName;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getSchoolName() {
        return schoolName;
    }

    public void setSchoolName(String schoolName) {
        this.schoolName = schoolName;
    }
}
```

#### 继承的特点:

```markdown
1.Java是单继承的:
    一个类只能继承一个直接父类。 
面试题：为什么Java是单继承？ 
答：反证法：假如Java可以多继承。 
2.但是一个类可以间接继承多个父类.可以多层继承。 
3.一个父类可以有多个子类。
4.Java中的祖宗类是Object类,一个类要么默认继承了Object类,要么间接继承了Object
```

```java
//请看如下代码：
class A {
    public void test() {
        System.out.println("A");
    }
}

class B {
    public void test() {
        System.out.println("B");
    }
}

class C extends A, B {
    public static void main(String[] args) {
        C c = new C();
        c.test(); // 出现了类的二义性，所以Java不能多继承。只能单继承！
    }
}
```

```java
public class ExtendsDemo {
}

class A {
}

class B extends A {
}

class C extends B {
}
```
### 多态
#### 多态的形式：
```markdown
父类名称 对象名称 = new 子类构造器;
接口名称 对象名称 = new 实现类构造器;

父类的类型范围 > 子类的类型范围。
```

#### 多态的概念：
```markdown
相同类型的行为，在不同的状态下可以表现出不同的特征。
```
#### 多态的识别技巧：

```markdown
对于方法的调用：
    编译看左边，运行看右边。
对于变量的调用：
    编译看左边，运行也看左边。
```
#### 多态的使用前提：
```markdown
1.必须有继承或者实现关系。
2.必须存在父类类型的变量引用子类类型的对象。
3.存在方法重写。
```

```java
public class PolymorphicDemo {
    public static void main(String[] args) {
        //父类名称 对象名称 = new 子类构造器;
        Animal a = new Wolf();
        a.run(); // 编译看左边，运行看右边。
        System.out.println(a.name); // 编译看左边，运行也看左边。

        Animal a1 = new Tiger();
        a1.run();   // 编译看左边，运行看右边。
        System.out.println(a.name); // // 编译看左边，运行也看左边。

    }
}

class Animal{
    public String name = "动物";
    public void run(){
        System.out.println("动物可以跑~~~");
    }
}

class Wolf extends Animal{
    public String name = "狼";
    @Override
    public void run(){
        System.out.println("狼跑的贼贼溜~~~");
    }
}

class Tiger extends Animal{
    public String name = "老虎";
    @Override
    public void run(){
        System.out.println("老虎跑的贼贼溜~~~");
    }
}
```
#### 多态的优劣势:
##### 优势：
```markdown
1.在多态形式下，右边对象可以实现组件化切换，业务功能也随之改变，
后续代码无需改变，便于扩展和维护。
2.实际开发的过程中，父类类型作为方法形式参数，传递子类对象给方法，
可以传入一切子类对象进行方法的调用，更能体现出多态的扩展性与便利.
```
##### 劣势：
```markdown
1.多态形式下，不能直接调用子类特有的功能。
```

```java
public class PolymorphicDemo {
    public static void main(String[] args) {
        Animal a = new Cat();
        a.run();
        // a.catchMouse(); // 报错了，多态形式下，不能直接调用子类特有的功能。

        Animal a1 = new Cat();
        go(a1);
        Animal a2 = new Wolf();
        go(a2);
    }

    // 动物大赛:全部动物都可以进来。
    public static void go(Animal c){
        c.run();
    }
}
class Animal{
    public void run(){
        System.out.println("动物可以跑~~~");
    }
}

class Cat extends Animal{
    @Override
    public void run(){
        System.out.println("猫跑的贼贼快~~~");
    }
    // 特有功能
    public void catchMouse(){
        System.out.println("🐱抓🐀~~~~~");
    }
}

class Wolf extends Animal{
    @Override
    public void run(){
        System.out.println("狼跑的贼贼溜~~~");
    }
    // 特有功能
    public void catchSheep(){
        System.out.println("🐺抓🐏吃~~~~~");
    }
}
```
#### 多态\_引用类型自动类型转换:
```markdown
1.小范围类型的变量或者值可以直接赋值给大范围类型的变量。
2.大范围类型的变量或者值必须强制类型转换给小范围类型的变量。

引用数据类型转换的思想是一样的:
父类类型的范围 > 子类类型的范围。
引用数据类型的自动类型转换语法：
    1.子类类型的对象或者变量可以自动类型转换赋值给父类类型的变量。
```

```markdown
小结：
    有继承关系的两个类，子类对象可以直接赋值给父类类型的变量。
    自动类型转换没有解决多态的劣势。
```

```java
public class PolymorphicDemo {
    public static void main(String[] args) {
        Animal c = new Cat(); //  引用数据类型的自动类型转换

        Cat cat = new Cat();
        Animal c1 = cat; // 引用数据类型的自动类型转换
    }
}

class Animal{

}

class Cat extends Animal{

}
```
#### 多态\_引用类型强制类型转换:
##### 引用类型强制类型转换的语法：
```markdown
1.父类类型的变量或者对象必须强制类型转换成子类类型的变量，否则报错!
```

##### 强制类型转换的格式：
```markdown
类型 变量名称 = (类型)(对象或者变量)

注意：
    只要有继承/实现关系的两个类就可以进行强制类型转换，编译阶段一定不会报错但是运行阶段可能出错。

    Java建议在进行强制类型转换之前，先进行变量的真实类型判断，再进行强制类型转换。
    变量 instanceof 真实类型：判断变量是否是后面的类型或者其子类，是返回true ,反之。
```

```markdown
小结：
    父类类型的变量必须强制类型转换给子类类型的变量。
    只要有继承/实现关系的两个类就可以进行强制类型转换，编译阶段一定不会报错，但是运行阶段可能出错。
    Java建议在进行强制类型转换之前，先进行变量的真实类型判断，再进行强制类型转换。
    强制类型转换解决了多态的劣势。
```

```java
public class PolymorphicDemo {
    public static void main(String[] args) {
        Animal a = new Cat();
        a.run();

        Cat c = (Cat) a;
        c.catchMouse();

        System.out.println("-------------------");

        Animal a1 = new Cat();
        //Cat c2 = (Cat) a1; // 运行阶段出现了类型转换异常：ClassCastException.
        if(a1 instanceof Wolf){
            Wolf w = (Wolf) a1;
            w.catchSheep();
        }else if(a1 instanceof Cat){
            Cat c3 = (Cat) a1;
            c3.catchMouse();
        }

    }
}

class Animal{
    public void run(){
        System.out.println("动物可以跑~~~");
    }
}
class Cat extends Animal{
    @Override
    public void run(){
        System.out.println("猫跑的贼贼快~~~");
    }
    // 特有功能
    public void catchMouse(){
        System.out.println("🐱抓🐀~~~~~");
    }
}

class Wolf extends Animal{
    @Override
    public void run(){
        System.out.println("狼跑的贼贼溜~~~");
    }
    // 特有功能
    public void catchSheep(){
        System.out.println("🐺抓🐏吃~~~~~");
    }
}
```
#### 多态接口的综合案例:
```markdown
拓展：面向对象思想设计一个电脑对象，可以接入2个USB设备
    （鼠标，键盘： 实现接入，调用独有功能，拔出）。

分析：
    （1）提供2个USB设备。（USB设备必须满足：接入和拔出的功能）
    （2）定义一个USB的接口（申明USB设备的规范必须是实现接入和拔出的功能）
    （3）开始定义2个真实的实现类代表书鼠标和键盘
    （4）定义一个电脑类。

小结：
    这是一种高度面向对象的代码风格，也是Java以后开发功能代码的语法形式。
```

```java
public class Demo {
    public static void main(String[] args) {
        // a.买一部电脑
        Computer mac = new Computer();
        // b.买2个USB设备
        Mouse m = new Mouse("罗技鼠标");
        mac.install(m);

        KeyBoard k = new KeyBoard("双飞燕键盘");
        mac.install(k);
    }
}

// 3.定义一个计算机：Computer
class Computer {
    // 必须提供一个连接USB设备的入口
    public void install(USB usb){
        //  接入
        usb.connect();
        // 独有功能： usb可能是键盘，鼠标。。。
        if(usb instanceof Mouse){
            Mouse m = (Mouse) usb;
            m.dbClick();
        }else if(usb instanceof KeyBoard){
            KeyBoard k = (KeyBoard) usb;
            k.keyDown();
        }
        // 拔出
        usb.unconnection();
    }
}

// 2.定义两个USB设备类。
class Mouse implements USB{

    private String name ;
    public Mouse(String name){
        this.name = name ;
    }

    // 独有功能
    public void dbClick(){
        System.out.println(name+"双击了老铁666~~~~");
    }

    @Override
    public void connect() {
        System.out.println(name+"成功接入了电脑！");
    }

    @Override
    public void unconnection() {
        System.out.println(name+"成功拔出了电脑！");
    }
}

class KeyBoard implements USB {
    private String name ;
    public KeyBoard(String name){
        this.name = name ;
    }

    // 独有功能
    public void keyDown(){
        System.out.println(name+"写下了：来了，老弟，点亮小红心~~~");
    }

    @Override
    public void connect() {
        System.out.println(name+"成功接入了电脑！");
    }

    @Override
    public void unconnection() {
        System.out.println(name+"成功拔出了电脑！");
    }
}
// 1.定义一个USB的接口，代表了USB规范：接入，拔出。
interface USB {
    void connect(); // 接入
    void unconnection(); // 拔出
}
```
# 类

## 什么是类?

```markdown
类是相同事物共同特征的描述。任何事物都是属于一个类的。 人类，学生类。 类只能描述一类事物，并不能描述具体的某个对象。
```

## 如何定义类?

```Java
修饰符

class 类名 {

}
```

```markdown
1.类名首字母应该大小（满足驼峰模式）：StudentName. 
2.一个Java代码中可以定义多个类。 
3.只能有一个类用public修饰，而且public修饰的类名必须成为Java的文件名称。 
4.规范上来说，在实际开发中，建议一个Java代码中只定义一个类。
```

## 类中的成分（类中有且仅有5大成分，五大金刚）

```Java
修饰符

class 类名 {
    -a.成员变量Field：描述类或者对象的属性信息的。
            -b.成员方法Method：描述类或者对象的行为的。
            -c.构造器（构造方法,Constructor）:初始化类的一个对象返回。
            -d.代码块：
            -e.内部类：
    类下只要不是这5大成分代码就报错！
}
```

### 成员变量：

#### 静态成员变量（类变量）：

```markdown
有static修饰的成员变量称为静态成员变量也叫类变量，属于类本身的，直接用类名访问即可。
```

```markdown
静态成员变量的访问格式： -- 类名.静态成员变量。 -- 对象.静态成员变量。(不建议的)
```

#### 实例成员变量

```markdown
无static修饰的成员变量称为实例成员变量，属于类的每个对象的，必须用类的对象来访问。
```

```markdown
实例成员变量的访问格式：
     对象.实例成员变量。
```

```markdown
总结：
    静态成员变量只有一份，属于类，所以被类和类的全部对象共享访问。 
注意：
    面试中如果发现有用对象访问静态成员变量，可以直接改成用类名访问再解答。 实例成员变量属于类的每个对象的，必须先创建对象，然后用对象访问。
```

```java
public class Student {
    // 实例成员变量 :无static修饰，属于类的每个对象的,必须用类的对象来访问。
    private String name;
    private int age;
    // 静态成员变量：有static修饰，属于类，与类一起加载，只有一份，直接用类名访问即可。
    public static String schoolName = "黑马";

    public static void main(String[] args) {
        // 1.静态成员变量： 类名.静态成员变量。
        System.out.println(Student.schoolName);
        // 注意：同一个类中访问静态成员变量可以省略类名不写
        System.out.println(schoolName);

        // 2.实例成员变量 ：对象.实例成员变量。
        // System.out.println(name); // 报错了
        Student zzj = new Student();
        zzj.name = "猪八戒";
        System.out.println(zzj.name);
        System.out.println(zzj.age);


        // 3.静态成员变量：对象.静态成员变量。(不建议的)
        System.out.println(zzj.schoolName);
    }
}
```

### 成员方法：

#### 静态方法

```markdown
有static修饰的成员方法称为静态方法也叫类方法，属于类本身的，直接用类名访问即可。
```

```markdown
静态方法的访问格式：
    类名.静态方法。
    对象.静态方法。（不推荐）
```

#### 实例方法

```markdown
无static修饰的成员方法称为实例方法，属于类的每个对象的，必须用类的对象来访问。
```

```markdown
实例方法的访问格式：
    对象.实例方法。
```

```markdown
小结：
    静态方法，属于类，可以被类和对象共享访问。 实例方法，属于对象的，必须创建对象来访问，否则报错！
-------------面试问答题的拓展，代码语法内容--------------------------
实例方法是否可以直接访问实例变量? 可以的,实例方法和实例变量都属于同一个对象。
实例方法是否可以直接访问静态变量？可以的,静态变量只有一份，可以被共享。 
实例方法是否可以直接访问实例方法？可以的，实例方法都是属于同一个对象。 
实例方法是否可以直接访问静态方法？可以的，静态方法可以被共享访问。
静态方法是否可以直接访问实例变量? 不可以的，实例成员变量必须用对象访问。 
静态方法是否可以直接访问静态变量？可以的，静态变量可以被共享。 
静态方法是否可以直接访问实例方法？不可以的，实例方法必须用对象访问。
静态方法是否可以直接访问静态方法？ 可以的，静态方法可以被共享访问
---------------------------------------------------------------

成员变量有两种：
    有static修饰的属于类叫静态成员变量，与类一起加载一次，直接用类名调用即可。
    无static修饰的属于类的每个对象的叫实例成员变量，与类的对象一起加载，对象有多少个，实例成员变量就加载多少份。必须用类的对象调用。

成员方法有两种：
    有static修饰的属于类叫静态方法，直接用类名调用即可。
    无static修饰的属于类的每个对象的叫实例方法，必须用类的对象调用。
```

```java
public class Student {
    // 实例成员变量
    private String name;
    private int age;

    public static void go() {
        System.out.println("跑的贼快~~~");
    }

    // 1.实例方法:无static修饰，属于类的对象的。
    public void run() {
        System.out.println(this.name + "-->" + this.age + "岁：跑的贼快~~~");
    }

    // 2.静态方法：有static修饰，属于类，直接用类调用即可
    public static void inAddr() {
        System.out.println("我们都在吉山区！！");
    }

    public static void main(String[] args) {
        // 1.静态方法：类名.静态方法
        Student.inAddr();
        // 注意：同一个类中静态方法的调用可以省略类名不写。
        inAddr();

        // 2.实例方法：对象.实例方法
        // run(); // 报错了！
        Student ss = new Student();
        ss.name = "莎莎";
        ss.age = 1000;
        ss.run();

        // 3.静态方法：对象.静态方法（不推荐）
        ss.inAddr();
    }
}
```

### 构造器：

```markdown
初始化类的一个对象返回。
格式：
    修饰符 类名称(形参列表){

    } 
创建对象： 
    类名 对象名称 = new 构造器;
构造器有两种：
    有参构造器，无参数构造器。
特点：
    一个类默认自带一个无参数构造器，但是如果我们自己定义了有参数构造器那么默认的无参数构造器就消失了。
```

#### this关键字：

```markdown
this代表了当前对象的引用。
this可以出现在构造器和方法中。
this出现在构造器中代表构造器正在初始化的对象。
this出现在方法中，哪个对象调用方法，this就代表哪个对象。
this可以访问对象的成员变量，区分成员变量是局部的还是对象中的成员变量。
```

```java
public class ClassDemo {
    public static void main(String[] args) {
        Student zzj = new Student();
        zzj.setName("猪刚鬣");

        Student swk = new Student("齐天大圣", 2000);
        System.out.println(swk.getName());
    }
}

class Student {
    // 成员变量
    private String name;
    private int age;

    public Student() {
    }

    public Student(String name, int age) {
        // this出现在构造器中代表构造器正在初始化的对象。
        this.name = name; // swk.name = 齐天大圣
        this.age = age;  // swk.age = 2000
    }

    public String getName() {
        return name; // swk.name
    }

    public void setName(String name) {
        //  this出现在方法中，哪个对象调用方法，this就代表哪个对象。
        this.name = name; // zzj.name = 猪刚鬣
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}
```

#### static关键字

```markdown
引入： 
    我们之前定义了很多成员变量（name , age , sex）其实我们只写了一份，但是发现每个对象都可以用，就说明Java中这些成员变量或者方法是存在所属性的。 有些是属于对象的，有些是属于类本身的。

Java是通过成员变量是否有static修饰来区分是类的还是属于对象的。

static == 静态 == 修饰的成员（方法和成员变量）属于类本身的。
```

## 抽象类

```markdown
引入:
    父类觉得子类一定要做某个功能，但是每个子类实现是不一样的。 子类也只会调用自己重写的方法，所以父类的该方法定义成抽象方法。 约束子类一定要重写该方法。拥有抽象方法的类就必须定义抽象类。 
小结：
    抽象方法是有abstract修饰，只有方法签名，没有方法体。 拥有抽象方法的类必须定义成抽象类，必须加abstract修饰。 子类继承了抽象类必须重写抽象方法。
```

### 抽象方法：

```java
//有abstract修饰，只有方法签名，没有方法体。
public abstract void run();
```

### 抽象类的定义：

```markdown
有abstract修饰的类就是抽象类。
```

```java
public class AbstractDemo {
    public static void main(String[] args) {
        Wolf qpl = new Wolf();
        qpl.run();

        Cat dlam = new Cat();
        dlam.run();
    }
}

// 抽象类
abstract class Animal {
    // 抽象方法
    public abstract void run();
}

class Wolf extends Animal {
    @Override
    public void run() {
        System.out.println("🐺跑的贼贼快~~");
    }
}

class Cat extends Animal {
    @Override
    public void run() {
        System.out.println("🐱跑的贼快~~");
    }
}
```

### 抽象类的使用：

```markdown
一个类继承了抽象类，必须重写完抽象类的全部抽象方法，否则这个类也必须定义成抽象类。
```

```java
public class AbstractDemo {
    public static void main(String[] args) {
        Teacher boZai = new Teacher();
        boZai.work();
        boZai.eat();
    }
}

// 开发一个教务系统：老师，班主任（工作，吃饭）
abstract class People {
    public abstract void work(); // 工作

    public abstract void eat(); // 吃饭
}

//abstract class Manager extends People{
//    @Override
//    public void work() {
//
//    }
//}

// ALT+ENTER
class Teacher extends People {
    @Override
    public void work() {
        System.out.println("老师要授课~~~");
    }

    @Override
    public void eat() {
        System.out.println("老师讲课很累吃的很多~~~");
    }
}
```

### 抽象类的特征：有得有失。

```markdown
有得：
    抽象类得到了拥有抽象方法的能力。 失去：抽象类失去了创建对象的能力。 抽象类除了有得有失，其他都具备（成员变量，普通方法，构造器都有）。

面试题：
    抽象类是否有构造器? 抽象类是否可以创建对象? 为什么？ 
答： 
    抽象类一定有构造器，抽象类就是被子类继承，子类需要调用父类构造器。 抽象类虽然有构造器但是抽象类不能创建对象。
    抽象类中可能存在抽象方法，抽象方法是不能被调用执行的，所以抽象类不能创建对象。 抽象本身意味着不能被实例化。 
小结： 
    抽象类得到了拥有抽象方法的能力，失去了创建对象的能力。 抽象类其他成分（成员变量，普通方法，构造器都有）都具备。
```

```java
public class AbstractDemo {
    public static void main(String[] args) {
//        People p = new People(); // 抽象类不能创建对象。
//        p.run(); // 抽象方法根本不能调用执行，因为没有方法体，所以抽象类不能创建对象。
    }
}

abstract class People {
    private String name;
    private int age;

    public People() {

    }

    public abstract void run();

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}
```

### 抽象类的意义:

```markdown
抽象类存在的意义有两点： 
    （1）被继承，抽象类就是为了被子类继承，否则抽象类将毫无意义。(核心意义)
    （2）抽象类体现的是"模板思想"：部分实现，部分抽象。（拓展）
     可以使用抽象类设计一个模板模式。
```

```java
public class ExtendsDemo {
}

class Cat extends Animal {
    @Override
    public void run() {

    }
}

abstract class Animal {
    private String name;
    private int age;

    public Animal() {
    }

    public Animal(String name, int age) {
        this.name = name;
        this.age = age;
    }

    // 抽象方法
    public abstract void run();

    public void sing() {
        System.out.println("唱歌！");
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}
```

### 抽象类设计模板模式:

#### 设计模式：

```markdown
是前人（技术大牛，或者一些技术协会，或者一些大型知名的IT公司）已经研发好或者设计好的优秀软件设计思想， 后来者可以直接使用就能够得到很好的软件模式。

模板模式是一种设计模式思想： 
模板模式的作用：
    部分实现，部分抽象，可以极大的简化功能代码，提高开发效率

写一个模板模式的案例：
    作文模板。 作文模板： 标题和第一段 以及最后一段是固定的， 正文部分交给使用模板的人自己来实现。

小结： 
    模板模式是部分实现，部分抽象，确定的部分模板直接实现，不确定的部分 定义成抽象方法交给使用模板的人实现。
```

```java
public class ExtendsDemo {
    public static void main(String[] args) {
        Student lty = new Student();
        lty.write();

        Teacher boZai = new Teacher();
        boZai.write();
    }
}

class Teacher extends Template {
    @Override
    public String writeMain() {
        // 4
        return "\t\t我爸也挺好的。";
    }
}

class Student extends Template {
    @Override
    public String writeMain() {
        // 4
        return "\t\t我爸爸是区长，所以我开车贼溜，想怼谁就怼谁，你敢叼我吗？";
    }
}

abstract class Template {
    // 1.标题是固定的，实现的
    private String title = "\t\t\t\t\t\t《我的爸爸》";
    private String one = "\t\t我的爸爸很牛逼，有多牛逼呢，来介绍一下。";
    private String last = "\t\t下辈子还要做他儿子，太爽了。";

    // 2.写一个写作文的方法
    public void write() {
        System.out.println(title); // 1
        System.out.println(one);  // 2
        // 写正文部分：模板本身不知道怎么做，必须交给使用模板的人来实现。
        // 把正文部分定义成一个抽象方法，交给子类重写实现。
        System.out.println(writeMain()); //3
        System.out.println(last); // 5
    }

    // 3.正文部分的抽象方法
    public abstract String writeMain();
}
```

##### 单例模式：

```markdown
单例模式的含义： 
    单例模式，是一种常用的软件设计模式。通过单例模式可以保证系统中，应用该模式的这个类永远只有一个实例。即一个类永远只有一个对象实例。
```

```markdown
单例的应用场景： 
    在实际开发中，有很多业务对象永远只需要一个，无论启动多少次我们只需要一个对象，例如任务管理对象，只需要一个对象。节约内存和性能。因为对象越多内存占用越大，极有可能出现内存溢出！
```

###### 饿汉单例设计模式：

```markdown
在用类获取对象的时候，对象已经提前创建好了。 
设计步骤： 
    a.定义一个类，把构造器私有。 
    b.定义一个静态变量存储一个对象。 
    c.提供一个返回单例对象的方法。
```

```java
public class SingleInstanceDemo01 {
    public static void main(String[] args) {
//        SingleInstance s1 = SingleInstance.getInstance();
//        SingleInstance s2 = SingleInstance.getInstance();

        // 简化写法：去掉第3步，公开静态变量直接访问！
        SingleInstance s1 = SingleInstance.ins;
        SingleInstance s2 = SingleInstance.ins;
        System.out.println(s1 == s2);
    }
}

class SingleInstance {
    //  b.定义一个静态变量存储一个对象。
    public static SingleInstance ins = new SingleInstance();

    //  a.定义一个类，把构造器私有。
    private SingleInstance() {

    }

    //  c.提供一个返回单例对象的方法。
//    public static SingleInstance getInstance(){
//        return ins ;
//    }
}
```

###### 懒汉单例设计模式：

```markdown
在真正需要该对象的时候，才去创建一个对象。 
设计步骤： 
    a.定义一个类，把构造器私有。 
    b.定义一个静态变量存储一个对象。 
    c.提供一个返回单例对象的方法。
```

```java
public class SingleInstanceDemo02 {
    public static void main(String[] args) {
        SingleInstance02 s1 = SingleInstance02.getInstance();
        SingleInstance02 s2 = SingleInstance02.getInstance();
        System.out.println(s1 == s2);
    }
}

class SingleInstance02 {
    //  b.定义一个静态变量存储一个对象。
    public static SingleInstance02 ins;

    //  a.定义一个类，把构造器私有。
    private SingleInstance02() {

    }

    //  c.提供一个返回单例对象的方法。
    public static SingleInstance02 getInstance() {
        if (ins == null) {
            ins = new SingleInstance02();
        }
        return ins;
    }
}
```

### 抽象类的注意事项:

```markdown
1. 抽象类不能创建对象，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。 
理解：
    假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。

2. 抽象类一定有而且是必须有构造器，是供子类创建对象时，初始化父类成员使用的。 
理解：
    子类的构造器中，有默认的super()，需要访问父类构造器。

3. 抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。

4. 抽象类的子类，必须重写抽象父类中所有的抽象方法，否则子类也必须定义成抽象类。

5. 抽象类存在的意义是为了被子类继承，抽象类体现的是模板思想。 
理解：
    抽象类中已经实现的是模板中确定的成员，抽象类不确定如何实现的定义成抽象方法，交给具体的子类去实现。
```

```java
public class AbstractDemo {
    public static void main(String[] args) {

    }
}

abstract class Animal {
    public abstract void run();
}
```

## 接口

### 什么是接口？

```markdown
接口是更加彻底的抽象，接口中全部是抽象方法和常量。（JDK 1.8之前）
```

### 接口有啥用?

```markdown
接口体现的是规范思想，实现接口的类必须重写完接口中全部的抽象方法。 规范 == 约束。
```

### 定义接口的格式：

```java
修饰符 interface 接口名称 {

}
```

### 接口中的成分研究：

```markdown
1.抽象方法：
    接口中的抽象方法可以省略 public abstract 不写，默认会加上。 
2.常量： 
    public static final修饰的成员变量就是常量
    常量要求必须有初始值，其值在执行的过程中不可改变。
    常量的名称建议全部字母大写，多个单词用下划线隔开 
注意：
    接口中常量的定义可以省略public static final不写。
```

```markdown
小结： 
    JDK 1.8之前，接口中全部是抽象方法和常量，其他成分都没有。 抽象方法可以省略 public abstract 不写，默认会加上。 接口中常量的定义可以省略public static final不写。
```

```java
public interface InterfaceDemo {
    // public static final修饰的成员变量就是常量
    // 常量要求必须有初始值，其值在执行的过程中不可改变。
    // 常量的名称建议全部字母大写，多个单词用下划线隔开
    // public static final String SCHOOL_NAME = "黑马";
    String SCHOOL_NAME = "黑马";

    //public abstract void run();
    //public abstract void sing(String name);
    void run();

    void sing(String name);
}
```

### 接口的基本实现:

```markdown
类与类是继承关系。 类与接口是实现关系。

接口是为了被类实现的。（实现==继承） 实现接口的类叫“实现类” （实现类==子类）

类与类的继承是用：
    extends 类与接口的实现使用：implements
```

实现接口的实现类的格式：

```java
修饰符  class 实现类名称 implements 接口1, 接口2, 接口3, ....{

        }
```

```markdown
小结： 
    接口是用来被实现的，实现的关键字是：implements，实现接口的类叫实现类。 一个类实现了接口，必须重写完接口中的全部抽象方法，否则这个类必须定义成抽象类。
```

```java
public class InterfaceDemo {
    public static void main(String[] args) {
        PingPongMan zjk = new PingPongMan("张继科");
        zjk.run();
        zjk.comption();
    }
}

// 实现类
class PingPongMan implements SportMan {
    private String name;

    public PingPongMan(String name) {
        this.name = name;
    }

    @Override
    public void run() {
        System.out.println(name + "乒乓球运动员必须跑步训练~~");
    }

    @Override
    public void comption() {
        System.out.println(name + "在比赛~~");
    }
}

// 运动员的接口：接口体现规范思想。约束思想。
interface SportMan {
    void run(); // 跑步

    void comption(); // 比赛
}
```

### 接口的多实现:

```markdown
类与类是单继承关系：
    一个类只能直接继承一个父类。 
类与接口是多实现关系：
    一个类可以同时实现多个接口。
```

#### 实现接口的实现类的格式：

```java
修饰符 class 实现类名称 implements 接口1, 接口2, 接口3, ....{

        }
```

```markdown
小结： 
    一个类实现多个接口，必须重写完全部接口中的全部抽象方法，否则这个类要成为抽象类。
```

```java
public class InterfaceDemo {
    public static void main(String[] args) {
        BasketBallMan yaoMing = new BasketBallMan("姚明");
        yaoMing.rule();
        yaoMing.run();
        yaoMing.abroad();
    }
}

class BasketBallMan implements SportMan, Law {
    private String name;

    public BasketBallMan(String name) {
        this.name = name;
    }

    @Override
    public void run() {
        System.out.println(name + "必须跑步~~");
    }

    @Override
    public void abroad() {
        System.out.println(name + "出国比赛~~");
    }

    @Override
    public void rule() {
        System.out.println(name + "必须守法，不能砍人~~");
    }
}

// 运动员的接口：
interface SportMan {
    void run();

    void abroad();
}

// 接口==规范
interface Law {
    void rule();//守法
}
```

### 接口的多继承:

```markdown
类与类是单继承关系： 
    一个类只能直接继承一个父类。 
类与接口是多实现关系：
    一个类可以同时实现多个接口。 接口与接口是多继承关系：一个接口可以同时继承多个接口。
```

```java
public class InterfaceDemo {
    public static void main(String[] args) {
        BasketBallMan yaoMing = new BasketBallMan("姚明");
        yaoMing.rule();
        yaoMing.run();
        yaoMing.abroad();
    }
}

class BasketBallMan implements SportMan {
    private String name;

    public BasketBallMan(String name) {
        this.name = name;
    }

    @Override
    public void run() {
        System.out.println(name + "必须跑步~~");
    }

    @Override
    public void abroad() {
        System.out.println(name + "出国比赛~~");
    }

    @Override
    public void rule() {
        System.out.println(name + "必须守法，不能砍人~~");
    }

    @Override
    public void eat() {

    }
}

// 运动员的接口：
interface SportMan extends Law, Eat {
    void run();

    void abroad();
}

// 接口==规范
interface Law {
    void rule();//守法
}

interface Eat {
    void eat(); // 吃
}
```

### JDK1\_8开始之后的接口:

```markdown
JDK 1.8之前接口中全部是抽象方法和常量。 JDK 1.8之后接口不再纯洁了，接口还新增了如下三种方法。

a.默认方法(其实就是实例方法).
    必须用default修饰，默认会加public修饰。
    必须用接口的实现类的对象来调用。

b.静态方法
    必须用static修饰，默认会加public修饰。 
    有且仅能用接口名称调用。

c.私有方法（私有的实例方法，JDK 1.9开始才有的）
    只能在接口中被接口的默认方法，私有方法调用。
```

```java
public class InterfaceDemo {
    public static void main(String[] args) {
        // 1.默认方法:必须用接口的实现类的对象来调用。
        PingPongMan zjk = new PingPongMan();
        zjk.go();

        // 2.静态方法：有且仅能用接口名称调用。
        SportMan.inAddr();
    }
}

class PingPongMan implements SportMan {
}

interface SportMan {
    // 1.默认方法(其实就是实例方法)
    default void go() {
        start();
        System.out.println("开始跑~~~");
    }

    // 2.静态方法
    static void inAddr() {
        System.out.println("我们在吉山区~~");
    }

    // 3.私有方法
    private void start() {
        System.out.println("准备开始~~");
    }
}
```

### 实现多个接口的使用注意实现:

```markdown
1.如果实现了多个接口，多个接口中存在同名的静态方法并不会冲突， 原因是只能通过各自接口名访问静态方法。

2.当一个类，既继承一个父类，又实现若干个接口时，(重点)父类中的成员方法与接口中的默认方法重名，子类就近选择执行父类的成员方法。

3.当一个类实现多个接口时，多个接口中存在同名的默认方法。实现类必须重写这个方法。

4.接口中，没有构造器，不能创建对象。(重点)
接口是更彻底的抽象，连构造器都没有，自然不能创建对象！！
```

```java
public class InterfaceDemo {
    public static void main(String[] args) {
//        Cat c = new Cat();
//        c.run();
    }
}

/**
 * 4.接口中，没有构造器，不能创建对象。(重点)
 *  接口是更彻底的抽象，连构造器都没有，自然不能创建对象！！
 */

/**
 *   3.当一个类实现多个接口时，多个接口中存在同名的默认方法。
 *     实现类必须重写这个方法。
 */
//interface A{
//    default void test(){
//        System.out.println("A");
//    }
//}
//interface B{
//    default void test(){
//        System.out.println("B");
//    }
//}
//class C implements A , B {
//    @Override
//    public void test() {
//        System.out.println("C");
//    }
//}

/**
 * 2.当一个类，既继承一个父类，又实现若干个接口时，(重点)
 *   父类中的成员方法与接口中的默认方法重名，子类就近选择执行父类的成员方法。
 */
//class Animal{
//    public void run(){
//        System.out.println("动物可以跑步~~~");
//    }
//}
//interface A{
//    default void run(){
//        System.out.println("A可以跑步~~~");
//    }
//}
//interface B{
//
//}
//class Cat extends Animal implements A , B{
//
//}


/**
 *  1.如果实现了多个接口，多个接口中存在同名的静态方法并不会冲突，
 *         原因是只能通过各自接口名访问静态方法。
 */
//interface A{
//    static void test(){
//        System.out.println("A");
//    }
//}
//interface B{
//    static void test(){
//        System.out.println("B");
//    }
//}
//class C implements A , B{
//}
```

## 代码块

### 静态代码块：

```markdown
有static修饰，属于当前类本身，与类一起优先加载，加载的时候会自动触发执行。
```

#### 格式:

```java
static{

        }
```

#### 静态代码块的作用：

```markdown
可以在类执行方法之前进行静态资源数据的初始化操作。
```

```markdown
小结： 
    静态代码块与类一起优先加载，自动触发执行。 可以在类执行方法之前进行静态资源数据的初始化操作。
```

```java
public class CodeDemo01 {
    public static List<String> datas = new ArrayList<>();

    // 静态代码块。
    static {
        // 静态代码块的作用：可以在类执行方法之前进行静态资源数据的初始化操作。
        System.out.println("静态代码块被触发执行~~~~~~~~");
        datas.add("东");
        datas.add("南");
        datas.add("西");
        datas.add("北");
    }

    public static void main(String[] args) {
        System.out.println(datas);
    }
}
```

### 实例代码块：

```markdown
无static修饰的的代码块，属于类的每个对象的，会与对象一起加载， 每次创建对象的时候都会自动执行一次实例代码块的执行。
```

#### 格式：

```java
{}
```

#### 实例代码块作用：

```markdown
可以用于初始化实例资源的数据。
实例代码块的代码相当于是提取到每个构造器中去执行的。
```

```java
public class CodeDemo02 {
    private String name;

    {
        System.out.println("实例代码块的代码被触发执行~~~~");
        name = "黑马";
    }

    public CodeDemo02() {

    }

    public CodeDemo02(int age) {

    }

    public static void main(String[] args) {
        CodeDemo02 c = new CodeDemo02();
        System.out.println(c.name);

    }
}
```

### final关键字:

```markdown
final是最终的含义，可以修饰类，方法，变量。

1.final修饰类：类不能被继承了，类绝育了。 
2.final修饰方法：方法不能被重写了。 
3.final修饰变量的总规则：变量有且仅能被赋值一次。

注意：final 和 abstract是啥关系：互斥关系。
```

```java
public class FinalDemo01 {
    public static void main(String[] args) {
    }
}

class Animal {
    public final void run() {

    }
}

class Cat extends Animal {
//    @Override
//    public void run(){
//
//    }
}
```

#### final修饰变量-修饰局部变量:

```markdown
总规则：
    final修饰变量，变量有且仅能被赋值一次。

变量有几种:
1.局部变量
    方法中，形参，代码块中，for循环，构造器中定义的变量等都是局部变量。 
2.成员变量 
    a.静态成员变量。
    b.实例成员变量。
```

```java
public class FinalDemo02 {
    public static void main(String[] args) {
        final int age = 18;
        //age = 19 ; // 第二次赋值，直接报错

        final double rate = 3.14;
        // rate = 3.144 ; // 第二次赋值，直接报错

        buy(0.8);
        buy(0.9);
    }

    public static void buy(final double z) {
        // z = 0.5 ; // 第二次赋值，直接报错
    }
}
```

#### final修饰变量-修饰静态成员变量:

```markdown
总规则：
    final修饰变量，变量有且仅能被赋值一次。

变量有几种:
1.局部变量
    方法中，形参，代码块中，for循环，构造器中定义的变量等都是局部变量。 
2.成员变量
    a.静态成员变量。 final修饰静态成员变量就变成了常量。 常量名称字母全部大写，多个单词用下划线隔开。

final修饰静态成员变量可以在哪些地方赋值一次： 
    可以在定义的时候赋值一次。 可以在静态代码块赋值一次。

    b.实例成员变量。
```

```java
public class FinalDemo03 {
    public static final String SCHOOL_NAME = "黑马";
    public static final String SCHOOL_NAME1;

    static {
        SCHOOL_NAME1 = "黑马1";
    }

    public static void main(String[] args) {
    }
}
```

#### final修饰变量-修饰实例成员变量:

```markdown
总规则：
    final修饰变量，变量有且仅能被赋值一次。

变量有几种:
1.局部变量
    方法中，形参，代码块中，for循环，构造器中定义的变量等都是局部变量。
2.成员变量 
    a.静态成员变量。 final修饰静态成员变量就变成了常量。 常量名称字母全部大写，多个单词用下划线隔开。

final修饰静态成员变量可以在哪些地方赋值一次： 
    可以在定义的时候赋值一次。 可以在静态代码块赋值一次。

    b.实例成员变量。 
final修饰实例成员变量可以在哪些地方赋值一次： 
    可以在定义的时候赋值一次。 可以在实例代码块中赋值一次。 可以在全部构造器中赋值一次。
```

```java
public class FinalDemo04 {
    private final String name = "小黑";
    private final String name1;
    private final String name2;

    {
        name1 = "小白";
    }

    public FinalDemo04() {
        name2 = "小白2";
    }

    public FinalDemo04(String n) {
        name2 = "小白2";
    }

    public static void main(String[] args) {
        FinalDemo04 f = new FinalDemo04();
        // f.name = "小白"; // 第二次赋值。直接报错。
    }
}
```
## 内部类
### 内部类是类的五大成分之一：
```markdown
成员变量，方法，构造器，代码块，内部类。
```
### 什么是内部类？
```markdown
定义在一个类里面的类就是内部类。
```

### 内部类有什么用？
```markdown
可以提供更好的封装性, 内部类有更多权限修饰符, 封装性有更多的控制。
```
### 内部类的分类:
#### 静态内部类:
##### 什么是静态内部类？
```markdown
使用了static修饰的内部类，属于外部类本身，会与外部类加载一次，只有一份。
```

##### 静态内部类的成分特点：
```markdown
类有的成分它都具备，它只是位置在一个类的里面而已，而且也只有一份，
所以与普通类几乎无任何差别。
```

##### 静态内部类的访问格式：
```markdown
外部类名称.内部类名称 （外部类==宿主，内部类==寄生）
```
##### 静态内部类创建对象的格式：
```markdown
外部类名称.内部类名称 对象名称 = new 外部类名称.内部类构造器;
拓展:
    静态内部类是否可以直接访问外部类的静态成员？ 可以的，外部类的静态成员只有一份是被共享的！
    静态内部类是否可以直接访问外部类的实例成员？ 不可以的，外部类的实例成员必须用外部类的对象访问！
```

```java
public class InnerClass {
    public static void main(String[] args) {
        //外部类名称.内部类名称 对象名称 = new 外部类名称.内部类构造器;
        Outter.Inner in = new Outter.Inner();
        in.show();
    }
}

class Outter {
    public static int age = 100;
    private char sex;

    // 静态内部类
    public static class Inner{
        private String name ;
        public static String schoolName = "黑马";

        public void show(){
            System.out.println(age);
            //System.out.println(sex);
        }

        public Inner() {
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }
    }
}
```
#### 实例内部类：
```java
public class Demo05 {
    public static void main(String[] args) {
        Body.Heart heart = new Body().new Heart();
        heart.jump();
    }
}

// 外部类
class Body {
    private int weight = 30;
    // 实例内部类:属于外部类对象
    public class Heart {
        private int weight = 20;
        public void jump() {
            int weight = 10;
            System.out.println("心脏在跳动 " + weight);	// 10
            System.out.println("心脏在跳动 " + this.weight);	// 20
            System.out.println("心脏在跳动 " + Body.this.weight);	// 30
        }
    }
}
```
##### 什么是实例内部类：
```markdown
无static修饰的内部类，属于外部类的每个对象的，与对象一起加载的。
```
##### 实例内部类的成分特点：
```markdown
不能定义静态成员（不能有静态变量和静态方法），可以定义常量其他都有。
```
##### 实例内部类创建对象的格式：
```markdown
外部类名称.内部类名称 对象名称 = new 外部类构造器.new 内部类构造器;
拓展：
    实例内部类中是否可以直接访问外部类的静态成员？
    可以的，静态成员只有一份，可以被共享访问。
    实例内部类中是否可以直接访问外部类的实例成员?
    可以的，实例内部类是属于外部类对象的，可以访问外部类的实例成员。
```

```java
public class InnerClass {
    public static void main(String[] args) {
        Outter.Inner in = new Outter().new Inner();
        in.show();
    }
}
class Outter {
    public static int age = 12;
    private char sex;
    // 实例内部类，没有static修饰，属于外部类的对象的。
    public class Inner{
        private String name ;
        public static final String SCHOOL_NAME ="黑马";
        public Inner() {
        }

        public void show(){
            System.out.println(age);
            System.out.println(sex);
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }
    }
}
```
#### 局部内部类：
```markdown
定义在方法中，在构造器中，代码块中，for循环中定义的内部类
就是局部内部类。
局部内部类中的成分特点：
    只能定义实例成员，不能定义静态成员可以定义常量的。
```

```java
public class InnerClass {



    {
        class A{

        }
    }

    static {
        class B{

        }

    }
    public static void main(String[] args) {
        test();
        test();
        test();
    }

    public static void test(){
        class A{
            public void show(){

            }
        }
        abstract class B {

        }
        A a = new A();
        a.show();
    }
}
```

#### 匿名内部类：

##### 什么是匿名内部类？
```markdown
其实是局部内部类，是一个没有名字的局部内部类。
```
##### 匿名内部类的作用？
```markdown
简化代码。
```
##### 匿名内部类的格式:
```java
new 类名|接口|抽象类(形参){
方法重写;
}
```
##### 匿名内部类的特点：
```markdown
1.匿名内部类是一个没有名字的内部类。
2.匿名内部类一旦写出来，会自动创建一个匿名内部类的对象返回。
3.匿名内部类相当于是一个子类类型的对象。
```

```markdown
小结：
    匿名内部类是用于简化代码的.
    匿名内部类一旦写出来，会自动创建一个匿名内部类的对象返回。
```

```java
public class AnonymityDemo01 {
    public static void main(String[] args) {
        Animal a = new Animal() {
            @Override
            public void run() {
                System.out.println("🐱跑的贼溜~~~");
            }
        };
        a.run();

        // 简化写法！
        new Animal(){
            @Override
            public void run() {
                System.out.println("🐕跑的贼溜~~");
            }
        }.run();
    }
}

abstract class Animal{
    public abstract void run();
}

//class Cat extends Animal {
//
//    @Override
//    public void run() {
//        System.out.println("🐱跑的贼溜~~~");
//    }
//}
```
##### 匿名内部类的常用形式：
```java
public class AnonymityDemo02 {
    public static void main(String[] args) {
        Swim s1 = new Swim() {
            @Override
            public void swimming() {
                System.out.println("学生快乐的狗爬式~~~");
            }
        };
        go(s1);

        go(new Swim() {
            @Override
            public void swimming() {
                System.out.println("老师🏊‍的挺好的~~");
            }
        });
    }

    // 要求所有的人一起参加游泳比赛
    public static void go(Swim s){
        System.out.println("开始");
        s.swimming();
        System.out.println("结束");
    }
}

// 要求所有的人一起参加游泳比赛
interface Swim{
    void swimming(); // 游泳。
}
```
##### 匿名内部类的真实使用演示：
```java
public class AnonymityDemo03 {
    public static void main(String[] args) {
        // 1.创建一个窗口对象
        JFrame win = new JFrame("登陆界面");
        JPanel panel = new JPanel();
        win.add(panel);
        // 6.创建一个按钮对象
        JButton btn = new JButton("发射导弹");
        panel.add(btn);

        // 7.给发射导弹按钮绑定点击事件监听器。
        btn.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                System.out.println("开始发射给日本了~~~");
            }
        });

//        btn.addActionListener((ActionEvent e) -> {
//                System.out.println("开始发射给日本了~~~");
//        });

//        btn.addActionListener(e -> System.out.println("开始发射给日本了~~~"));

        // 2.设置窗口的大小
        win.setSize(300 , 400);
        // 3.居中
        win.setLocationRelativeTo(null);
        // 4.关闭窗口推出程序
        win.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
        // 5.显示出来
        win.setVisible(true);
    }
}
public class Dog {
    public static String name = "泰日天";
}
```



# 枚举

```markdown
枚举是一种特殊类型，主要用于做信息的标志和分类。
```

## 枚举的定义格式：

```java
修饰符 enum 枚举类名称 {
    罗列枚举类的实例
}
```

## 枚举类的源代码：

```java
Compiled from"Oritation.java"

final class Oritation extends java.lang.Enum<Oritation> {
    public static final Oritation UP = new Oritation();
    public static final Oritation DOWN = new Oritation();
    public static final Oritation LEFT = new Oritation();
    public static final Oritation RIGHT = new Oritation();
}
```

## 枚举的特点：

```markdown
1.枚举类不能被继承。 
2.枚举默认继承了枚举类型：java.lang.Enum 
3.枚举类的第一行都是罗列枚举类的对象。他们都是常量。 
4.枚举类的构造器是私有的，枚举类相当于是多例模式。
```

```markdown
小结： 
    枚举用于做信息的分类和标志。 枚举类的第一行都是罗列枚举类的对象，枚举类相当于是多例模式。
```

```java
enum Oritation {
    UP, DOWN, LEFT, RIGHT;
}

public class EnumDemo01 {
    public static void main(String[] args) {
        go(Oritation.UP);
    }

    // 控制玛丽的走向：
    public static void go(Oritation o) {
        switch (o) {
            case UP:
                System.out.println("控制玛丽往上飞~~~");
                break;
            case DOWN:
                System.out.println("控制玛丽往下蹲~~~");
                break;
            case LEFT:
                System.out.println("控制玛丽往左跑~~~");
                break;
            case RIGHT:
                System.out.println("控制玛丽往👉跑~~~");
                break;
        }
    }

//    // 常量：
//    public static final int UP = 0 ;
//    public static final int DOWN = 1 ;
//    public static final int LEFT = 2 ;
//    public static final int RIGHT = 3 ;
//
//    public static void main(String[] args) {
//        go(LEFT);
//    }
//
//    // 超级玛丽游戏。
//    // 定义一个方法控制玛丽的走向。
//    public static void go(int oritation){
//        switch (oritation){
//            case UP:
//                System.out.println("控制玛丽往上飞~~~");
//                break;
//            case DOWN:
//                System.out.println("控制玛丽往下蹲~~~");
//                break;
//            case LEFT:
//                System.out.println("控制玛丽往左跑~~~");
//                break;
//            case RIGHT:
//                System.out.println("控制玛丽往👉跑~~~");
//                break;
//        }
//    }
}
```

## 枚举的常用API：

```java
public class EnumDemo02 {
    public static void main(String[] args) {
        Sex s = Sex.BOY;
        System.out.println(s); // BOY

        // 返回枚举的全部实例对象。（拓展）
        Season[] seasons = Season.values();
        for (int i = 0; i < seasons.length; i++) {
            Season season = seasons[i];
            System.out.println(season);
            // -- 拿当前枚举实例的索引
            System.out.println(season.ordinal());
        }
    }
}

// 性别
enum Sex {
    GIRL, BOY;
}

// 季节
enum Season {
    SPRING, SUMMER, AUTOUM, WINTER;
}

```

# 包和权限修饰符
## 包：
```markdown
分门别类的管理各种不同的技术。
企业的代码必须用包区分。便于管理技术，扩展技术，阅读技术。
```
## 定义包的格式：
```markdown
package 包名; 必须放在类名的最上面。一般工具已经帮我们做好了。
```
## 包名的命名规范：
```markdown
一般是公司域名的倒写+技术名称：
    http://www.itheima.com => com.itheima.技术名称
    包名建议全部用英文，多个单词用”.“连接，必须是合法标识符，不能用关键字
注意：
    相同包下的类可以直接访问。
    不同包下的类必须导包,才可以使用！
    导包格式：import 包名.类名;
```

```java
public class PackageDemo01 {
    public static void main(String[] args) {
        // 相同包下的类可以直接访问。
        Student.inAddr();

        // 不同包下的类必须导包,才可以使用！
        System.out.println(Dog.name);
    }
}
```

## 权限修饰符
```markdown
权限修饰符：
    有四种（private -> 缺省 -> protectecd - > public ）
可以修饰成员变量，修饰方法，修饰构造器，不同修饰符修饰的成员能够被访问的权限将受到限制!

四种修饰符的访问权限范围：
                    private    缺省       protected   public
    本类中           √           √          √           √
    本包下其他类中    X           √          √           √
    其他包下的类中    X           X          X           √
    其他包下的子类中   X           X          √           √
```
# Object类
```markdown
Object类是Java中一切类的祖宗类，一个类要么默认继承了Object类，要么间接继承了Object类。
Object类中的方法是一起类都可以使用的。
所以学习Object类的方法，那么一切类都可以使用这些功能！！
```
## Object类的常用方法：
### （1）public String toString():
```markdown
作用：
    默认是返回当前对象在堆内存中的地址信息。
    com.itheima._12Object类.Student@2ac1fdc4
    全限名@16进制的地址。
直接输出对象，默认也是调用了toString()方法，所以直接输出对象，toString()可以省略不写！
直接输出对象调用toString()方法返回对象的地址其实是没有意义的，开发中输出对象更多的时候希望看到对象的数据内容，所以toString()方法存在的意义是为了被子类重写，以便返回对象的数据内容输出!!
小结：
    所以toString()方法存在的意义是为了被子类重写，以便返回对象的数据内容输出!!!
```

```java
public class ObjectToStringDemo01{
    public static void main(String[] args) {
        Student s1 = new Student("铁扇公主",23,'女');
        //System.out.println(s1.toString());
        System.out.println(s1); // 自动调用toString()方法， toString()可以省略不写！
    }
}
public class Student {
    private String name;
    private int age ;
    private char sex ;

    public Student(){

    }

    public Student(String name, int age, char sex) {
        this.name = name;
        this.age = age;
        this.sex = sex;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public char getSex() {
        return sex;
    }

    public void setSex(char sex) {
        this.sex = sex;
    }

    // s1.equals(s2)
    // 需求：只要两个对象的名称，年龄，性别一样就认为是相等的。
    // 比较者：s1 == this
    // 被比较者：s2 == o
    @Override
    public boolean equals(Object o) {
        // 1.判断是否自己跟自己比较，是，直接返回true.
        if (this == o) return true;
        // 2.判断o是否为null或者类型是否是学生类型。不是返回false
        if (o == null || this.getClass() != o.getClass()) return false;
        // 3.o一定是学生类型了，判断内容是否一样。
        Student student = (Student) o;
        return age == student.age &&
                sex == student.sex &&
                Objects.equals(name, student.name);
    }

    // s1.equals(s2)
    // 需求：只要两个对象的名称，年龄，性别一样就认为是相等的。
    // 比较者：s1 == this
    // 被比较者：s2 == obj
//    @Override
//    public boolean equals(Object obj) {
//        // 1.判断obj是否是学生类型：因为学生只能和学生比较，否则是false
//        if(obj instanceof Student){
//            // 2.obj真的是学生类型了。
//            Student s2 = (Student) obj;
////            if(this.age == s2.age && this.sex == s2.sex && this.name.equals(s2.name)){
////                return true;
////            }else{
////                return false;
////            }
//            return this.age == s2.age && this.sex == s2.sex
//                    && this.name.equals(s2.name);
//        }else{
//            // obj不是学生！
//            return false ;
//        }
//    }

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", sex=" + sex +
                '}';
    }
}
```

### （2）public boolean equals(Object obj) :
```markdown
public static boolean equals(Object a, Object b):
    判断两个对象是否相等,可以避免空指针异常，建议大家使用！！
public static boolean isNull(Object obj): 
    判断对象是否为null， 如果为null返回true。
作用：
    默认是判断两个对象的地址是否一样。判断是否是同一个对象！
如果只是判断两个对象的地址是否一样，那么==号完全可以替代equals.所以equals存在的意义是为了被子类重写，以便重新定制对象的比较规则。

需求：
    只要两个对象的名称，年龄，性别一样就认为是相等的。

小结：
    equals存在的意义是为了被子类重写，以便重新定制对象的比较规则。
    字符串的比较建议用equals只要内容一样结果就是true。
```

```java
public class ObjectsDemo {
    public static void main(String[] args) {
        Student s1 = null;
        Student s2 = new Student("铁扇公主",23,'女');
        //System.out.println(s1.equals(s2));
        /**
         从源代码来看：可以避免空指针异常，建议大家使用！！
         public static boolean equals(Object a, Object b) {
            return (a == b) || (a != null && a.equals(b));
         }
         */
        System.out.println(Objects.equals(s1, s2));

        System.out.println("--------------------------");
        System.out.println(Objects.isNull(s1)); // true
        System.out.println(Objects.isNull(s2)); // false
        System.out.println(s1 == null); // true
        System.out.println(s2 == null); // false


    }
}
public class Student {
    private String name;
    private int age ;
    private char sex ;

    public Student(){

    }

    public Student(String name, int age, char sex) {
        this.name = name;
        this.age = age;
        this.sex = sex;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public char getSex() {
        return sex;
    }

    public void setSex(char sex) {
        this.sex = sex;
    }

    // s1.equals(s2)
    // 需求：只要两个对象的名称，年龄，性别一样就认为是相等的。
    // 比较者：s1 == this
    // 被比较者：s2 == o
    @Override
    public boolean equals(Object o) {
        // 1.判断是否自己跟自己比较，是，直接返回true.
        if (this == o) return true;
        // 2.判断o是否为null或者类型是否是学生类型。不是返回false
        if (o == null || this.getClass() != o.getClass()) return false;
        // 3.o一定是学生类型了，判断内容是否一样。
        Student student = (Student) o;
        return age == student.age &&
                sex == student.sex &&
                Objects.equals(name, student.name);
    }



    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", sex=" + sex +
                '}';
    }
}
```

```java
public class ObjectEqualsDemo02 {
    public static void main(String[] args) {
        Student s1 = new Student("铁扇公主",23,'女');
        Student s2 = new Student("铁扇公主",23,'女');
        System.out.println(s1.equals(s2)); // true.
        // System.out.println(s1 == s2); // false.
    }
}
```
# 常用API
## Date日期类
```markdown
Java是面向对象的，Date日期类代表了系统当前此刻日期对象。
```
### 构造器：
```java
public Date() //创建一个Date日期对象：代表了系统当前此刻日期对象。
public Date(long time)
```
### 方法：

```java
public long getTime()
//返回自 1970 年 1 月 1 日 00:00:00 开始到现在走过的总的毫秒值。
1s = 1000ms
```
### 时间记录的两种方式：
```markdown
a.Date日期类的对象：
    Date d = new Date();
b.时间毫秒值：
    自 1970 年 1 月 1 日 00:00:00 开始到现在走过的总的毫秒值。
小结：
    Date日期类表示的是当前此刻日期对象。
    时间记录的形式有2种：Date日期对象，时间毫秒值。
```

```java
public class DateDemo01 {
    public static void main(String[] args) {
        // 1.创建一个Date日期对象：代表了系统当前此刻日期对象。
        Date d = new Date();
        System.out.println(d);

        // 2.获取时间毫秒值。
        long time = d.getTime();
        System.out.println(time);
    }
}

```
### 时间毫秒值的作用:
```markdown
时间毫秒值可以用于时间的运算，例如做代码的执行性能分析。
```

```java
public class DateDemo02 {
    public static void main(String[] args) {
        // 1.先获取当前此刻时间毫秒值
        long startTime = new Date().getTime();

        for(int i = 0 ; i < 100000 ; i++){
            System.out.println(i);
        }

        // 2.获取代码执行完成以后此刻时间毫秒值
        long endTime = new Date().getTime();

        // 3.时间差：耗时。
        System.out.println((endTime - startTime)/1000.0+"s");

    }
}
```
### 时间的转换：
```markdown
Date日期对象  ---> getTime()  ---> 时间毫秒值。
时间毫秒值    ---> public Date(long time) ---> Date日期对象
小结：
    public Date(long time): 可以把时间毫秒值转换成对应的日期对象。
```

```java
public class DateDemo03 {
    public static void main(String[] args) {
        // 需求：请计算出此刻122s之后的时间并输出结果。
        // 1.创建一个日期对象代表此刻系统时间
        Date d = new Date();
        System.out.println(d);

        // 2.得到此刻日期对象的时间毫秒值
        long time = d.getTime();

        // 3.让时间毫秒值往后走122s
        time += 122*1000;

        // 4.通过日期对象的有参数构造器：把时间毫秒值转换成日期对象。
        Date d2 = new Date(time);
        System.out.println(d2);
    }
}
```
## DateFormat日期格式化类
### 作用：
```markdown
1.可以把Date日期对象或者时间毫秒值直接格式化成用户喜欢的形式。
2.可以把字符串的时间形式解析成对应的日期对象。"2019-10-01 10:10:11" -> Date日期对象
DateFormat是一个抽象类不能直接使用，需要用它的子类：
SimpleDateFormat：简单日期格式化类。
```
### 构造器：
```java
public SimpleDateFormat(String pattern)：指定时间格式创建简单日期格式化对象。
```
### 方法：
```java
public String format(Date d): 格式化日期对象。
public String format(Object time): 格式化时间毫秒值。
public Date parse(String date) throws ParseException: 解析字符串时间成日期对象。
```

```markdown
小结：
    SimpleDateFormat可以通过format方法格式化日期对象成我们喜欢的时间形式。
```

```java
public class DateFormatDemo01 {
    public static void main(String[] args) {
        // 需求：把Date日期对象格式化成 xxxx年xx月xx日 xx:xx:xx
        Date d = new Date();
        System.out.println(d);

        // 1.创建一个简单日期格式化对象
        // 参数：我们喜欢的时间格式.
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy年MM月dd日 HH:mm:ss EEE a");

        // 2.开始格式化日期对象返回我们喜欢的字符串时间格式。
        String rs = sdf.format(d);
        System.out.println(rs);
    }
}
public class DateFormatDemo02 {
    public static void main(String[] args) {
        // 需求：122s后的时间，并且需要格式化输出。
        // 1.得到当前系统此刻时间毫秒值
        long time = new Date().getTime();
        // 2.格式化此刻时间输出。
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy年MM月dd日 HH:mm:ss EEE a");
        System.out.println(sdf.format(time));

        // 3.让当前时间往后走122s,再格式化输出
        time += 122*1000;
        System.out.println(sdf.format(time));
    }
}
public class DateFormatDemo03 {
    public static void main(String[] args) throws ParseException {
        // 需求：面试题
        // 随便给你一个时间“2018-10-12 10:59:59” 请问 1天 2小时 121s后是什么时间
        // 思路：
        // 1.定义字符串时间
        String date = "2018-10-12 10:59:59";

        // 2.把字符串时间解析成日期对象（重点）
        // 重点注意：简单日期格式化的时间格式必须与被解析的时间格式完全一致，否则解析会报错！！
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        // 解析字符串时间成日期对象。
        Date d = sdf.parse(date);

        // 3.把日期对象转换成时间毫秒值，然后往后走1天 2小时 121s
        long time = d.getTime();
        time += (24*60*60+2*60*60+121)*1000L;

        // 4.格式化计算出的时间毫秒值输出即可。
        System.out.println(sdf.format(time));


    }
}
```
## 日历类CalenDar
```markdown
CalenDar：代表了系统当期此刻时间对应的日历对象。
```
### CalenDar获取日历对象的API:
```java
public static Calendar getInstance()
Calendar rightNow = Calendar.getInstance();
```
### CalenDar提供的常用API:
```java
public int get(int field)：返回给定日历字段的值。
public void set(int field, int value)：将给定的日历字段设置为给定值。
public abstract void add(int field, int amount)：根据日历的规则，为给定的日历字段添加或减去指定的时间量。
public Date getTime():获取日期对象
```

```java
public class CalendarDemo01 {
    public static void main(String[] args) {
        // 1.得到一个当前系统此刻时间对应的日历对象。
        Calendar rightNow = Calendar.getInstance();
        System.out.println(rightNow);

        // 2.获取年
        int yy = rightNow.get(Calendar.YEAR);
        System.out.println(yy);

        // 获取月
        int mm = rightNow.get(Calendar.MONTH) +1;
        System.out.println(mm);

        // 一年中的第几天
        int days = rightNow.get(Calendar.DAY_OF_YEAR);
        System.out.println(days);

        // 3.获取日期对象
        Date d = rightNow.getTime();
        System.out.println(d);

        // 4.直接获取此刻时间毫秒值
        long time = rightNow.getTimeInMillis();
        System.out.println(time);

        // 5.问300天后是什么时间：添加
        // 直接让日历在一年中的第几天往后走300天。
        rightNow.add(Calendar.DAY_OF_YEAR , 300);
        Date d1 = rightNow.getTime();
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss");
        System.out.println(sdf.format(d1));

        // 6.把日历的年份改成1996:修改
        rightNow.set(Calendar.YEAR, 1996);
        Date d2 = rightNow.getTime();
        System.out.println(sdf.format(d2));
    }
}
```
## System系统类
### System类的常用API:
```java
public static long currentTimeMillis()：获取当前系统此刻时间毫秒值。
public static void exit(int status):终止当前正在运行的 Java 虚拟机,参数用作状态码；根据惯例，非0的状态码表示异常终止
public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)：将数组中指定的数据拷贝到另一个数组中。
```

```java
public class SystemDemo01 {
    public static void main(String[] args) {
        // 1.获取当前系统此刻时间毫秒值。
        long time = System.currentTimeMillis();
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss EEE a");
        System.out.println(sdf.format(time));

        // 2.终止当前JVM虚拟机。非0的状态码表示异常终止
        // System.exit(0);

        // 3.数组拷贝的内容。
        int[] arrs1 = new int[]{10 , 20 , 30 , 40 ,50 ,60 ,70};
        int[] arrs2 = new int[6]; // -> [ 0 , 0 , 40 ,50 ,60 , 0]
        /**
         * arraycopy(Object src,int srcPos,Object dest, int destPos,int length)
         * 参数一：原数组
         * 参数二：从原数组的哪个元素索引开始复制
         * 参数三：目标数组
         * 参数四：从目标数组的哪个位置开始粘贴
         * 参数五：复制多少个
         */
        System.arraycopy(arrs1,3,arrs2,2 , 3);
        System.out.println("数组内容："+ Arrays.toString(arrs2));

        System.out.println("程序结束。。。。");
    }
}
```
## 大数据处理类BigDecimal
```markdown
引入：
    double类型的数据在运算的时候并不精确，可能出现数据失真。
    此时就可以用BigDecimal解决。
```
### BigDecimal作用：
```markdown
可以解决浮点数的精确计算。
```
### 常用API：
```java
public static BigDecimal valueOf(double val):直接把浮点型包装成大数据对象。
public BigDecimal add(BigDecimal value); 加法
public BigDecimal subtract(BigDecimal value); 减法
public BigDecimal multiply(BigDecimal value); 乘法
public BigDecimal divide(BigDecimal value); 除法
public double doubleValue():把BigDecimal的数据转换成double类型。
```

```java
public class BigDecimalDemo01 {
    public static void main(String[] args) {
        double a = 0.1;
        double b = 0.2;
        double c = a + b ;
        System.out.println(c);

        // 把a包装成大数据对象
        BigDecimal a1 = BigDecimal.valueOf(a);
        BigDecimal b1 = BigDecimal.valueOf(b);
        BigDecimal c1 = a1.add(b1);
        //BigDecimal c1 = a1.multiply(b1);

        // 最终还是把大数据计算出的精确结果转换回double类型。
        double rs = c1.doubleValue();
        System.out.println(rs);
        // buy(rs);


    }

    public static void buy(double money){

    }
}
```
## StringBuilder类
```markdown
引入：
    String类是定义字符串的类型，可以用String定义一个字符串变量存储字符串内容。
    String类的字符串因为不可变可以被共享。
    String类是不可变字符串，操作字符串的运算性能较差。
    操作字符串建议用：StringBuilder/StringBuffer 操作字符串性能较好！
```
### StringBuilder的作用：
```markdown
对字符串进行各种增删该查操作。
```
### 构造器：
```java
public StringBuilder(){}
```
### 方法：
```java
public StringBuilder append(Xxx xx):拼接内容。
```

```markdown
小结：
    StringBuilder适合对字符串进行各种增删该查操作，性能好。
    StringBuilder/StringBuffer功能是完全一样的，但是StringBuilder线程不安全性能好用的多。
    StringBuffer线程安全性能差用的少（了解）
```

```java
public class StringBuilderDemo01 {
    public static void main(String[] args) {
        String name = "itheima";
        name += "欢迎";
        name += "你来学习Java!";
        System.out.println(name);

        StringBuilder sb = new StringBuilder();
        sb.append("itheima");
        sb.append("欢迎");
        sb.append("你来学习Java！");
        // 把StringBuilder转换成字符串
        String rs = sb.toString();
        System.out.println(rs);

        // 链式编程的介绍
        StringBuilder sb1 = new StringBuilder();
        sb1.append("itheima").append("欢迎").append("你来学习Java！");
        System.out.println(sb1);
    }
}
public class StringBuilderDemo02 {
    public static void main(String[] args) {
        StringBuilder sb = new StringBuilder();
        sb.append("我在").append("itheima").append("快乐的黑老师");
        // 我在itheima快乐的黑老师
        System.out.println(sb);

        // 1.插入一段字符串。“学习Java”
        // 参数一：插入的起始索引位置
        // 参数二：插入的内容
        sb.insert(12,"学习Java");
        System.out.println(sb);

        // 2.删除“黑老师”
        // 参数一：删除的起始索引
        // 参数二：结束位置 （不包括）
        sb.delete(18 , sb.length());
        System.out.println(sb);

        // 3.反转内容
        sb.reverse();
        System.out.println(sb);

    }
}
```
## 包装类
```markdown
引入：
    Java认为一切皆对象。
    但是Java中的8种基本数据类型，并不是对象，而是数据的一种形式。
    Java为了实现一切皆对象，把8种数据类型都设计了一种对应的类，这个类就是包装类。
```

```markdown
    基本数据类型              包装类
    byte                     Byte
    short                    Short
    int                      Integer(特殊)
    long                     Long
    float                    Float
    double                   Double
    char                     Character(特殊)
    boolean                  Boolean
```
### 自动装箱：
```markdown
可以直接把基本数据类型的变量或者值直接赋值给对应的包装类变变量成为一个对象。
```
### 自动拆箱：
```markdown
可以直接把包装类的变量赋值给基本数据类型的变量。
```

```markdown
小结：
    Java通过了包装类实现了一切皆对象。
```

```java
public class Demo01 {
    public static void main(String[] args) {
        int a1 = 12 ;    // 12是类型数据，是基本数据类型的数据。
        Integer a2 = 13; // 13是对象数据。是引用类型的数据，自动装箱
        Integer a3 = a1; // 自动装箱

        Integer a4 = 100 ; // 自动装箱
        int a5 = a4;  // 自动拆箱

        // 手工装箱（不建议）
        Integer a6 = Integer.valueOf(13);
        Integer a7 = 13;

        // 手工拆箱（不建议）
        Integer a8 = 120;
        //int a9 = a8.intValue();
        int a9 = a8;
    }
}
```
### 包装类的特有功能：
```markdown
1.可以把基本数据类型的值转换成字符串。(没啥用)。
2.可以把字符串类型的数值转换成对应的基本数据类型（很有用了,重点）
    Xxxx parseXxxx("字符串类型的数值")
    Xxxx valueOf("字符串类型的数值"):建议方式
小结：
    包装类可以把字符串类型的数值转换成对应的基本数据类型的值。
```

```java
public class Demo02 {
    public static void main(String[] args) {
        Integer it = 13 ;
        // 1.可以调用toString()方法，把类型转换成字符串
        String rs1 = it.toString();
        System.out.println(rs1+1);

        // 2.直接+字符串变成字符串
        String rs2 = it + "";
        System.out.println(rs2+1);

        // 3.调用Integer.toString方法得到字符串(没啥用)
        String rs3 = Integer.toString(it);
        System.out.println(rs3+1);

        System.out.println("---可以把字符串类型的数值转换成对应的基本数据类型（很有用了,重点）------------------");
        String num = "23";
        // 把字符串类型的整数转换成整数类型的数值。
        //int numInt = Integer.parseInt(num);
        int numInt = Integer.valueOf(num);
        System.out.println(numInt+1);

        String price = "99.9";
        // 把字符串小数转换成对应的double类型的值。
        //double priceDb = Double.parseDouble(price);
        double priceDb = Double.valueOf(price);
        System.out.println(priceDb+0.1);

    }

}
```
# 泛型
```markdown
此在JDK5之后，新增了泛型(Generic)语法
泛型的格式： <数据类型>
泛型其实就是一个标签，用来约束在"编译阶段"只能操作某种数据类型。

小结：
    泛型就是一个标签。可以约束编译阶段只能操作某种数据类型。
```

```java
public class GenericDemo {
    public static void main(String[] args) {
        //ArrayList<String> lists = new ArrayList<String>();
        // JDK 1.7开始之后，泛型定义右边的类型申明可以省略不写。
        ArrayList<String> lists = new ArrayList<>();
        // lists.add(1);
        // lists.add('a');
        lists.add("Java");
        lists.add("Dlei");
        // lists.add(false);
        System.out.println(lists);

    }
}
```
## 泛型的好处
```markdown
1.可以在编译阶段就统一数据类型，这与Java的清晰严谨性保持一致。
2.在编译阶段就确定数据类型，避免了运行阶段的ClassCastException类型转换异常。
```

```java
public class GenericDemo {
    public static void main(String[] args) {
        ArrayList<String> lists = new ArrayList();
        //lists.add(false);
        //lists.add(12);
        lists.add("Java");
        lists.add("Dlei");
        lists.add("Mybatis");


        for(int i = 0 ; i < lists.size() ; i++){
            String ele = lists.get(i);
            System.out.println(ele);
        }
    }
}
```
## 自定义泛型类
```markdown
引入：
    之前我们用的都是sun公司写好的泛型类。
    接下来我们自己也做一个泛型类。
```
### 什么是泛型类?
```markdown使用了泛型的类就是泛型类。

```
### 泛型类的定义格式：

```java
修饰符 class 类名称<泛型变量>{

        }
```
### 泛型变量：
```markdown
一般使用 E , T , K , V
需求： 模拟sun公司的ArrayList集合，定义一个DleiArrayList.
```
### 泛型的核心思想：
```markdown
把出现泛型变量的地方全部替换成传输的真实数据类型。
```

```markdown
小结：
    泛型的核心思想：把出现泛型变量的地方全部替换成传输的真实数据类型。
    拓展：集合和泛型都只能支持引用数据类型。
```

```java
public class GenericDemo {
    public static void main(String[] args) {
        DleiArrayList<String> lists = new DleiArrayList<>();
        lists.add("Java");
        lists.add("MySQL");
        lists.remove("MySQL");
        System.out.println(lists);

        DleiArrayList<Integer> lists1 = new DleiArrayList<>();
        lists1.add(12);
        lists1.add(13);
        lists1.remove(12);
        System.out.println(lists1);

    }
}

class DleiArrayList<E>{
    private ArrayList lists = new ArrayList();

    public void add(E e){
        lists.add(e);
    }

    public void remove(E e){
        lists.remove(e);
    }

    @Override
    public String toString() {
        return lists.toString();
    }
}
```
## 自定义泛型方法
### 什么是泛型方法？
```markdown
使用了且定义了泛型的方法就是泛型方法。
```
### 泛型方法的定义格式：
```java
修饰符 <定义泛型变量> 返回值类型 方法名称(泛型形参等){

        }
```
### 注意：
```markdown
泛型变量一般建议用E , T , K , V. 
如果一旦定义了某个泛型变量，后面就只能用这个泛型变量。

需求：给你任意一个数组可以直接输出它的全部内容信息。
```
### 小结：
```markdown
泛型方法的核心思想：
    定义泛型变量，在出现泛型变量的地方全部替换成真实传输的数据类型。
```

```java
public class GenericDemo {
    public static void main(String[] args) {
        Integer[] nums = new Integer[]{10, 20, 30};
        printArr(nums);

        String[] names = new String[]{"赵敏", "张无忌", "殷素素", "周芷若"};
        printArr(names);

        Double[] scores = new Double[]{99.9, 889.2, 100.0};
        printArr(scores);
    }

    // 定义一个方法：可以接收任意类型的数组且输出里面的元素信息。
    public static <T> void printArr(T[] arrs) {
        StringBuilder sb = new StringBuilder();
        sb.append("[");
        if (arrs != null && arrs.length > 0) {
            // 数组中存在元素，需要拼接
            for (int i = 0; i < arrs.length; i++) {
                T ele = arrs[i];
                sb.append(i == arrs.length - 1 ? ele : ele + ", ");
            }
        }
        sb.append("]");
        System.out.println(sb);
    }
}
```
## 自定义泛型接口
### 什么是泛型接口？
```markdown
定义了泛型的接口就是泛型接口。
```
### 泛型接口的格式：
```java
修饰符 interface 接口名称<泛型变量>{

        }
```
### 注意：
```markdown
泛型变量一般建议 E , T , K , V

需求：开发一个教务系统，必须要完成老师和学生信息的 增删改查操作。
```
### 小结：
```markdown
泛型接口的思想：
在实现泛型接口的时候，传入真实的操作的数据类型。
```

```java
public interface Data<E> {
    void add(E ele);
    void delete(E ele);
    void update(E ele);
    void query();
}
public class GenericDemo {
    public static void main(String[] args) {
        StudentData sdata = new StudentData();
        sdata.add(new Student());
        sdata.delete(new Student());

        TeacherData tData = new TeacherData();
        tData.add(new Teacher());
        tData.delete(new Teacher());
    }
}
public class Student {
}
public class StudentData implements Data<Student> {
    @Override
    public void add(Student ele) {
        System.out.println("保存学生对象："+ele);
    }

    @Override
    public void delete(Student ele) {
        System.out.println("删除学生对象："+ele);
    }

    @Override
    public void update(Student ele) {

    }

    @Override
    public void query() {

    }
}
public class Teacher {
}
public class TeacherData implements Data<Teacher> {
    @Override
    public void add(Teacher ele) {
        System.out.println("保存老师对象："+ele);
    }

    @Override
    public void delete(Teacher ele) {
        System.out.println("删除老师对象："+ele);
    }

    @Override
    public void update(Teacher ele) {

    }

    @Override
    public void query() {

    }
}
```
## 泛型的通配符和上下限
```markdown
需求：
    开发一个极品飞车的游戏，所有的车可以一起比赛。
```

### 注意：
#### 泛型是没有继承关系的：
```markdown
虽然BMW和BENQI都继承了Car 但是ArrayList<BMW>， ArrayList<BENQI>
跟ArrayList<Car>没有任何关系。
```
#### 通配符：？
```markdown
？可以在使用泛型的时候代表一切数据类型。
E , T , K , V 只能用在定义泛型的时候使用。
```
#### 泛型的上下限：
```markdown
? extends Car: ?必须是Car本身或者Car的子类。（泛型的上限）
? super Car: ?必须是Car或者Car的父类。（泛型的下限）
```

```markdown
小结：
    ？可以在使用泛型的时候代表一切数据类型。
    ? extends Car: ?必须是Car本身或者Car的子类
```

```java
public class Game {
    public static void main(String[] args) {
        ArrayList<BMW> bmws = new ArrayList<>();
        bmws.add(new BMW());
        bmws.add(new BMW());
        bmws.add(new BMW());
        go(bmws);

        ArrayList<BENQI> benqis = new ArrayList<>();
        benqis.add(new BENQI());
        benqis.add(new BENQI());
        benqis.add(new BENQI());
        go(benqis);

        ArrayList<Dog> dogs = new ArrayList<>();
        dogs.add(new Dog());
        dogs.add(new Dog());
        dogs.add(new Dog());
        //go(dogs);// 狗也进来比赛了！！

    }

    // 比赛的方法
    public static void go(ArrayList<? extends Car> cars){

    }
}

class Car{
    public void run(){

    }
}

class BMW extends Car{
    @Override
    public void run(){
        System.out.println("宝马跑的贼溜~~");
    }
}

class BENQI extends Car{
    @Override
    public void run(){
        System.out.println("奔驰你敢买我就敢漏油~~");
    }
}

class Dog{

}
```
# Collection集合
## 什么是集合，与数组有什么区别?
```markdown
集合是一个容器。容器中的数据称为元素。 数据==元素。
集合的大小和元素类型可以不固定：大小可变，类型任意。
数组的长度和数据类型在定义的时候就要确定：长度固定，类型固定。

数组一般适合用于做类型和个数确定的数据的存储和操作。
集合适合做元素个数不确定的存储和操作,以及需要对学生进行增删改查的操作。
开发中：集合用的更多。
```
## Java中集合的代表是：
```markdown
Collection。是全部集合的祖宗类。
```
## Collection集合的体系：
```markdown
                        Collection<E>(接口)
           /                                       \
           Set<E>(接口)                             List<E>(接口)
           /                                    /                     \                  \
           HashSet<E>(实现类)                   LinkedList<E>(实现类) Vector(线程安全)     ArrayList<E>(实现类)
           /
           LinkedHashSet<E>(实现类)
```
## Collection集合体系的特点：
### Set系列（Collection）集合：
```markdown
添加的元素是无序，不重复，无索引的。
    HashSet：添加的元素是无序，不重复，无索引的。
    LinkedHashSet：添加的元素是有序，不重复，无索引的。
```
#### Set系列集合元素去重复的流程
```markdown
    1.对于基本数据类型的值，Set集合可以直接判断进行去重复。
    2.对于引用数据类型的对象，Set集合是按照如下流程进行是否重复的判断。
        Set集合会让两两对象，先调用自己的hashCode()方法得到彼此的哈希值（所谓的内存地址）
        然后比较两个对象的哈希值是否相同，如果不相同则直接认为两个对象不重复。
        如果哈希值相同，会继续让两个对象进行equals比较内容是否相同，如果相同认为真的重复了
        如果不相同认为不重复。

                集合会先让对象调用hashCode()方法获取两个对象的哈希值比较
                   /                     \
                false                    true
                /                          \
            不重复                        继续让两个对象进行equals比较
                                           /          \
                                         false        true
                                          /             \
                                        不重复          重复了
        需求：只要对象内容一样，就希望集合认为它们重复了。重写hashCode和equals方法。
    小结：
        如果希望Set集合认为某两个对象重复了，可以重写hashCode和equals方法。

```

```java
public class HashSetDemo02 {
    public static void main(String[] args) {
        Set<Student> stus = new HashSet<>();
        Student s1 = new Student("张无忌",32,'男');
        System.out.println(s1.hashCode());
        Student s2 = new Student("张无忌",32,'男');
        System.out.println(s2.hashCode());
        Student s3 = new Student("赵敏",22,'女');
        System.out.println(s3.hashCode());

        stus.add(s1);
        stus.add(s2);
        stus.add(s3);
        System.out.println(stus);

    }
}
```
#### Set系列集合元素无序的根本原因
```markdown
    Set系列集合添加元素无序的根本原因是因为底层采用了哈希表存储元素。

    JDK 1.8之前：哈希表 = 数组 + 链表  + （哈希算法）
    JDK 1.8之后：哈希表 = 数组 + 链表 + 红黑树  + （哈希算法）
        当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。

    小结：
        Set系列集合是基于哈希表存储数据的
        它的增删改查的性能都很好！！但是它是无序不重复的！如果不在意当然可以使用！
```

```java
public class HashSetDemo03 {
    public static void main(String[] args) {
        HashSet<String> sets = new HashSet<>(); // 一行经典代码！！
        sets.add("Java");
        sets.add("Java");
        sets.add("Mybatis");
        sets.add("MySQL");
        sets.add("MySQL");
        sets.add("Spring");
        // [Java, MySQL, Spring, Mybatis]
        System.out.println(sets);
    }
}
```

```markdown
    LinkedHashSet底层依然是使用哈希表存储元素的，
    但是每个元素都额外带一个链来维护添加顺序！！
    不光增删查快，还有序。缺点是多了一个存储顺序的链会占内存空间!!而且不允许重复，无索引。

    总结：
         如果希望元素可以重复，又有索引，查询要快用ArrayList集合。（用的最多）
         如果希望元素可以重复，又有索引，增删要快要用LinkedList集合。（适合查询元素比较少的情况，经常要首尾操作元素的情况）
         如果希望增删改查都很快，但是元素不重复以及无序无索引，那么用HashSet集合。
         如果希望增删改查都很快且有序，但是元素不重复以及无索引，那么用LinkedHashSet集合。

```

```java
public class HashSetDemo04 {
    public static void main(String[] args) {
        // 有序 不重复，无索引的
        Set<String> sets = new LinkedHashSet<>();
        sets.add("Mybatis");
        sets.add("Mybatis");
        sets.add("Java");
        sets.add("Java");
        sets.add("MySQL");
        sets.add("Spring");
        sets.add("Dlei");
        sets.add("Dlei");
        System.out.println(sets);
    }
}
```

```java
public class Student {
    private String name ;
    private int age ;
    private char sex;

    public Student(){

    }

    public Student(String name, int age, char sex) {
        this.name = name;
        this.age = age;
        this.sex = sex;
    }
    // s1 = new Student("张无忌",32,'男')
    // s2 = new Student("张无忌",32,'男')
    // 只要两个对象的内容一样，哈希值也会是一样的
    @Override
    public int hashCode() {
        // Objects.hash(张无忌, 32, 男)
        // Objects.hash(张无忌, 32, 男)
        return Objects.hash(name, age, sex);
    }

    // 只要两个对象的内容一样，结果一定是true
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Student student = (Student) o;
        return age == student.age &&
                sex == student.sex &&
                Objects.equals(name, student.name);
    }



    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public char getSex() {
        return sex;
    }

    public void setSex(char sex) {
        this.sex = sex;
    }

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", sex=" + sex +
                '}';
    }
}
```

```java
public class HashSetDemo01 {
    public static void main(String[] args) {
        // 无序，不重复，无索引的。
        Set<String> sets = new HashSet<>(); // 一行经典代码！！
        sets.add("Mybatis");
        sets.add("Java");
        sets.add("Java");
        sets.add("MySQL");
        sets.add("MySQL");
        sets.add("Spring");
        System.out.println(sets);
    }
}
```
### List系列集合:
```markdown
添加的元素是有序，可重复，有索引的。
    LinkedList：添加的元素是有序，可重复，有索引的。
    ArrayList：添加的元素是有序，可重复，有索引的。
    Vector 是线程安全的，速度慢，工作中很少使用。
List集合继承了Collection集合的全部功能，同时因为List系列集合有索引，底层基于数组存储数据的，查询快，增删慢！所以多了很多按照索引操作元素的特有功能：
    public void add(int index, E element): 将指定的元素，添加到该集合中的指定位置上。
    public E get(int index):返回集合中指定位置的元素。
    public E remove(int index): 移除列表中指定位置的元素, 返回的是被移除的元素。
    public E set(int index, E element):用指定元素替换集合中指定位置的元素,返回值的更新前的元素。
```

```java
public class ListDemo01 {
    public static void main(String[] args) {
        // 1.创建一个ArrayList集合对象：经典代码！
        List<String> lists = new ArrayList<>(); // 经典代码！
        lists.add("java1");
        lists.add("java2");
        lists.add("java3");
        System.out.println(lists); // ["java1" , "java2", "java3"]

        // a.给某个索引位置插入一个元素
        lists.add(1,"MySQL");
        System.out.println(lists);

        // b.根据索引获取对应位置处的元素
        System.out.println(lists.get(1));

        // c.根据索引删除元素
        // 删除成功后返回被删元素值！
        System.out.println(lists.remove(1));
        System.out.println(lists);

        // d.修改某个索引位置处的元素,修改成功返回之前的元素值！
        System.out.println(lists.set(1,"MyBatis"));
        System.out.println(lists);


    }
}
```
#### List遍历方式：
```markdown
List系列集合多了索引，所以多了一种按照索引遍历集合的for循环。
    （1）for循环
    （2）迭代器
    （3）foreach
    （4）JDK 1.8新技术。
```

```java
public class ListDemo02 {
    public static void main(String[] args) {
        List<String> lists = new ArrayList<>();
        lists.add("java1");
        lists.add("java2");
        lists.add("java3");
        /** （1）for循环 */
        for(int i = 0 ; i < lists.size() ; i++ ){
            // i  = 0  1  2
            String ele = lists.get(i);
            System.out.println(ele);
        }

        System.out.println("---------------------");
        /** （2）迭代器 */
        Iterator<String> it = lists.iterator();
        while(it.hasNext()){
            System.out.println(it.next());
        }
        System.out.println("---------------------");
        /** （3）foreach */
        for(String ele : lists){
            System.out.println(ele);
        }

        System.out.println("---------------------");
        /** （4）JDK 1.8新技术。 */
        lists.forEach(s -> {
            System.out.println(s);
        });

    }
}
```

```markdown
LinkedList也是List的实现类：底层是基于链表的，增删比较快，查询慢！！
LinkedList是支持双链表，定位前后的元素是非常快的，增删前后的元素也是最快的所以LinkedList除了拥有List集合的全部功能还多了很多操作首尾元素的特殊功能：
    public void addFirst(E e):将指定元素插入此列表的开头。
    public void addLast(E e):将指定元素添加到此列表的结尾。
    public E getFirst():返回此列表的第一个元素。
    public E getLast():返回此列表的最后一个元素。
    public E removeFirst():移除并返回此列表的第一个元素。
    public E removeLast():移除并返回此列表的最后一个元素。
    public E pop():从此列表所表示的堆栈处弹出一个元素。
    public void push(E e):将元素推入此列表所表示的堆栈。

 小结：
    LinkedList对于List有的功能它全部都有，有序可重复有索引。
    底层基于链表存储元素，首尾元素的增删都很快，查询比较慢。
```

```java
public class ListDemo03 {
    public static void main(String[] args) {
        // 做一个队列。
        LinkedList<String> queue = new LinkedList();
        queue.addLast("第1个人");
        queue.addLast("第2个人");
        queue.addLast("第3个人");
        queue.addLast("第4个人");
        // 出队
        System.out.println(queue.removeFirst());
        System.out.println(queue.removeFirst());

        // 做一个栈
        LinkedList<String> stack = new LinkedList();
        // 压栈
        stack.push("第1个子弹");
        stack.push("第2个子弹");
        stack.push("第3个子弹");
        stack.push("第4个子弹");
        System.out.println(stack);
        // 弹栈
        System.out.println(stack.pop());
        System.out.println(stack.pop());
        System.out.println(stack.pop());
        System.out.println(stack);
    }
}
小结：
    Collection集合是集合的祖宗类，集合大小可变，类型可变，但是建议用泛型约束类型。
    Set系列集合特点：添加的元素是无序，不重复，无索引的。
    List系列集合:添加的元素是有序，可重复，有索引的。
```

```java
public class CollectionDemo {
    public static void main(String[] args) {
        // 添加的元素是无序，不重复，无索引的。
        Collection<String> sets = new HashSet<>();
        sets.add("MySQL");
        sets.add("MyBatis");
        sets.add("HTML");
        sets.add("HTML");
        sets.add("MyBatis");
        sets.add("Java");
        System.out.println(sets);

        // 添加的元素是有序，可重复，有索引的。
        Collection<String> lists = new ArrayList<>();
        lists.add("MySQL");
        lists.add("MyBatis");
        lists.add("HTML");
        lists.add("HTML");
        lists.add("MyBatis");
        lists.add("Java");
        System.out.println(lists);
    }
}
```
## Collection集合的常用API
```markdown
Collection集合作为一个容器提供了很多的操作功能：增删改查。
Collection集合是集合的祖宗类，它的功能是一切集合都可以直接使用的。
```

```java
public boolean add(E e)：  把给定的对象添加到当前集合中 。
public void clear() :清空集合中所有的元素。
public boolean remove(E e): 把给定的对象在当前集合中删除。
public boolean contains(Object obj): 判断当前集合中是否包含给定的对象。
public boolean isEmpty(): 判断当前集合是否为空。
public int size(): 返回集合中元素的个数。
public Object[] toArray(): 把集合中的元素，存储到数组中
```

```java
public class CollectionDemo {
    public static void main(String[] args) {
        Collection<String> c = new ArrayList<>();
        // 1.添加元素,添加成功返回true，反之
        c.add("Java1");
        c.add("Java2");
        c.add("Java3");
        System.out.println(c.add("Java3"));
        System.out.println(c);

        // 2.集合大小
        System.out.println(c.size());

        // 3.清空集合元素
        c.clear();
        System.out.println(c);

        // 4.判断集合是否为空，为空返回true . 反之中
        System.out.println(c.isEmpty()); //  true

        // 5.判断集合中是否包含某个元素。
        Collection<String> c1 = new ArrayList<>();
        c1.add("Java1");
        c1.add("Java2");
        c1.add("Java3");
        System.out.println(c1.contains("Java2"));// true
        System.out.println(c1.contains("Java4")); // false

        // 6.可以把集合转换成数组。
        Object[] arrs = c1.toArray();
        System.out.println("数组："+ Arrays.toString(arrs));

        // 拓展：一定要指定数组的类型
        String[] arrs1 = c1.toArray(new String[0]);
        System.out.println("数组："+ Arrays.toString(arrs1));

        System.out.println("-------------拓展------------------");
        Collection<String> c2 = new ArrayList<>();
        c2.add("Java1");
        c2.add("Java2");
        c2.add("Java3");

        Collection<String> c3 = new ArrayList<>();
        c3.add("Java4");
        c3.add("Java5");
        c3.add("Java6");
        // 把c3的全部元素倒入到c2中去。
        c2.addAll(c3);
        System.out.println(c2);
    }
}
```
## Collection集合的遍历方式
```markdown
遍历：一个一个的访问一遍元素，遍历很重要，开发中很多业务都要遍历实现。

Collection集合的功能是全部集合都可以直接使用的。
Collection遍历方式有三种：
    （1）迭代器。
    （2）foreach遍历（增强for循环）：是迭代器的简化写法。
    （3）JDK 1.8开始之后的新技术：Lambda表达式。（了解）
```
### 迭代器遍历集合的步骤

```markdown
    先获取当前被遍历集合的迭代器对象。
     方法：Iterator<E> iterator()
     代码：Iterator<String> it = names.iterator();
    定义一个while循环遍历， 先通过it.hasNext()问是否有下一个元素
    有就通过it.next()取出下一个元素返回，如果没有循环结束。
     方法：boolean hasNext()：询问是否有下一个元素，有返回true ,没有返回false.
     方法：E next()：取出下一个元素返回。
```

```markdown
小结：
    迭代器遍历是先得到集合的迭代器对象，然后通过迭代器对象询问是否有下一个元素，有就取出来。
```

```java
public class CollectionDemo01 {
    public static void main(String[] args) {
        Collection<String> names = new ArrayList<>();
        names.add("赵敏");
        names.add("张无忌");
        names.add("殷素素");
        names.add("小昭");
        System.out.println(names);

        // names = [赵敏, 张无忌, 殷素素,小昭]
        //                       it

        // 1.开始获取集合的迭代器遍历集合
        Iterator<String> it = names.iterator();
        /*System.out.println(it.next());
        System.out.println(it.next());
        System.out.println(it.next());
        System.out.println(it.next());*/
        // System.out.println(it.next()); // NoSuchElementException没有此元素异常

        // 2.定义一个while循环遍历集合
        while(it.hasNext()){
            String ele = it.next();
            System.out.println(ele);
        }
    }
}
```
### foreach遍历（增强for循环）：是迭代器的简化写法。
```markdown
关键是记住遍历格式：
for(被遍历集合或者数组中元素的类型 变量 : 被遍历集合或者数组 ){

        }
小结：
    foreach遍历优点：方便简单。
    foreach遍历的缺点：无法知道当前遍历到了哪个元素位置。
```

```java
public class CollectionDemo02 {
    public static void main(String[] args) {
        Collection<String> names = new ArrayList<>();
        names.add("赵敏");
        names.add("张无忌");
        names.add("殷素素");
        names.add("小昭");
        System.out.println(names);
        // names = [赵敏, 张无忌, 殷素素,小昭]
        //   ele
        for(String ele : names){
            System.out.println(ele);
        }
    }
}
```

### JDK 1.8开始之后的新技术：Lambda表达式
```markdown
小结：
    Collection集合的遍历方式是全部集合都可以用的。
```

```java
public class CollectionDemo03 {
    public static void main(String[] args) {
        Collection<String> names = new ArrayList<>();
        names.add("赵敏");
        names.add("张无忌");
        names.add("殷素素");
        names.add("小昭");
        System.out.println(names);
        // names = [赵敏, 张无忌, 殷素素,小昭]
        //   ele
        // JDK 1.8开始之后的新技术：Lambda表达式
        names.forEach(ele -> {
            System.out.println(ele);
        });
    }
}
```

## 斗地主游戏的案例开发
```markdown
业务需求分析：
    斗地主的做牌，洗牌，发牌。
    业务:总共有54张牌。
    点数: "3","4","5","6","7","8","9","10","J","Q","K","A","2"
    花色: "♠", "♥", "♣", "♦"
    大小王: "👲" , "👨"
    点数分别要组合4种花色，大小王各一张。

斗地主：
    发出51张牌，剩下3张作为底牌。

功能：
    1.做牌。
    2.洗牌
    3.定义3个玩家。
    4.发牌。
    5.看牌。
```

```java
public class GameDemo {
    // a.定义一个集合存储做好的54张牌：♠3 ，♠4。
    public static List<Card> cards = new ArrayList<>();
    static {
        /** 1.做牌。54张牌做好放到cards集合中去 */
        // 定义点数：类型确定了，个数确定了。应该用数组
        String[] sizes = {"3","4","5","6","7","8","9","10","J","Q","K","A","2"};
        // 定义花色：类型确定了，个数确定了。应该用数组
        String[] colors = {"♠", "♥", "♣", "♦"};
        // 先遍历点数，再遍历花色组合牌对象
        for(String size : sizes){
            for(String color : colors){
                // 创建一个牌对象
                Card card = new Card(size , color);
                // 把这张牌放到集合中存储起来
                cards.add(card);
            }
        }
        // 单独创建大小王对象 ："👲" , "👨"
        cards.add(new Card("","👲" ));
        cards.add(new Card("","👨" ));
        System.out.println("新牌："+cards);
    }

    public static void main(String[] args) {
        /** 2.洗牌：就是把牌的顺序打乱 */
        // public static void shuffle(List<?> list) :打乱List集合的顺序。
        Collections.shuffle(cards);
        System.out.println("洗牌后："+cards);

        /** 3.定义3个玩家。*/
        List<Card> linghuChong = new ArrayList<>();
        List<Card> renYingYing = new ArrayList<>();
        List<Card> dongFangBuBai = new ArrayList<>();

        /** 4.发牌：把洗后的牌依次发出51张出去，剩余三张作为底牌 */
        // cards = [♥3, ♠8, ♦8, ♠K, ♦7, ♥6, ♣6, ♣9, ♦4,....
        //    i     0    1   2   3   4   5   6  7   8   % 3
        for(int i = 0 ; i < cards.size() - 3 ; i++ ){
            Card c = cards.get(i);
            if(i % 3 == 0 ) {
                // 请令狐冲接牌
                linghuChong.add(c);
            }else if( i % 3 == 1){
                // 请盈盈接牌
                renYingYing.add(c);
            }else if(i % 3 == 2){
                // 请东方不败接牌
                dongFangBuBai.add(c);
            }
        }

        /** 5.看牌。*/
        System.out.println("冲冲："+linghuChong);
        System.out.println("盈盈："+renYingYing);
        System.out.println("东方："+dongFangBuBai);
        // System.out.println("底牌："+cards.get(53)+"->"+cards.get(52)+"->"+cards.get(51));

        // 拓展：截取最后三张底牌！
        List<Card> lastThreeCards = cards.subList(cards.size()-3 , cards.size());
        System.out.println("底牌："+lastThreeCards);
    }
}
public class Card {
    // 点数
    private String size;
    // 花色
    private String color;

    public Card() {

    }

    public Card(String size, String color) {
        this.size = size;
        this.color = color;
    }

    public String getSize() {
        return size;
    }

    public void setSize(String size) {
        this.size = size;
    }

    public String getColor() {
        return color;
    }

    public void setColor(String color) {
        this.color = color;
    }

    @Override
    public String toString() {
        return color+size;
    }
}
```
## Collections工具类
```markdown
Collections是一个操作集合的工具类，本身不是集合
只是辅助操作集合功能的类。
Collections下的方法都是静态方法，无需创建对象调用，直接用类名访问即可！
```
### Collections下的API:
```java
    1、public static <T> boolean addAll(Collection<? super T> c, T... elements)
        -- 参数一：操作的集合对象。
        -- 参数二：可变参数，给集合批量加的元素值。
    2、public static void shuffle(List<?> list)：
        -- 打乱List集合的顺序
    3、public static <T extends Comparable<? super T>> void sort(List<T> list)
        -- 给List集合进行默认的升序排序。默认只能由小到大。
        -- 有值特性的，按照值特性排序。
        -- 对于字符串按照首字母的编号排序！
        注意： 此方法默认不能给引用类型的对象做排序，因为人家不知道你的排序规则！
    4、public static <T> void sort(List<T> list,Comparator<? super T> c)
        -- 参数一：被排序的集合对象。
        -- 参数二：比较器对象，用于程序员来定制大小排序规则。

小结：
    对于有值特性的集合，sort可以直接排序，但是 此方法默认不能给引用类型的对象做排序
    对于引用类型的集合对象元素，必须用比较器的方式来进行比较排序。
```

```java
public class CollectionsDemo01 {
    public static void main(String[] args) {
        List<String> names = new ArrayList<>();
//        names.add("吴晓桐");
//        names.add("王创欣");
//        names.add("张城宏");
        // 1.给集合批量添加元素。
        Collections.addAll(names , "吴晓桐","王创欣","张城宏" );
        System.out.println(names);

        // 2.只能打乱List集合的顺序
        // public static void shuffle(List<?> list)
        Collections.shuffle(names);
        System.out.println(names);

        // 3.只能给List系列集合进行排序（默认是升序排序）
        // public static <T extends Comparable<? super T>> void sort(List<T> list)
        List<Double> scores = new ArrayList<>() ;
        Collections.addAll(scores , 10.0 , 98.2 , 100.0 , 75.5 , 0.0 , 23.5);
        System.out.println(scores);
        Collections.sort(scores); // 排序
        System.out.println(scores);

        // 4.字符串排序研究(按照字符串首字符的编号大小进行升序排序)
        List<String> nameEns = new ArrayList<>() ;
        Collections.addAll(nameEns ,"Dlei" , "Zero" , "abooooooo" , "jack" , "殷素素" , "rose" , "aboart");
        Collections.sort(nameEns); // 排序
        System.out.println(nameEns);

    }
}
public class CollectionsDemo02 {
    public static void main(String[] args) {
        Student s1 = new Student("张三丰", 100, '男');
        Student s2 = new Student("张无忌", 32, '男');
        Student s3 = new Student("赵敏",   22, '女');
        Student s4 = new Student("殷素素", 45, '女');

        List<Student> students = new ArrayList<>();
//        students.add(s1);
//        students.add(s2);
//        students.add(s3);
//        students.add(s4);
        Collections.addAll(students , s1 , s2, s3, s4);
        System.out.println(students);
        /**
         * 参数一：被排序的集合对象。
         * 参数二：比较器对象：Comparator
         * 需求：按照年龄升序排序！
         */
        Collections.sort(students, new Comparator<Student>() {
            @Override
            public int compare(Student o1, Student o2) {
                // 会自动提取集合的两两元素进来进行比较。
                // 如果认为o1 > o2 返回正整数即可。
                // 如果认为o1 < o2 返回负整数即可。
                // 如果认为o1 = o2 返回0即可。
//                if(o1.getAge() > o2.getAge()){
//                    return 1;
//                }else if(o1.getAge() < o2.getAge()){
//                    return -1;
//                }
//                return 0;
                return o1.getAge() - o2.getAge();
            }
        }); //



        System.out.println(students);
    }
}
public class Student {
    private String name ;
    private int age ;
    private char sex ;

    public Student() {
    }

    public Student(String name, int age, char sex) {
        this.name = name;
        this.age = age;
        this.sex = sex;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public char getSex() {
        return sex;
    }

    public void setSex(char sex) {
        this.sex = sex;
    }

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", sex=" + sex +
                '}'+"\n";
    }


}
```

# 数据结构
```markdown
集合是基于数据结构做出来的，不同的集合底层会采用不同的数据结构。不同的数据结构，功能和作用是不一样的。
```
## 什么是数据结构？
```markdown
数据结构指的是数据以什么方式组织在一起。
不同的数据结构，增删查的性能是不一样的。
不同的集合底层会采用不同的数据结构，我们要知道集合的底层是基于哪种数据结构存储和操作数据的。这样才能知道具体场景用哪种集合。
```
## Java常见的数据结构有哪些?
```markdown
a.队列（queue）
    -- 先进先出，后进后出。
    -- 场景：各种排队。叫号系统。
    -- 有很多集合可以实现队列。

b.栈（stack）
    -- 后进先出，先进后出
    -- 压栈 == 入栈
    -- 弹栈 == 出栈
    -- 场景：手枪的弹夹。


c.线性表（数组）
    -- 线性表是内存中的连续存储区域。
    -- 分成若干等分的小区域（每个区域大小是一样的）
    -- 元素存在索引
    -- 特点：查询元素快（根据索引快速计算出元素的地址，然后立即去定位）
            增删元素慢（创建新数组，迁移元素）

d.链表
    -- 元素不是内存中的连续区域存储。
    -- 元素是游离存储的。每个元素会记录下个元素的地址。
    -- 特点：查询元素慢
            增删元素快（针对于首尾元素，速度极快，一般是双链表）

e.红黑树
    二叉树：binary tree 永远只有一个根节点,是每个结点不超过2个节点的树（tree） 。
    排序二叉树：小的左边，大的右边，但是可能树很高，性能变差。为了做排序和搜索!!
    红黑树（就是自平衡的排序二叉树）：
       树尽量的保证到了很矮小，但是又排好序了，性能最高的树。增删查改性能都好！！！
```
# 正则表达式
```markdown
正则表达式是一些特殊的格式化字符，可以用于做信息校验。
```
## 正则表达式的作用？
```markdown
可以用于校验邮箱，手机号码，电话等信息是否合法，是否满足规范。
可以用于做网络爬虫，可以从一大推的信息中爬出我们想要的数据。
```

```java
public class Demo01 {
    public static void main(String[] args) {
        // 1.正则表达式的入门使用。
        String regex = "[abc]";
        System.out.println("a".matches(regex)); // true
        System.out.println("d".matches(regex)); // false

        String regex1 = "[^abc]"; // 不能出现abc.
        System.out.println("a".matches(regex1)); // false
        System.out.println("d".matches(regex1)); // true

        String regex2 = "[a-zA-Z]"; // 只能是英文字母
        System.out.println("Z".matches(regex2)); // true
        System.out.println("2".matches(regex2)); // false

       /** 预定义字符类
        . 任何字符
        \d 数字：[0-9]
        \D 非数字： [^0-9]
        \s 空白字符：[ \t\n\x0B\f\r]
        \S 非空白字符：[^\s]
        \w 单词字符：[a-zA-Z_0-9]
        \W 非单词字符：[^\w]
        */
        System.out.println("2".matches("\\d"));
        System.out.println("徐".matches("\\w"));
        System.out.println("A".matches("\\w"));

        /**
         Greedy 数量词
         X? X，一次或一次也没有
         X* X，零次或多次
         X+ X，一次或多次
         X{n} X，恰好 n 次
         X{n,} X，至少 n 次
         X{n,m} X，至少 n 次，但是不超过 m 次
         */

        // 校验密码：至少6个字母数字下划线。
//        Scanner sc = new Scanner(System.in);
//        System.out.print("请输入密码：");
//        String pwd = sc.nextLine();
//        if(pwd.matches("\\w{6,}")){
//            System.out.println("密码合法！");
//        }else{
//            System.err.println("密码格式不正确，至少6个字母数字下划线!");
//        }

//        Scanner sc = new Scanner(System.in);
//        System.out.print("请输入手机号码：");
//        String phone = sc.nextLine();
//        if(phone.matches("1[3-9]\\d{9}")){
//            System.out.println("手机合法！");
//        }else{
//            System.err.println("手机格式不正确！");
//        }


        Scanner sc = new Scanner(System.in);
        System.out.print("请输入邮箱：");
        String email = sc.nextLine();
        // 251425887@qq.com
        // xulei2@itcast.cn
        // dlei0009@163.com
        // dlei009@pic.com.cn
        if(email.matches("\\w+@\\w{1,20}(\\.\\w{1,10}){1,2}")){
            System.out.println("email合法！");
        }else{
            System.err.println("email格式不正确！");
        }
    }
}
```
## 正则表达式案例
```markdown
使用正则表达式来爬取一段文字中的电话号码和邮箱。
```

```java
public class Demo02 {
    public static void main(String[] args) {
        String content = "地址三：北京市顺义区京顺路99号黑马程序员（教学楼A栋）" +
                "电话：400-618-4000,手机号码18665616520 ， " +
                "座机 北京市02022209358顺义区京顺027-28309358，或者027-110" +
                " 北京市顺义区京顺邮箱是xulei2@itcast.cn";

        // 1.定义爬取规则。
        String regex = "(\\w+@\\w{1,20}(\\.\\w{1,10}){1,2})|(1[3-9]\\d{9})|(4\\d{2,3}-?\\d{2,6}-?\\d{2,10})|(0\\d{2,6}-?\\d{3,12})";
        // 2.需要把正则表达式进行编译成匹配规则对象。
        Pattern pattern = Pattern.compile(regex);
        // 3.开始通过匹配规则对象pattern去定义内容的匹配器对象
        Matcher matcher = pattern.matcher(content);
        // 4.拿着匹配器开始去内容中爬取想要的信息。
        while(matcher.find()){ // 寻找
            System.out.println(matcher.group()); // 取出来
        }
    }
}
```
# 可变参数
## 可变参数的作用：
```markdown
可变参数可以用在方法，构造器等形参中，用于接收多个数据。
```
## 可变参数的格式：
```markdown
数据类型... 变量名称
可变参数在内部本质上就是一个数组！！
```
## 可变参数的优点：
```markdown
参数传输非常的灵活！！
```
## 可变参数的注意事项：
```markdown
1.一个形参列表中只能有一个可变参数。
2.可变参数必须放在形参列表的最后面
```

```java
public class MethodDemo {
    public static void main(String[] args) {
        sum(); // 不传参数。
        sum(1); // 1个参数。
        sum(1,2,2,3,3,4,4); //多个参数。
        sum(new int[]{10,20,30,40}); //可以传输一个数组。
    }

    public static void sum(int... nums){
        //  nums对外是可变参数，对内是一个数组
        System.out.println(nums.length);
        System.out.println("参数："+Arrays.toString(nums));
    }
}
```
# 冒泡排序
```markdown
    我们之前排序都是调用sun公司写好的API，直接实现排序！
    我们现在来自己通过一种比较算法实现排序。编程思想的技术，提高编程能力和理解能力。
```
## 冒泡排序的作用：
```markdown
可以用于对数组或者对集合的元素进行大小排序！！
```
## 冒泡排序的核心算法思想:
```markdown
int[] arr = new int[] {55, 22, 99, 88};
每次从数组的第一个位置开始两两比较。把较大的元素与较小的元素进行层层交换。
最终把当前最大的一个元素存入到数组当前的末尾。这就是冒泡思想。
```
## 冒泡排序的核心点：
```markdown
每次两两比较找出当前最大值冒出到当前最后面即可！！
```
## 分析：
```markdown
        冒泡排序总共要找几轮：数组的长度-1
        每轮要比较几次：数组的长度 - i - 1
        int[] arr = new int[] {55 , 22 , 99, 88};

        i                比较的次数
        0                3
        1                2
        2                1
    小结：
        冒泡排序的思想是每轮两两比较，较大值与后面的元素交换位置。
        外部循环控制：数组的长度-1轮
        每轮要比较几次：数组的长度 - i - 1
```

```java
public class BubbleSort {
    public static void main(String[] args) {
        // 1,定义一个数组
        int[] arr = new int[] {55, 22, 99, 88};
        // 2.定义一个循环控制总共找几轮
        for(int i = 0 ; i < arr.length - 1 ; i++){
            // 3.内部循环控制当前轮比较多少次
            for(int j = 0 ;  j < arr.length - 1 - i ; j++){
                // i = 0   j = 0 1 2
                // i = 1   j = 0 1
                // i = 2   j = 0
                // 4.拿当前位置的元素值与后一个元素进行大小比较。
                if(arr[j] > arr[j+1]){
                    // 必须交换位置，大的元素往后走。
                    int temp = arr[j+1];
                    arr[j+1] = arr[j];
                    arr[j] = temp;
                }
            }
        }
        System.out.println("结果："+ Arrays.toString(arr));
    }

}
```

# Map集合
```markdown
    Map集合是一种双列集合，每个元素包含两个值。
    Map集合的每个元素的格式：key=value(键值对元素)。
    Map集合也被称为“键值对集合”。

    Map集合是另一个集合体系。
    Collection是单值集合体系。
```

## Map集合的完整格式：
```java
{key1=value1 , key2=value2 , key3=value3 , ...}
```
## Map集合有啥用？
```markdown
1.Map集合存储的信息更加的丰富。
     Collection: ["苍老师","日本","女","动作演员",23,"广州"]
     Map : {name="苍老师" , jiaxiang=小日本 , sex="女" , age = 23 , addr=广州}

2.Map集合很适合做购物车这样的系统。
    Map:  {娃娃=30 , huawei=1000 , iphonex=1}
    注意：集合和泛型都只能支持引用数据类型，集合完全可以称为是对象容器，存储都是对象。
```
## Map集合的体系：
```markdown
        Map<K , V>(接口,Map集合的祖宗类)
        |
        HashMap<K , V>(实现类,经典的，用的最多)
        |
        LinkedHashMap<K, V>(实现类)
```
## Map集合的特点：
```markdown
        1.Map集合的特点都是由键决定的。
        2.Map集合的键是无序,不重复的，无索引的。
            Map集合后面重复的键对应的元素会覆盖前面的整个元素！
        3.Map集合的值无要求。
        4.Map集合的键值对都可以为null。

       HashMap:元素按照键是无序，不重复，无索引，值不做要求。
       LinkedHashMap:元素按照键是有序，不重复，无索引，值不做要求。
```

```java
public class MapDemo {
    public static void main(String[] args) {
        Map<String , Integer> maps = new HashMap<>(); // 一行经典代码。
        maps.put("娃娃",1);
        maps.put("娃娃",10);
        maps.put("快乐用品",2);
        maps.put("快乐用品",23);
        maps.put("iphone11" , 1000);
        maps.put("iphoneX" , 1000);
        maps.put(null , null);
        System.out.println(maps);
    }
}
```
## Map集合的常用API
```java
public V put(K key, V value):  把指定的键与指定的值添加到Map集合中。
public V remove(Object key): 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。
public V get(Object key) 根据指定的键，在Map集合中获取对应的值。
public Set<K> keySet(): 获取Map集合中所有的键，存储到Set集合中。
public boolean containKey(Object key):判断该集合中是否有此键。
```

```java
public class MapDemo {
    public static void main(String[] args) {
        Map<String , Integer> maps = new HashMap<>();
        // 1.添加元素
        maps.put("娃娃",2);
        maps.put("iphoneX",100);
        maps.put("huawei",10);
        maps.put("iphoneX" , 10);
        maps.put(null , null);
        System.out.println(maps);
        // maps = {null=null, huawei=10, iphoneX=10, 娃娃=2}

        // 2.获取集合的大小
        System.out.println(maps.size());

        // 3.判断集合是否为空
        System.out.println(maps.isEmpty()); // false

        // 4.清空集合
        maps.clear();

        // 5.根据键获取值
        Map<String , Integer> maps1 = new HashMap<>();
        maps1.put("娃娃",2);
        maps1.put("iphoneX",100);
        maps1.put("huawei",10);
        maps1.put("iphoneX" , 10);
        System.out.println(maps1);
        // 根据键获取值
        System.out.println(maps1.get("huawei"));

        // 6.根据键删除整个元素
        //maps1.remove("iphoneX");
        //System.out.println(maps1);

        // 7.获取全部的键返回一个Set集合。
        //  Set<K> keySet(): 键是无序不重复，返回Set集合
        Set<String> keys = maps1.keySet();
        System.out.println(keys);

        // 8.提取Map集合全部的值返回的是一个Collection集合。
        //  Collection<V> values():值是不做要求的，可能重复，返回Collection集合。
        Collection<Integer> values = maps1.values();
        System.out.println(values);

        // 9.判断是否包含某个键
        //  boolean containsKey(Object key);
        System.out.println(maps1.containsKey("娃娃")); // true
        System.out.println(maps1.containsValue("iphone11")); // false

        // 10.判断是否包含某个值：
        //  boolean containsValue(Object value);
        System.out.println(maps1.containsValue(10));// true
        System.out.println(maps1.containsValue(2));// true
        System.out.println(maps1.containsValue(12)); // false

    }
}
```
## Map集合的遍历
### 1.键找值的方式遍历：先拿到Map集合所有的键，再通过遍历键获取对应值。（最简单的）
```java
public class MapDemo01 {
    public static void main(String[] args) {
        Map<String, Integer> maps = new HashMap<>();
// 1.添加元素：添加键值对元素
        maps.put("iphoneX", 1);
        maps.put("娃娃", 8);
        maps.put("huawei", 8);
        maps.put("Java", 1);
        System.out.println(maps);
// maps  = {huawei=8, Java=1, iphoneX=1, 娃娃=8}

        // a.先提取map集合全部的键到一个Set集合中去
        Set<String> keys = maps.keySet();  // [huawei , Java , iphoneX , 娃娃]
        // b.再通过遍历键获取对应值。
        for (String key : keys) {
            // 根据键取出对应的值
            Integer value = maps.get(key);
            System.out.println(key + "---->" + value);
        }

    }
}
```
### 2.键值对方式遍历
```java
public class MapDemo02 {
    public static void main(String[] args) {
        Map<String,Integer> maps = new HashMap<>();
        // 1.添加元素：添加键值对元素
        maps.put("iphoneX" , 1);
        maps.put("娃娃" , 8);
        maps.put("huawei" , 8);
        maps.put("Java" , 1);
        System.out.println(maps);
        /**
            maps = {huawei=8, Java=1, iphoneX=1, 娃娃=8}
            最开始是想直接用foreach遍历Map集合
            发现foreach根本不能直接遍历Map集合，Map集合的键值对元素直接来看是没有类型的。
                |
            把Map集合转换成Set集合:Set<Map.Entry<K, V>> entrySet();
                |
            Set<Map.Entry<String,Integer>> entries = maps.entrySet();
            entries = [ (huawei=8), (Java=1), (iphoneX=1), (娃娃=8)]
                         entry
            此时里面的键值对元素(huawei=8)变成了一个对象，有了类型，类型是：Map.Entry<String,Integer>
         */
        Set<Map.Entry<String, Integer>> entries = maps.entrySet();
        for(Map.Entry<String,Integer> entry : entries){
            String key = entry.getKey();
            Integer value = entry.getValue();
            System.out.println(key +"---->"+value);
        }


    }
}
```
### 3.JDK 1.8开始的新技术
```java
public class MapDemo03 {
    public static void main(String[] args) {
        Map<String,Integer> maps = new HashMap<>();
        // 1.添加元素：添加键值对元素
        maps.put("iphoneX" , 1);
        maps.put("娃娃" , 8);
        maps.put("huawei" , 8);
        maps.put("Java" , 1);
        System.out.println(maps);
        //   maps = {huawei=8, Java=1, iphoneX=1, 娃娃=8}

        maps.forEach((k , v) -> {
            System.out.println(k +"--->"+v);
        });

    }
}
```
## Map集合存储自定义类型元素
```java
public class MapDemo {
    public static void main(String[] args) {
        // 学生对象作为键的类型，值用字符串表示地址信息
        Map<Student , String> maps = new HashMap<>();
        maps.put(new Student("欧世杰",18,'男') , "广州");
        maps.put(new Student("林志玲",41,'女') , "日本");
        maps.put(new Student("林志玲",41,'女') , "日本");
        maps.put(new Student("古天乐",41,'男') , "香港");

        // 可以遍历
        maps.forEach( (stu , addr) -> {
            System.out.println(stu.getName() +"在："+addr);
        });

    }
}
```
## LinkedHashMap
```markdown
    HashMap是按照键无序不重复，无索引的，底层也是基于哈希表存储数据的，只是每个数据多了附属值。
    LinkedHashMap是按照键“有序”不重复，无索引的，底层也是基于哈希表存储数据的，只是每个数据多了附属值。每个键数据多了一个链记录添加顺序。

    覆盖：只改值！！不会改顺序！

    小结：
         Map集合的性能都挺好的，基于哈希表存储数据的，可以支持键值对元素！！!
         - List<String> names = new ArrayList<>();
         - Map<String , Integer> names = new HashMap<>()；
```

```java
public class LinkedHashMapDemo {
    public static void main(String[] args) {
        Map<String,Integer> maps = new LinkedHashMap<>();
        // 1.添加元素：添加键值对元素
        maps.put("iphoneX" , 1);
        maps.put("娃娃" , 8);
        maps.put("Java" , 1);
        maps.put("huawei" , 8);
        maps.put("Java" , 22);
        System.out.println(maps);
    }
}
```
## 图书管理系统案例
```java
public class Book {
    private String name ;  // 书名
    private String author; // 作者
    private double price ; // 价格

    public Book(){

    }

    public Book(String name, String author, double price) {
        this.name = name;
        this.author = author;
        this.price = price;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getAuthor() {
        return author;
    }

    public void setAuthor(String author) {
        this.author = author;
    }

    public double getPrice() {
        return price;
    }

    public void setPrice(double price) {
        this.price = price;
    }

    @Override
    public String toString() {
        return "Book{" +
                "name='" + name + '\'' +
                ", author='" + author + '\'' +
                ", price=" + price +
                '}';
    }
}

```

```java
/**
    目标：图书管理系统的开发。

    业务需求分析：
        （1）查看全部书籍。query
        （2）添加书本信息。add
        （3）删除书本信息。delete
        （4）修改书本信息。update
        （5）退出系统。 exit

    书本信息的结构:

        栏目                书名            价格        作者
        ---------------------------------------------------
        言情小说
                         《金瓶梅》         99.9        阿猫
                         《红楼梦》         198.2       曹雪芹
        武侠小说
                         《三少爷的剑》      98.2        古龙
                         《神雕侠侣》        98.2        金庸
        ------------------------------------------------------

    分析:
        （1）定义一个书本类，来代表书本对象。 Book.java
        （2）定义一个集合来代表一个图书馆，这个集合只需要一个。
            定义一个静态的集合：Map<String , List<Book>>
        （3）开发功能，让用户选择操作命令，执行相关功能。

 */
public class BookSystem {
    /**
     （2）定义一个集合来代表一个图书馆，这个集合只需要一个。
         用于存储系统所有的书本信息
     */
    public static final Map<String, List<Book>> BOOKS_STORE = new HashMap<>();

    /**
      定义一个静态的扫描器对象
     */
    public static final Scanner SYS_SCANNER = new Scanner(System.in);

    public static void main(String[] args) {
        /**（3）开发功能，让用户选择操作命令，执行相关功能。*/
        showCommand();
    }

    /**
        展示系统所有的功能操作命令
     */
    public static void showCommand() {
        System.out.println("（1）查看全部书籍: query");
        System.out.println("（2）添加书本信息: add");
        System.out.println("（3）删除书本信息: delete");
        System.out.println("（4）修改书本信息: update");
        System.out.println("（5）退出系统：exit");
        System.out.print("请选择您的操作命令：");
        String command = SYS_SCANNER.nextLine();
        switch (command){
            case "query":
                // 查看全部书籍:
                queryBooks();
                break;
            case "add":
                // 添加书本信息:
                addBook();
                break;
            case "delete":
                // 删除书本信息:
                // 作业：
                break;
            case "update":
                // 修改书本信息:
                updateBook();
                break;
            case "exit":
                // 退出系统:
                System.out.println("欢迎下次光临！");
                System.exit(0); // 干掉JVM虚拟机。
                break;
            default:
                System.err.println("您的命令输入非法！");
        }
        // 递归自己方法。
        showCommand();
    }

    /**
         修改书本信息
         Map<String, List<Book>> BOOKS_STOR
         = {言情小说=[book1 ,book2] , 武侠=[book1 ,book2]}
     */
    public static void updateBook() {
        System.out.println("--------------------修改书本的业务--------------------");
        while(true){
            System.out.print("请您输入书本栏目：");
            String type = SYS_SCANNER.nextLine();
            // 判断是否存在这个栏目
            if(BOOKS_STORE.containsKey(type)){
                // 存在该栏目了。
                // 2.请输入需要修改的书本名称。
                while(true){
                    System.out.print("请您输入书本名称：");
                    String name = SYS_SCANNER.nextLine();
                    // 3.判断是否存在这本书：去当前栏目的橱柜中查询是否存在该书名。
                    Book book = selectBookByTypeAndName(type, name);
                    // 4.判断是否有这本书
                    if(book!=null){
                        // 5.该书存在，可以修改了
                        System.out.print("请您输入修改书本名称：");
                        String newName = SYS_SCANNER.nextLine();
                        System.out.print("请您输入修改书本价格：");
                        String newPrice = SYS_SCANNER.nextLine();
                        System.out.print("请您输入修改书本作者：");
                        String newAuthor = SYS_SCANNER.nextLine();
                        // 6.对需要修改的那本书修改即可！
                        book.setName(newName);
                        book.setPrice(Double.valueOf(newPrice));
                        book.setAuthor(newAuthor);
                        System.out.println("修改成功了！");
                        queryBooks(); // 触发查询
                        return;// 结束当前方法！
                    }else{
                        System.err.println("您的书名瞎搞了！");
                    }
                }
            }else{
                System.err.println("对不起，不存在该栏目！");
            }
        }
    }

    /**
     * 根据栏目和书名查询出这本书对象。
     * @param type
     * @param name
     * @return
     */
    public static Book selectBookByTypeAndName(String type , String name){
        // 1.提取出当前栏目下的全部书本信息（橱柜）
        List<Book> books = BOOKS_STORE.get(type);
        for(Book book : books){
            if(book.getName().equals(name)){
                return book ; // 找到这本书了，并返回了！
            }
        }
        return null;
    }


    /**
        查询系统的全部书本信息
        Map<String, List<Book>> BOOKS_STOR
        = {言情小说=[book1 ,book2] , 武侠=[book1 ,book2]}
     */
    public static void queryBooks() {
        System.out.println("--------------------查询书本的业务--------------------");
        // 判断是否存在书本信息
        if(BOOKS_STORE.size() > 0){
            System.out.println("栏目\t\t\t书名\t\t\t价格\t\t作者");
            BOOKS_STORE.forEach((type , books) -> {
                System.out.println(type);
                for(Book book : books){
                    System.out.println("\t\t\t"+book.getName()+"\t\t"+book.getPrice()+"\t\t"+book.getAuthor());
                }
            });
        }else{
            System.out.println("对不起，您还没有添加任何书本信息！");
            System.out.println("-----------------------------------------------------");

        }
    }

    /**
        添加书本信息
        Map<String, List<Book>> BOOKS_STORE。
     */
    public static void addBook(){
        System.out.println("--------------------添加书本的业务--------------------");
        // 1.让用户输入栏目。
        System.out.print("请您输入书本栏目：");
        String type = SYS_SCANNER.nextLine();
        // 2.定义一个List集合用于保存这个栏目的橱柜
        List<Book> books = null ;
        // 判断是否存在这个栏目
        if(BOOKS_STORE.containsKey(type)){
            // 之前已经存在该栏目
            // 3.直接获取该栏目的值：橱柜对象List<Book>
            books = BOOKS_STORE.get(type);
        }else{
            // 这个栏目是第一次添加
            // 手工创建一个新橱柜
            books = new ArrayList<>();
            // 把这个栏目和橱柜放到图书馆中去
            BOOKS_STORE.put(type , books);
        }
        // 4.为当前橱柜加一本书对象。
        System.out.print("请您输入书本名称：");
        String name = SYS_SCANNER.nextLine();
        System.out.print("请您输入书本价格：");
        String price = SYS_SCANNER.nextLine();
        System.out.print("请您输入书本作者：");
        String author = SYS_SCANNER.nextLine();
        Book book = new Book(name ,author,Double.valueOf(price));
        books.add(book);
        System.out.println("您添加的"+name+"已经成功添加到"+type+"中去!");
    }

}
```
## 斗地主游戏案例
```markdown
业务需求分析：
    斗地主的做牌，洗牌，发牌。
    业务:总共有54张牌。
    点数: "3","4","5","6","7","8","9","10","J","Q","K","A","2"
    花色: "♠", "♥", "♣", "♦"
    大小王: "👲" , "👨"
    点数分别要组合4种花色，大小王各一张。

    斗地主：发出51张牌，剩下3张作为底牌。

    功能：
        1.做牌。
        2.洗牌
        3.定义3个玩家。
        4.发牌。
        5.看牌。
public class GameDemo {
    // a.定义一个集合存储做好的54张牌：♠3 ，♠4。
    public static List<Card> cards = new ArrayList<>();
    // 定义一个集合用于备份新牌。
    public static List<Card> newCards = new ArrayList<>();
    static {
        /** 1.做牌。54张牌做好放到cards集合中去 */
        // 定义点数：类型确定了，个数确定了。应该用数组
        String[] sizes = {"3","4","5","6","7","8","9","10","J","Q","K","A","2"};
        // 定义花色：类型确定了，个数确定了。应该用数组
        String[] colors = {"♠", "♥", "♣", "♦"};
        // 先遍历点数，再遍历花色组合牌对象
        for(String size : sizes){
            for(String color : colors){
                // 创建一个牌对象
                Card card = new Card(size , color);
                // 把这张牌放到集合中存储起来
                cards.add(card);
            }
        }
        // 单独创建大小王对象 ："👲" , "👨"
        cards.add(new Card("","👲" ));
        cards.add(new Card("","👨" ));
        System.out.println("新牌："+cards);
        newCards.addAll(cards); // 把新牌备份一份到newCards中去
    }

    public static void main(String[] args) {
        /** 2.洗牌：就是把牌的顺序打乱 */
        // public static void shuffle(List<?> list) :打乱List集合的顺序。
        Collections.shuffle(cards);
        System.out.println("洗牌后："+cards);

        /** 3.定义3个玩家。*/
        List<Card> linghuChong = new ArrayList<>();
        List<Card> renYingYing = new ArrayList<>();
        List<Card> dongFangBuBai = new ArrayList<>();
        // Collections.sort()

        /** 4.发牌：把洗后的牌依次发出51张出去，剩余三张作为底牌 */
        // cards = [♥3, ♠8, ♦8, ♠K, ♦7, ♥6, ♣6, ♣9, ♦4,....
        //    i     0    1   2   3   4   5   6  7   8   % 3
        for(int i = 0 ; i < cards.size() - 3 ; i++ ){
            Card c = cards.get(i);
            if(i % 3 == 0 ) {
                // 请令狐冲接牌
                linghuChong.add(c);
            }else if( i % 3 == 1){
                // 请盈盈接牌
                renYingYing.add(c);
            }else if(i % 3 == 2){
                // 请东方不败接牌
                dongFangBuBai.add(c);
            }
        }

        /**
            拓展：看牌之前对玩家的牌进行排序。

         */
        sortCards(linghuChong);
        sortCards(renYingYing);
        sortCards(dongFangBuBai);

        /** 5.看牌。*/
        System.out.println("冲冲："+linghuChong);
        System.out.println("盈盈："+renYingYing);
        System.out.println("东方："+dongFangBuBai);
        // System.out.println("底牌："+cards.get(53)+"->"+cards.get(52)+"->"+cards.get(51));

        // 拓展：截取最后三张底牌！
        List<Card> lastThreeCards = cards.subList(cards.size()-3 , cards.size());
        sortCards(lastThreeCards);
        System.out.println("底牌："+lastThreeCards);
    }

    public static void sortCards(List<Card> cards){
        /**
         List<Card> linghuChong = [♥K, ♥3, ♣5, ♦10, ♣10, ♣3,.....]
         Collections.sort(List集合,比较器对象)
         */
        Collections.sort(cards, new Comparator<Card>() {
            @Override
            public int compare(Card o1, Card o2) {
                // o1 👨
                // o2 ♥3
                // 需要程序员自定义比较的大小规则
                // 当前牌对象在新牌集合中的索引就是它的大小。
                return newCards.indexOf(o2) - newCards.indexOf(o1);
            }
        });
    }
}
public class Card {
    // 点数
    private String size;
    // 花色
    private String color;

    public Card() {

    }

    public Card(String size, String color) {
        this.size = size;
        this.color = color;
    }

    public String getSize() {
        return size;
    }

    public void setSize(String size) {
        this.size = size;
    }

    public String getColor() {
        return color;
    }

    public void setColor(String color) {
        this.color = color;
    }

    @Override
    public String toString() {
        return color+size;
    }
}
```
# 异常
## 什么是异常？
```markdown
异常是程序在"编译"或者"执行"的过程中可能出现的问题。
异常是应该尽量提前避免的。
异常可能也是无法做到绝对避免的，异常可能有太多情况了，开发中只能提前干预！！
异常一旦出现了，如果没有提前处理，程序就会退出JVM虚拟机而终止，开发中异常是需要提前处理的。

研究异常并且避免异常，然后提前处理异常，体现的是程序的健壮性！！！

Java会为常见的代码异常都设计一个类来代表。
```
## 异常的体系:
```markdown
         Java中异常继承的根类是：Throwable。

             Throwable(根类，不是异常类)
          /              \
        Error           Exception（异常，需要研究和处理）
                        /            \
                       编译时异常     RuntimeException(运行时异常)


        Error : 错误的意思，严重错误Error，无法通过处理的错误，一旦出现，程序员无能为力了，只能重启系统，优化项目。比如内存奔溃，JVM本身的奔溃。这个程序员无需理会。

        Exception:才是异常类，它才是开发中代码在编译或者执行的过程中可能出现的错误，它是需要提前处理的。以便程序更健壮！
```
## Exception异常的分类:
```markdown
1.编译时异常：
    继承自Exception的异常或者其子类，编译阶段就会报错，必须程序员处理的。否则代码编译就不能通过！！

2.运行时异常: 
    继承自RuntimeException的异常或者其子类，编译阶段是不会出错的，它是在运行时阶段可能出现，运行时异常可以处理也可以不处理，编译阶段是不会出错的，但是运行阶段可能出现，还是建议提前处理！！
小结：
    异常类：Exception。
    异常需要处理的，否则异常出现后，程序会死亡。
    异常分为2类：编译时异常，运行时异常。
    编译时异常编译阶段就直接报错，程序员必须处理。
    运行时异常编译阶段不报错，运行阶段才可能报错!!
```

```java
public class ExceptionDemo {
    public static void main(String[] args) {
        System.out.println("程序开始。。。。");
        int[] arrs = {10 , 20};
        System.out.println(arrs[2]);// 出现了运行时异常，编译阶段不报错
        System.out.println("程序结束。。。。");
    }
}
```
## 常见的运行时异常
```markdown
运行时异常的概念: 
继承自RuntimeException的异常或者其子类，编译阶段是不会出错的，它是在运行时阶段可能出现的错误，运行时异常编译阶段可以处理也可以不处理。

1.数组索引越界异常: ArrayIndexOutOfBoundsException
2.空指针异常 : NullPointerException 直接输出没有问题。但是调用空指针的变量的功能就会报错！！
3.类型转换异常：ClassCastException
4.迭代器遍历没有此元素异常：NoSuchElementException
5.数学操作异常：ArithmeticException
6.数字转换异常： NumberFormatException

小结：
    运行时异常都是继承了RuntimeException的，编译阶段一定不会报错，但是
    运行阶段可能出现。

    异常一旦出现，会从出现异常的点那里直接结束程序！
```

```java
public class ExceptionDemo {
    public static void main(String[] args) {
        System.out.println("程序开始。。。。。。");
        /** 1.数组越界异常:ArrayIndexOutOfBoundsException */
        int[] arrs = {10 ,20 ,30};
        System.out.println(arrs[0]);
        System.out.println(arrs[1]);
        System.out.println(arrs[2]);
       // System.out.println(arrs[3]);// 出现了该异常，程序在此死亡！

        /** 2.空指针异常 : NullPointerException */
        String name = "itheima";
        System.out.println(name.length()); // 7
        name = null ;
        System.out.println(name); // null
        // System.out.println(name.length());// 出现了该异常，程序在此死亡！


        /** 3.类型转换异常：ClassCastException */
        Object rs = "abc";
        // Integer it = (Integer) rs; // 出现了该异常，程序在此死亡！

        /** 4.迭代器遍历没有此元素异常：NoSuchElementException*/
        List<String> names = new ArrayList<>();
        Collections.addAll(names , "张无忌","赵敏");
        Iterator<String> it = names.iterator();
        System.out.println(it.next());
        System.out.println(it.next());
        // System.out.println(it.next()); // 出现了该异常，程序在此死亡！


        /** 5.数学操作异常：ArithmeticException */
       // int c = 10 / 0 ; //  // 出现了该异常，程序在此死亡！

        /** 6.数字转换异常： NumberFormatException*/
        String num = "anc";
       // Integer i = Integer.valueOf(num);

        System.out.println("程序结束。。。。。。");
    }
}
```
## 常见的编译时异常
```markdown
 编译时异常：
继承自Exception的异常或者其子类，没有继承RuntimeException编译时异常是编译阶段就会报错，必须程序员编译阶段就处理的。否则代码编译就报错！！
```
### 编译时异常的作用是什么
```markdown
是担心程序员的技术不行，在编译阶段就爆出一个错误，目的在于提醒!
提醒程序员这里很可能出错，请检查并注意不要出bug.
```

```markdown
小结：
    编译时异常继承自Exception，没有继承RuntimeException
    编译时异常是编译阶段就会报错的。一定需要处理，否则代码不通过。
    运行时异常是程序员的技术和考虑不周引起的。
    编译时异常不是程序员引起的，是别人担心你技术不行，在这里可能出错，是一个善意的提醒作用。
    编译时异常是可遇不可求，编译时异常遇到了就遇到了呗！
```

```java
public class ExceptionDemo {
    public static void main(String[] args) throws ParseException {
        String date = "2018-10-11 10:10:10";
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        Date d = sdf.parse(date);
        System.out.println(d);
    }
}
```
## 异常的产生默认的处理过程解析
```markdown
    （1）默认会在出现异常的代码那里自动的创建一个异常对象：ArithmeticException。
    （2）异常会从方法中出现的点这里抛出给调用者，调用者最终抛出给JVM虚拟机。
    （3）虚拟机接收到异常对象后，先在控制台直接输出异常栈信息数据。
    （4）直接干掉当前程序。
    （5）后续代码没有机会执行了，因为程序已经死亡。

    小结：
        异常一旦出现，会自动创建异常对象，最终抛出给虚拟机，虚拟机
        只要收到异常，就直接输出异常信息，干掉程序！！

        默认的异常处理机制不好，一旦出现异常，程序立即死亡！
```

```java
public class ExceptionDemo {
    public static void main(String[] args) {
        System.out.println("程序开始。。。。。。。。。。");
        chu(10,0);
        System.out.println("程序结束。。。。。。。。。。");
    }

    public static void chu(int a , int b){
        System.out.println(a);
        System.out.println(b);
        int c = a / b ;// 出现了运行时异常
        System.out.println("结果是："+c);
    }
}
```
## 异常\_编译时异常的处理机制
```markdown
    编译时异常：编译阶段就会报错，一定需要程序员处理的，否则代码无法通过！！

    抛出格式：
        方法 throws 异常1 ,  异常2 , ..{

        }

        建议格式：可以抛出所有异常！
        方法 throws Exception{

        }

    方式一：在出现异常的方法那里，层层把异常抛出给调用者，最终抛给JVM虚拟机。
        这种方式跟默认的方式是一样的，一旦真的出现异常，程序还是会死亡！
        这种方式不是很好！!
```

```java
public class ExceptionDemo01 {
    public static void main(String[] args) throws Exception {
        System.out.println("程序开始。。。");
        parse();
        System.out.println("程序结束。。。");
    }

    public static void parse() throws Exception {
        String date = "2018-10-11 10:10:10";
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        Date d = sdf.parse(date);
        System.out.println(d);

        InputStream is = new FileInputStream("D:/meidleiffnv.jpg");
    }


//    public static void main(String[] args) throws ParseException, FileNotFoundException {
//        System.out.println("程序开始。。。");
//        parse();
//        System.out.println("程序结束。。。");
//    }
//
//    public static void parse() throws ParseException , FileNotFoundException {
//        String date = "2018-10-11 10:10:10";
//        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
//        Date d = sdf.parse(date);
//        System.out.println(d);
//        InputStream is = new FileInputStream("D:/meinv.jpg");
//    }
}
```

```markdown
方式二：在出现异常的地方自己处理，谁出现谁处理。

    自己捕获异常和处理异常的格式：捕获处理
        try{
            // 监视可能出现异常的代码！
        }catch(异常类型1 变量){
            // 处理异常
        }catch(异常类型2 变量){
            // 处理异常
        }...

    捕获处理异常企业级写法：
         try{
             // 可能出现异常的代码！
         }catch (Exception e){
            e.printStackTrace(); // 直接打印异常栈信息
         }
         可以捕获处理一切异常类型！

    小结：
        方法二：在出现异常的地方自己捕获处理异常，这种方式确实不会引起程序的死亡！
        底层都自己解决问题，上层调用者不能直接知道底层执行的情况！从理论来看也不是最好的方案！
```

```java
public class ExceptionDemo02 {

    public static void main(String[] args) {
        System.out.println("程序开始。。。");
        parse();
        System.out.println("程序结束。。。");
    }

    public static void parse() {
        try{
            String date = "2018-10-11 10:10:10";
            SimpleDateFormat sdf = new SimpleDateFormat("yyyy/MM-dd HH:mm:ss");
            Date d = sdf.parse(date);
            System.out.println(d);

            InputStream is = new FileInputStream("D:/meinv.jpg");
        } catch (Exception e) {
            e.printStackTrace();// 打印异常信息！
        }
    }


//    public static void parse() {
//        try{
//            String date = "2018-10-11 10:10:10";
//            SimpleDateFormat sdf = new SimpleDateFormat("yyyy/MM-dd HH:mm:ss");
//            Date d = sdf.parse(date);
//            System.out.println(d);
//
//            InputStream is = new FileInputStream("D:/meinv.jpg");
//        } catch (FileNotFoundException | ParseException e) {
//            e.printStackTrace();// 打印异常信息！
//        }
//    }

//    public static void parse() {
//        try{
//            String date = "2018-10-11 10:10:10";
//            SimpleDateFormat sdf = new SimpleDateFormat("yyyy/MM-dd HH:mm:ss");
//            Date d = sdf.parse(date);
//            System.out.println(d);
//
//            InputStream is = new FileInputStream("D:/meinv.jpg");
//        } catch (FileNotFoundException e) {
//            e.printStackTrace();// 打印异常信息！
//        } catch (ParseException e) {
//            e.printStackTrace();
//        }
//    }

}
```

```markdown
方式三： 在出现异常的地方把异常一层一层的抛出给最外层调用者，
最外层调用集中捕获处理！！（规范做法）

小结：
    底层把异常抛给最外层调用者，最外层集中捕获处理异常
    这种方式最外层可以知道底层执行的情况，而且程序不会死亡，
    这是理论上最好的异常处理方案！
```

```java
public class ExceptionDemo03 {
    public static void main(String[] args) {
        System.out.println("程序开始。。。。");
        try {
            parse();
            System.out.println("功能成功完成了！");
        } catch (Exception e) {
            e.printStackTrace();
            System.out.println("功能操作失败了！！");
        }
        System.out.println("程序结束。。。。");
    }

    public static void parse() throws Exception {
        String date = "2018-10-11 10:10:10";
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        Date d = sdf.parse(date);
        System.out.println(d);
        // InputStream is = new FileInputStream("D:/meiddddnv.jpg");
    }

}
```
## 运行时异常的处理机制
```markdown
运行时异常在编译阶段是不会报错，在运行阶段才会出错。
运行时异常在编译阶段不处理也不会报错，但是运行时如果出错了程序还是会死亡
所以运行时异常也建议要处理。

运行时异常是自动往外抛出的，不需要我们手工抛出。

运行时异常的处理规范：直接在最外层捕获处理即可，底层会自动抛出！！

小结：
    运行时异常编译阶段是不会出错的，可以处理也可以不处理，建议还是处理。
    运行时异常底层是自动抛出的
    一般在最外层直接捕获处理即可，底层会自动抛出！！
```

```java
public class ExceptionDemo {
    public static void main(String[] args) {
        System.out.println("程序开始。。。。");
        try{
            chu();
            System.out.println("成功！");
        }catch (Exception e){
            e.printStackTrace();
            System.err.println("失败！");

        }
        System.out.println("程序结束。。。。");
    }

    public static void chu() {
        int c = 10 / 0 ;
        System.out.println(c);
    }
}
```
## finally关键字
```markdown
    用在捕获处理的异常格式中的，放在最后面。
        try{
            // 可能出现异常的代码！
        }catch(Exception e){
            e.printStackTrace();
        }finally{
            // 无论代码是出现异常还是正常执行，最终一定要执行这里的代码！！
        }

    finally的作用：可以在代码执行完毕以后进行资源的释放操作。
```

```java
public class FinnallyDemo {
    public static void main(String[] args) {
        chu();
    }

    public static void chu(){
        InputStream is = null;
        try{
            // int i1 = 10 / 0 ;
            is = new FileInputStream("D://ddddd.jpg");
            int i = 10 / 0 ;
            System.out.println(i);

        }catch (Exception e){
            e.printStackTrace();
        }finally {
            // 释放资源
            try{
                if(is!=null)is.close();
            }catch (Exception e){
                e.printStackTrace();
            }
            System.out.println("====finally====");
        }
    }
}
```
## 异常的语法注意
```markdown
 - 运行时异常被抛出可以不处理。可以自动抛出,编译时异常必须处理.按照规范都应该处理!
 - 重写方法申明抛出的异常，应该与父类被重写方法申明抛出的异常一样或者范围更小
 - 方法默认都可以自动抛出运行时异常！
 - 当多异常处理时，捕获处理，前边的异常类不能是后边异常类的父类。
 - 在try/catch后可以追加finally代码块，其中的代码一定会被执行，通常用于资源回收。
```

```java
public class ExceptionDemo {

}
class Fu{
    public void test() throws Exception {

    }
}

class Zi extends Fu{
    @Override
    public void test() {

    }

```
## 自定义异常
```markdown
引入:
    Java已经为开发中可能出现的异常都设计了一个类来代表.
    但是实际开发中,异常可能有无数种情况,Java无法为这个世界上所有的异常都定义一个代表类。
    假如一个企业如果想为自己认为的某种问题定义成一个异常就需要自己来自定义异常类.

    需求：认为年龄小于0岁，大于200岁就是一个异常。

    自定义异常:
        自定义编译时异常.
            a.定义一个异常类继承Exception.
            b.重写构造器。
            c.在出现异常的地方用throw new 自定义对象抛出!
            编译时编译阶段就报错，提醒更加强烈，一定需要处理！！

        自定义运行时异常.
            a.定义一个异常类继承RuntimeException.
            b.重写构造器。
            c.在出现异常的地方用throw new 自定义对象抛出!
            提醒不强烈，编译阶段不报错！！
```

```java
public class ExceptionDemo {
    public static void main(String[] args) {
        try {
            checkAge(300);
        } catch (Exception e) {
            e.printStackTrace();
            System.out.println("失败了！");
        }
    }

    public static void checkAge(int age) throws ItheimaAgeIlleagalException {
        if(age < 0 || age > 200){
            // 创建一个自定义异常对象并抛出
            // throws : 用在方法上抛出方法中的异常。
            // throw : 用在方法内，创建一个异常对象并从此点抛出！
            throw new ItheimaAgeIlleagalException("/ age is xiagao!");
        }else{
            System.out.println("年龄很合适！");
        }
    }
}
/**
 1.自定义编译时异常；必须继承Exception
 2.重写构造器
 */
public class ItheimaAgeIlleagalException extends Exception{
    public ItheimaAgeIlleagalException() {
    }

    public ItheimaAgeIlleagalException(String message) {
        super(message);
    }

    public ItheimaAgeIlleagalException(String message, Throwable cause) {
        super(message, cause);
    }

    public ItheimaAgeIlleagalException(Throwable cause) {
        super(cause);
    }

    public ItheimaAgeIlleagalException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {
        super(message, cause, enableSuppression, writableStackTrace);
    }
}
/**
 1.自定义运行时时异常；必须继承RuntimeException
 2.重写构造器
 */
public class ItheimaAgeIlleagalRuntimeException extends RuntimeException{
    public ItheimaAgeIlleagalRuntimeException() {
    }

    public ItheimaAgeIlleagalRuntimeException(String message) {
        super(message);
    }

    public ItheimaAgeIlleagalRuntimeException(String message, Throwable cause) {
        super(message, cause);
    }

    public ItheimaAgeIlleagalRuntimeException(Throwable cause) {
        super(cause);
    }

    public ItheimaAgeIlleagalRuntimeException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {
        super(message, cause, enableSuppression, writableStackTrace);
    }
}
```
## 异常的强大之处
```java
public class Demo {
    public static void main(String[] args) {
        while(true){
            try{
                System.out.println("请输入您的年龄：");
                int age = new Scanner(System.in).nextInt();
                System.out.println(age);
                break ;
            }catch (Exception e){
                System.err.println("请您不要瞎输入！！");
            }
        }
    }
}
```
# 多线程
## 什么是进程？
```markdown
程序是静止的，运行中的程序就是进程。
```
## 进程的三个特征：
```markdown
1.动态性 ： 进程是运行中的程序，要动态的占用内存，CPU和网络等资源。
2.独立性 ： 进程与进程之间是相关独立的，彼此有自己的独立内存区域。
3.并发性 ： 假如CPU是单核，同一个时刻其实内存中只有一个进程在被执行。
CPU会分时轮询切换依次为每个进程服务，因为切换的速度非常快，给我们的感觉这些进程在同时执行，这就是并发性。
```
## 并行:
```markdown
同一个时刻同时有多个在执行。
```
## 什么是线程？
```markdown
线程是属于进程的。一个进程可以包含多个线程，这就是多线程。
线程创建开销相对于进程来说比较小。
线程也支持并发性。
```
## 线程的作用：
```markdown
可以提高程序的效率，可以有更多机会得到CPU。
多线程可以解决很多业务模型。
大型高并发技术的核心技术。
设计到多线程的开发可能都比较难理解。
小结：
    多线程是并发抢占CPU执行的，执行会出现随机性。
```
## 多线程的创建
```markdown
多线程的创建有三种方式：
    （1）定义一个线程类继承Thread类，然后重写run()方法，再创建线程对象，调用
         start()方法启动线程

    （2）定义一个线程任务类实现Runnable接口，然后重写run()方法
        创建线程任务对象，把线程任务对象包装成线程对象，调用
        start()方法启动线程

    （3）定义一个线程任务类实现Callable接口（拓展）
方式一：创建多线程。
       a.定义一个线程类继承Thread类。
       b.重写Thread类的run()方法
       c.创建线程类的对象。
       d.调用线程类对象的start()方法启动线程

       优点：
           编码相对简单。
       缺点：
           线程类已经继承了Thread类，不能再继承其他类，
           线程类的功能受到了约束不能继承其其它类的功能。
           不能直接得到线程执行的结果。
注意事项：
      1,启动线程必须调用start()方法
       如果直接调用run()方法，会被直接当成主线程的方法调用执行，不会出现子线程！！
      2.一般需要把子线程先创建启动，再写主线程的任务。
```

```java
// 进程：ThreadDemo.class
public class ThreadDemo {
    // main方法本身就是代表了一个线程，称为主线程：main线程
    public static void main(String[] args) {
        //  c.创建线程类的对象。
        Thread t = new MyThread();
        //  d.调用线程类对象的start()方法启动线程，其实也是调用run()方法。
        t.start();

        for(int i = 0 ; i < 10 ; i++){
            System.out.println("主线程输出："+i);
        }
    }
}
// a.定义一个线程类继承Thread类。
// MyThread只是线程类不是线程对象，是用来创建线程对象的。
class MyThread extends Thread{
    // b.重写Thread类的run()方法
    @Override
    public void run() {
        // 线程的执行方法。
        for(int i = 0 ; i < 10 ; i++){
            System.out.println("子线程输出："+i);
        }
    }
}
```

```markdown
方式二:
        a.定义一个线程任务类实现Runnable接口。重写run()方法
        b.创建一个线程任务对象
        c.把线程任务对象包装成一个线程对象
            -- public Thread(Runnable target)
        d.调用线程对象的start()方法启动线程。

        优缺点：
         优点：线程任务对象只是实现了Runnable接口，可以继续继承其他类，也可以继续
             实现其他接口，本身功能可以增强。
             适合做多线程资源共享操作。
             适合做线程池。
         缺点：
             编码相对复杂。
             不能直接得到线程执行的结果。
```

```java
public class ThreadDemo {
    public static void main(String[] args) {
        // b.创建一个线程任务对象。
        Runnable target = new MyRunnable();
        // c.把线程任务对象包装成一个线程对象：public Thread(Runnable target)
        Thread t = new Thread(target);
        // d.调用线程对象的start()方法启动线程
        t.start();

        Thread t1 = new Thread(target);
        t1.start();

        for(int i = 0 ; i < 10 ; i ++ ) {
            System.out.println(Thread.currentThread().getName()+"=>"+i);
        }
    }
}
// a.定义线程任务类实现Runable接口
class MyRunnable implements Runnable{
    // 重写run()方法
    @Override
    public void run() {
        for(int i = 0 ; i < 10 ; i++ ){
            System.out.println(Thread.currentThread().getName()+" => "+i);
        }
    }
}
//匿名内部类写法
public class ThreadDemo02 {
    public static void main(String[] args) {
        // b.创建一个线程任务对象。
        Runnable target = new Runnable() {
            @Override
            public void run() {
                for(int i = 0 ; i < 10 ; i++ ){
                    System.out.println(Thread.currentThread().getName()+" => "+i);
                }
            }
        };
        // c.把线程任务对象包装成一个线程对象：public Thread(Runnable target)
        Thread t = new Thread(target);
        // d.调用线程对象的start()方法启动线程
        t.start();


        // c.把线程任务对象包装成一个线程对象：public Thread(Runnable target)
        new Thread(new Runnable() {
            @Override
            public void run() {
                for(int i = 0 ; i < 10 ; i++ ){
                    System.out.println(Thread.currentThread().getName()+" => "+i);
                }
            }
        }).start();



        for(int i = 0 ; i < 10 ; i ++ ) {
            System.out.println(Thread.currentThread().getName()+"=>"+i);
        }
    }
}
```

```markdown
方式三的优缺点：
        缺点：
            编码复杂。
        优点：
             线程任务对象只是实现了Callable接口，可以继续继承其他类，也可以继续
             实现其他接口，本身功能可以增强。
             适合做多线程资源共享操作。
             适合做线程池。
             可以直接得到线程执行的结果。
```

```java
public class ThreadDemo {
    public static void main(String[] args) {
        // c.创建一个Callable的线程任务对象
        Callable call = new MyCallable();
        // d.把Callable线程任务对象包装成一个未来任务对象
        // --  public FutureTask(Callable<V> callable)
        // 未来任务对象的作用：
        //    1.可以包装Callable任务对象，未来任务对象本身是一个Runnable的类型的对象。
        //    2.未来任务对象可以在线程执行完毕以后获取线程执行的结果。
        FutureTask<String> target = new FutureTask<>(call);
        // e.把未来任务对象（Runnable对象）包装成一个线程对象。
        Thread t = new Thread(target);
        // f.启动线程
        t.start();

        for(int i  = 1 ; i <= 5 ; i++ ) {
            System.out.println(Thread.currentThread().getName()+" => " + i);
        }

        try {
            // 得到线程执行的结果
            String rs = target.get();
            System.out.println(rs);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

// a.定义一个线程任务类实现Callable接口。
class MyCallable implements Callable<String>{
    // b.重写线程任务对象的call方法。
    @Override
    public String call() throws Exception {
        int sum = 0 ;
        for(int i  = 1 ; i <= 5 ; i++ ) {
            sum += i;
            System.out.println(Thread.currentThread().getName()+" => " + i);
        }
        return Thread.currentThread().getName()+"求和的结果是："+sum;
    }
}
```
## 线程的常用API
```java
/**
 * 线程默认是有名称的，主线程的名称是main
 * 子线程的名称：Thread_索引。
 */
//Thread类：
public String getName():可以直接获取线程的名称。
public void setName(String name):给当前线程取名字。
public static Thread currentThread():返回当前所在线程对象。
```

```java
public class ThreadDemo {
    // main方法本身就是代表了一个线程，称为主线程：main线程
    public static void main(String[] args) {
        //  c.创建线程类的对象。
        Thread t = new MyThread();
        //  d.调用线程类对象的start()方法启动线程，其实也是调用run()方法。
        t.setName("1号线程");
        t.start();
        //System.out.println(t.getName());

        Thread t1 = new MyThread();
        t1.setName("2号线程");
        t1.start();
        //System.out.println(t1.getName());

        // 这行代码是由哪个线程对象执行的，就会得到哪个线程对象。
        Thread m = Thread.currentThread();
        //System.out.println(m.getName());
        m.setName("最牛逼的线程");

        for(int i = 0 ; i < 10 ; i++){
            System.out.println(Thread.currentThread().getName()+" --->"+i);
        }
    }
}
// a.定义一个线程类继承Thread类。
// MyThread只是线程类不是线程对象，是用来创建线程对象的。
class MyThread extends Thread{
    // b.重写Thread类的run()方法
    @Override
    public void run() {
        // 线程的执行方法。
        for(int i = 0 ; i < 10 ; i++){
            System.out.println(Thread.currentThread().getName()+" ---> "+i);
        }
    }
}
Thread类提供了取线程名称的有参数构造器：
        public Thread(String name):
小结：
    子线程通过super调用Thread的有参数构造器为自己的线程对象取名字。
```

```java
public class ThreadDemo02 {
    // main方法本身就是代表了一个线程，称为主线程：main线程
    public static void main(String[] args) {
        Thread t = new MyThread02("1号线程");
        t.start();

        Thread t1 = new MyThread02("2号线程");
        t1.start();

        // 这行代码是由哪个线程对象执行的，就会得到哪个线程对象。
        Thread m = Thread.currentThread();
        m.setName("最牛逼的线程");

        for(int i = 0 ; i < 10 ; i++){
            System.out.println(Thread.currentThread().getName()+" --->"+i);
        }
    }
}

// a.定义一个线程类继承Thread类。
// MyThread只是线程类不是线程对象，是用来创建线程对象的。
class MyThread02 extends Thread{

    public MyThread02(String name){
        super(name);
    }

    // b.重写Thread类的run()方法
    @Override
    public void run() {
        // 线程的执行方法。
        for(int i = 0 ; i < 10 ; i++){
            System.out.println(Thread.currentThread().getName()+" ---> "+i);
        }
    }
}
```
# 线程安全
```markdown
线程安全问题：
    多个线程同时操作同一个共享资源的时候可能出现线程安全问题。

    需求：模拟取款业务的线程安全问题。

    共享资源：账户。
    多个线程：小明/小红。
    功能：取款10000元。

小结：
    线程安全问题出现的原因是：多个线程同时操作同一个共享资源的时候可能出现线程安全问题。
```

```java
public class ThreadSafeDemo {
    public static void main(String[] args) {
        // 入口类：
        // 1.创建一个共享的账户对象（共享资源），账户对象必须只创建一个。
        Account acc = new Account(10000, "ICBC-110");

        // 2.创建2个线程对象代表：小明和小红。
        Thread xiaoMing = new DrawThread(acc,"小明");
        xiaoMing.start();

        Thread xiaoRed = new DrawThread(acc,"小红");
        xiaoRed.start();
    }
}
/**
 取钱的线程类
 */
public class DrawThread extends Thread {
    private Account acc ; // 定义了一个账户类型的成员变量接收取款的账户对象！
    public DrawThread(Account acc , String name){
        super(name); // 为当前线程对象取名字
        this.acc = acc ;
    }
    @Override
    public void run() {
        // 小明/小红
        acc.drawMoney(10000);
    }
}
// 账户类
public class Account {
    private double money ; // 余额
    private String cardId ;
    public Account(){

    }
    public Account(double money, String cardId) {
        this.money = money;
        this.cardId = cardId;
    }
    // 小明、小红执行到此
    public void drawMoney(double money) {
        // 1.先拿到是谁来取钱：取当前线程对象的名称
        String name = Thread.currentThread().getName();
        // 2.判断余额是否足够
        if(this.money >= money){
            // 3.余额足够
            System.out.println(name+"来取钱，吐出："+money);
            // 4.更新余额
            this.money -= money;
            // 5.输出结果
            System.out.println(name+"来取钱"+money+"成功，取钱后剩余："+this.money);
        }else{
            // 6.余额不足
            System.out.println(name+"来取钱，余额不足，剩余"+this.money);
        }
    }

    public double getMoney() {
        return money;
    }

    public void setMoney(double money) {
        this.money = money;
    }

    public String getCardId() {
        return cardId;
    }

    public void setCardId(String cardId) {
        this.cardId = cardId;
    }


}
```
## 线程同步\_同步代码块
### 线程同步的作用：
```markdown
就是为了解决线程安全问题的方案。
```
### 线程同步解决线程安全问题的核心思想：
```markdown
让多个线程实现先后依次访问共享资源，这样就解决了安全问题。
```
### 线程同步的做法：
```markdown
是把共享资源进行上锁，每次只能一个线程进入访问完毕以后，其他线程才能进来。
```
### 线程同步的方式有三种：
```markdown
（1）同步代码块。
（2）同步方法。
（3）lock显示锁。
a.同步代码块。
     作用：把出现线程安全问题的核心代码给上锁，每次只能一个线程进入
          执行完毕以后，其他线程才可以进来执行。
     格式：
          synchronized(锁对象){
                // 访问共享资源的核心代码
          }
          锁对象：理论上可以是任意的“唯一”对象即可。
          原则上：锁对象建议使用共享资源。
                -- 在实例方法中建议用this作为锁对象。
                -- 在静态方法中建议用类名.class字节码作为锁对象。
```

```java
public class ThreadSafe {
    public static void main(String[] args) {
        // 入口类：
        // 1.创建一个共享的账户对象（共享资源），账户对象必须只创建一个。
        Account acc = new Account(10000, "ICBC-110");

        // 2.创建2个线程对象代表：小明和小红。
        Thread xiaoMing = new DrawThread(acc,"小明");
        xiaoMing.start();

        Thread xiaoRed = new DrawThread(acc,"小红");
        xiaoRed.start();
    }
}
/**
 取钱的线程类
 */
public class DrawThread extends Thread {
    private Account acc ; // 定义了一个账户类型的成员变量接收取款的账户对象！
    public DrawThread(Account acc , String name){
        super(name); // 为当前线程对象取名字
        this.acc = acc ;
    }
    @Override
    public void run() {
        // 小明/小红
        acc.drawMoney(10000);
    }
}
// 账户类
public class Account {
    private double money ; // 余额
    private String cardId ;
    public Account(){

    }
    public Account(double money, String cardId) {
        this.money = money;
        this.cardId = cardId;
    }
    // 小明、小红执行到此
    public void drawMoney(double money) {
        // 1.先拿到是谁来取钱：取当前线程对象的名称
        String name = Thread.currentThread().getName();
        synchronized (this){
            // 2.判断余额是否足够
            if(this.money >= money){
                // 3.余额足够
                System.out.println(name+"来取钱，吐出："+money);
                // 4.更新余额
                this.money -= money;
                // 5.输出结果
                System.out.println(name+"来取钱"+money+"成功，取钱后剩余："+this.money);
            }else{
                // 6.余额不足
                System.out.println(name+"来取钱，余额不足，剩余"+this.money);
            }
        }
    }

    public double getMoney() {
        return money;
    }

    public void setMoney(double money) {
        this.money = money;
    }

    public String getCardId() {
        return cardId;
    }

    public void setCardId(String cardId) {
        this.cardId = cardId;
    }


}
```

```markdown
b.同步方法
        作用：把出现线程安全问题的核心方法给锁起来，
             每次只能一个线程进入访问，其他线程必须在外面等待。
        用法：直接给方法加上一个修饰符 synchronized.
        原理:  同步方法的原理和同步代码块的底层原理其实是完全一样的，只是
              同步方法是把整个方法的代码都锁起来的。
              同步方法其实底层也是有锁对象的：
                  如果方法是实例方法：同步方法默认用this作为的锁对象。
                  如果方法是静态方法：同步方法默认用类名.class作为的锁对象。

```

```java
public class ThreadSafe {
    public static void main(String[] args) {
        // a.创建一个账户对象。
        Account acc = new Account(10000,"ICBC-110" );
        // b.定义一个线程类创建2个线程代表小明和小红
        Thread xiaoMing = new DrawThread(acc , "小明");
        xiaoMing.start();

        Thread xiaoRed = new DrawThread(acc, "小红");
        xiaoRed.start();
    }
}
// 账户类
public class Account {
    private double money ; // 余额
    private String cardId ;
    public Account(){

    }
    public Account(double money, String cardId) {
        this.money = money;
        this.cardId = cardId;
    }
    // 小明、小红执行到此
    public synchronized void drawMoney(double money) {
        // 1.先拿到是谁来取钱：取当前线程对象的名称
        String name = Thread.currentThread().getName();
        // 2.判断余额是否足够
        if(this.money >= money){
            // 3.余额足够
            System.out.println(name+"来取钱，吐出："+money);
            // 4.更新余额
            this.money -= money;
            // 5.输出结果
            System.out.println(name+"来取钱"+money+"成功，取钱后剩余："+this.money);
        }else{
            // 6.余额不足
            System.out.println(name+"来取钱，余额不足，剩余"+this.money);
        }
    }

    public double getMoney() {
        return money;
    }

    public void setMoney(double money) {
        this.money = money;
    }

    public String getCardId() {
        return cardId;
    }

    public void setCardId(String cardId) {
        this.cardId = cardId;
    }


}
/**
 取钱的线程类
 */
public class DrawThread extends Thread {
    private Account acc ; // 定义了一个账户类型的成员变量接收取款的账户对象！
    public DrawThread(Account acc , String name){
        super(name); // 为当前线程对象取名字
        this.acc = acc ;
    }
    @Override
    public void run() {
        // 小明/小红
        acc.drawMoney(10000);
    }
}
```

```markdown
c.lock显示锁。
        java.util.concurrent.locks.Lock机制提供了比synchronized代码块和synchronized方法更广泛的锁定操作,
        同步代码块/同步方法具有的功能Lock都有,除此之外更强大

       Lock锁也称同步锁，加锁与释放锁方法化了，如下：
             - `public void lock() `:加同步锁。
             - `public void unlock()`:释放同步锁。

   总结：
        线程安全性能差。
        线程不安全性能好。假如开发中不会存在多线程安全问题，建议使用线程不安全的设计。
 */
```

```java
public class ThreadSafe {
    public static void main(String[] args) {
        // a.创建一个账户对象。
        Account acc = new Account(10000,"ICBC-110"  );
        // b.定义一个线程类创建2个线程代表小明和小红
        Thread xiaoMing = new DrawThread(acc , "小明");
        xiaoMing.start();

        Thread xiaoRed = new DrawThread(acc, "小红");
        xiaoRed.start();
    }
}
/**
 取钱的线程类
 */
public class DrawThread extends Thread {
    private Account acc ; // 定义了一个账户类型的成员变量接收取款的账户对象！
    public DrawThread(Account acc , String name){
        super(name); // 为当前线程对象取名字
        this.acc = acc ;
    }
    @Override
    public void run() {
        // 小明/小红
        acc.drawMoney(10000);
    }
}
// 账户类
public class Account {
    private double money ; // 余额
    private String cardId ;
    // 创建一把锁对象
    private final Lock lock = new ReentrantLock();
    public Account(){

    }
    public Account(double money, String cardId) {
        this.money = money;
        this.cardId = cardId;
    }
    // 小明、小红执行到此
    public void drawMoney(double money) {
        // 1.先拿到是谁来取钱：取当前线程对象的名称
        String name = Thread.currentThread().getName();
        // 2.判断余额是否足够
        lock.lock();
        try{
            if(this.money >= money){
                // 3.余额足够
                System.out.println(name+"来取钱，吐出："+money);
                // 4.更新余额
                this.money -= money;
                // 5.输出结果
                System.out.println(name+"来取钱"+money+"成功，取钱后剩余："+this.money);
            }else{
                // 6.余额不足
                System.out.println(name+"来取钱，余额不足，剩余"+this.money);
            }
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            lock.unlock(); // 释放锁！
        }
    }

    public double getMoney() {
        return money;
    }

    public void setMoney(double money) {
        this.money = money;
    }

    public String getCardId() {
        return cardId;
    }

    public void setCardId(String cardId) {
        this.cardId = cardId;
    }


}

```
## 线程控制
```java
//线程休眠Thread.sleep：让当前线程暂停一段时间再继续执行。
public class ThreadControlDemo01 {
    public static void main(String[] args) {
        for(int i = 0 ; i < 10 ; i++ ){
            System.out.println("输出："+i);
            try {
                // 项目经理让我加上这行代码，如果用户交钱了就注释掉。
                Thread.sleep(3000);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
}
/**
 目标：线程礼让。
 */
public class ThreadControlDemo02 {
    public static void main(String[] args) {
        new MyThread().start();

        for(int i = 0 ; i < 100 ; i++ ){
            System.out.println(Thread.currentThread().getName()+" => " + i);
            if(i == 3){
                Thread.yield();// 线程让步，当前线程让出CPU。
            }
        }
    }
}

class MyThread extends Thread{
    @Override
    public void run() {
        for(int i = 0 ; i < 100 ; i++ ){
            System.out.println(Thread.currentThread().getName()+" => " + i);
        }
    }
}
/**
 目标：join线程。

 当前线程让某个线程插入进来执行。
 */
public class ThreadControlDemo03 {
    public static void main(String[] args) {
        Thread t = new MyThread01();
        t.start();

        Thread t1 = new MyThread01();
        t1.start();

        for(int i = 0 ; i < 100 ; i++ ){
            System.out.println(Thread.currentThread().getName()+" => " + i);
            if(i == 3){
                try {
                    t.join(); // 主线程执行到3的时候，让t线程来跑，但是可能之后被别人抢走
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}

class MyThread01 extends Thread{
    @Override
    public void run() {
        for(int i = 0 ; i < 100 ; i++ ){
            System.out.println(Thread.currentThread().getName()+" => " + i);
        }
    }
}
/**
 目标：线程优先级

 可以为某个线程设计优先级，优先级高的线程有更多的机会得到CPU。
 -- public final int getPriority() : 获取优先级。
 -- public final void setPriority(int newPriority):设置优先级
 线程有三个优先级别：
 1   MIN_PRIORITY
 5   NORM_PRIORITY (默认)
 10  MAX_PRIORITY


 */
public class ThreadControlDemo04 {
    public static void main(String[] args) {
        Thread t = new MyThread02();
        //System.out.println(t.getPriority());
        t.setPriority(Thread.MAX_PRIORITY);
        t.start();

        Thread t1 = new MyThread02();
        //System.out.println(t1.getPriority());
        //t1.setPriority(Thread.NORM_PRIORITY); // 默认
        t1.start();


        System.out.println(Thread.currentThread().getPriority());
        Thread.currentThread().setPriority(Thread.MIN_PRIORITY);

        for(int i = 0 ; i < 100 ; i++ ){
            System.out.println(Thread.currentThread().getName()+" => " + i);
        }
    }
}

class MyThread02 extends Thread{
    @Override
    public void run() {
        for(int i = 0 ; i < 100 ; i++ ){
            System.out.println(Thread.currentThread().getName()+" => " + i);
        }
    }
}
```
## 死锁
```markdown
死锁是这样一种情形：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。
            由于线程被无限期地阻塞，因此程序不可能正常终止。

            客户（占用资金，等待经销商的货品资源）   经销商（占用货品资源，等待客户的资金）

     java 死锁产生的四个必要条件：
         1、互斥使用，即当资源被一个线程使用(占有)时，别的线程不能使用。（资源同时只能一个人使用）
         2、不可抢占，资源请求者不能强制从资源占有者手中夺取资源，资源只能由资源占有者主动释放。
         3、请求和保持，即当资源请求者在请求其他的资源的同时保持对原有资源的占有。
         4、循环等待，即存在一个等待循环队列：p1要p2的资源，p2要p1的资源。这样就形成了一个等待环路

         当上述四个条件都成立的时候，便形成死锁。当然，死锁的情况下如果打破上述任何一个条件，
         便可让死锁消失

     代码实现。

     小结：
         开发中要尽量避免死锁。
         Java实现死锁代码形式上一般要出现synchronized的嵌套。

```

```java
public class ThreadDead {
    // 定义2个资源:每个资源只需要一个
    public static Object resources01 = new Object();
    public static Object resources02 = new Object();

    public static void main(String[] args) {
        // 定义两个线程。
        new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (resources01){
                    System.out.println("线程1占用资源1，开始请求资源2");
                    try {
                        Thread.sleep(1000);
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                    synchronized (resources02){
                        System.out.println("线程1占用资源2");
                    }
                }
            }
        }).start();


        new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (resources02){
                    System.out.println("线程2占用资源2，开始请求资源1");
                    try {
                        Thread.sleep(1000);
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                    synchronized (resources01){
                        System.out.println("线程2占用资源1");
                    }
                }
            }
        }).start();
    }
}
```
# 线程通信
```markdown
线程通信：多个线程因为在同一个进程中，所以互相通信比较容易的。

    线程通信的经典模型：生产者与消费者问题。
         生产者负责生成商品，消费者负责消费商品。
         生产不能过剩，消费不能没有。

         厂家   口红   消费者。

    模拟一个案例：
        小明和小红有一个共同账户：共享资源
        他们有3个爸爸（亲爸，岳父，干爹）给他们存钱。

        模型：小明和小红去取钱，如果有钱就取出，然后等待自己，唤醒他们3个爸爸们来存钱
             他们的爸爸们来存钱，如果发现有钱就不存，没钱就存钱，然后等待自己，唤醒孩子们来取钱。
             做整存整取：10000元。
    分析：
        生产者线程：亲爸，岳父，干爹
        消费者线程：小明，小红
        共享资源：账户对象。

    注意：线程通信一定是多个线程在操作同一个资源才需要进行通信。
         线程通信必须先保证线程安全，否则毫无意义，代码也会报错！

    线程通信的核心方法：
        public void wait(): 让当前线程进入到等待状态 此方法必须锁对象调用.
        public void notify() : 唤醒当前锁对象上等待状态的某个线程  此方法必须锁对象调用
        public void notifyAll() : 唤醒当前锁对象上等待状态的全部线程  此方法必须锁对象调用
```

```java
public class ThreadCommunication {
    public static void main(String[] args) {
        // 1.创建1个账户对象。
        Account acc = new Account(0 , "ICBC-111");

        // 2.创建消费者线程：小明/小红  取钱
        new DrawThread(acc,"小明").start();
        new DrawThread(acc,"小红").start();

        // 3.创建生产者线程：亲爸,岳父,干爹
        new SaveThread(acc,"亲爸").start();
        new SaveThread(acc,"岳父").start();
        new SaveThread(acc,"干爹").start();
    }
}
// 存钱的线程类。
public class SaveThread extends Thread {
    private Account acc ;
    public SaveThread(Account acc , String name){
        super(name);
        this.acc = acc;
    }
    @Override
    public void run() {
        // 亲爸，干爹，岳父
        while(true){
            acc.saveMoney(10000);
        }
    }
}
// 取钱的线程类。
public class DrawThread extends Thread {
    private Account acc ;
    public DrawThread(Account acc , String name){
        super(name);
        this.acc = acc;
    }
    @Override
    public void run() {
        while(true){
            // 小明 小红
            acc.drawMoney(10000);
        }
    }
}
// 账户类
public class Account {
    private double money ; // 余额
    private String cardId ;
    // 创建一把锁对象
    private final Lock lock = new ReentrantLock();
    public Account(){

    }
    public Account(double money, String cardId) {
        this.money = money;
        this.cardId = cardId;
    }
    // 亲爸，干爹，岳父
    public synchronized void saveMoney(double money) {
        try{
            String name = Thread.currentThread().getName();
            if(this.money > 0){
                // 有钱，不需要存钱
                this.notifyAll(); // 唤醒别人
                this.wait();// 等待自己，释放锁！
            }else{
                // 没钱
                this.money += money;
                System.out.println(name+"来存钱，存钱后剩余："+this.money);
                this.notifyAll(); // 唤醒别人
                this.wait();// 等待自己，释放锁！
            }
        }catch (Exception e){
            e.printStackTrace();
        }
    }

    // 小明，小红
    public synchronized void drawMoney(double money) {
        try{
            String name = Thread.currentThread().getName();
            if(this.money >= money){
                // 余额足够
                this.money -= money;
                System.out.println(name+"来取钱"+money+"成功!剩余:"+ this.money);
                // 取完钱后，等待自己，唤醒别人
                this.notifyAll(); // 唤醒别人
                this.wait();// 等待自己，释放锁！
            }else{
                // 余额不足。
                this.notifyAll(); // 唤醒别人
                this.wait();// 等待自己，释放锁！
            }
        }catch (Exception e){
            e.printStackTrace();
        }
    }

    public double getMoney() {
        return money;
    }

    public void setMoney(double money) {
        this.money = money;
    }

    public String getCardId() {
        return cardId;
    }

    public void setCardId(String cardId) {
        this.cardId = cardId;
    }

```
# 线程池
```markdown
     线程池:其实就是一个容纳多个线程的容器,其中的线程可以反复的使用，省去了频繁创建和销毁线程对象的操作,无需反复创建线程而消耗过多资源。

     为什么要用线程池：
       合理利用线程池能够带来三个好处
       1.降低资源消耗。
            -- 减少了创建和销毁线程的次数，每个工作线程都
               可以被重复利用，可执行多个任务。

       2.提高响应速度
            -- 不需要频繁的创建线程，如果有
               线程可以直接用，不会出现系统僵死！

       3.提高线程的可管理性（线程池可以约束系统最多只能有多少个线程，
            不会因为线程过多而死机）

     线程池的核心思想：线程复用，同一个线程可以被重复使用，来处理多个任务。
```

```markdown
线程池在Java中的代表类：ExecutorService(接口)。

    Java在Executors类下提供了一个静态方法得到一个线程池的对象：
         1.public static ExecutorService newFixedThreadPool(int nThreads)：
            创建一个线程池返回。

    ExecutorService提交线程任务对象执行的方法：
         1.Future<?> submit(Runnable task):提交一个Runnable的任务对象给线程池执行。
```

```java
public class ThreadPoolDemo02 {
    public static void main(String[] args) {
        // 1.创建一个线程池
        ExecutorService pools = Executors.newFixedThreadPool(3);
        // 2.提交线程执行任务。
        Runnable target = new MyRunnbale();
        pools.submit(target); // 提交任务给线程池，线程池会自动创建一个线程并启动
        pools.submit(target); // 提交任务给线程池，线程池会自动创建一个线程并启动
        pools.submit(target); // 提交任务给线程池，线程池会自动创建一个线程并启动
        pools.submit(target); // 提交任务给线程池，这里不会创建线程了，会复用之前的某个线程执行此任务。
        pools.submit(target); // 提交任务给线程池，这里不会创建线程了，会复用之前的某个线程执行此任务。

        // pools.shutdown(); // 会等线程的全部任务执行完毕以后再关闭线程池。
        pools.shutdownNow(); // 立即关闭线程池，不管线程池是否执行完毕！
    }
}
// 线程任务对象
class MyRunnbale implements Runnable{
    @Override
    public void run() {
        for(int i = 1 ; i <= 5 ; i++ ){
            System.out.println(Thread.currentThread().getName()+" => "+i);
        }
    }
}
```

```markdown
    线程池在Java中的代表类：ExecutorService(接口)。

    Java在Executors类下提供了一个静态方法得到一个线程池的对象：
         1.public static ExecutorService newFixedThreadPool(int nThreads)：
            创建一个线程池返回。
 
    ExecutorService提交线程任务对象执行的方法：
         1.Future<?> submit(Runnable task):提交一个Runnable的任务对象给线程池执行。
         2.<T> Future<T> submit(Callable<T> task): 提交一个Callable的任务对象给线程池执行。

    需求：要求用线程池计算出 1-100 ， 1-200 的和返回。

    小结：
         Callable的任务是可以得到执行的结果。
         以后创建线程对象建议使用线程池。
```

```java
public class ThreadPoolDemo03 {
    public static void main(String[] args) throws Exception {
        // 1.创建一个线程池：容量是3
        ExecutorService pools = Executors.newFixedThreadPool(3);
        // 2.提交线程执行任务。
        Future<String> f1 =  pools.submit(new MyCallable(100)); // 创建线程，且自动执行
        Future<String> f2 =  pools.submit(new MyCallable(200)); // 创建线程，且自动执行
        Future<String> f3 =  pools.submit(new MyCallable(300)); // 创建线程，且自动执行
        Future<String> f4 =  pools.submit(new MyCallable(400)); // 不会创建线程，复用之前的线程

        String rs1 = f1.get();  // 获取线程执行的结果。
        System.out.println(rs1);

        String rs2 = f2.get();
        System.out.println(rs2);

        String rs3 = f3.get();
        System.out.println(rs3);

        String rs4 = f4.get();
        System.out.println(rs4);

        // pools.shutdown(); // 会等线程的全部任务执行完毕以后再关闭线程池。
        pools.shutdownNow(); // 立即关闭线程池，不管线程池是否执行完毕！
    }
}

class MyCallable implements Callable<String>{
    private int n;
    public MyCallable(int n){
        this.n = n;
    }
    @Override
    public String call() throws Exception {
        int sum = 0 ;
        for(int i = 1 ; i <= n ; i++ ){
            sum+=i;
        }
        return Thread.currentThread().getName()+"计算1-"+n+"的和是："+sum;
    }
}
```

# Lambda表达式
```markdown
     什么是Lambda表达式？
         Lambda表达式是JDK1.8开始之后的新技术，是一种代码的新语法。
         是一种特殊写法，
         作用：“核心目的是为了简化匿名内部类的代码写法”。

     Lambda表达式的格式:
        (匿名内部类被重写方法的形参列表) -> {
           被重写方法的方法体代码。
        }

        -> 就是一个新语法，没有实际含义，但是不能省略！

    Lambda表达式的使用前提：
         （1）Lambda表达式并不能简化所有匿名内部类的写法。
         （2）Lambda表达式只能简化接口中只有一个抽象方法的匿名内部类形式。

    Lambda表达式只能简化函数式接口的匿名内部类写法：
         a.首先必须是接口。
         b.接口中只能有一个抽象方法。

    小结：
         Lambda表达式只能简化函数式接口的匿名内部类的形式!!
```

```java
public class LambdaDemo01 {
    public static void main(String[] args) {
        Thread t = new Thread(){
            @Override
            public void run() {
                System.out.println(Thread.currentThread().getName());
            }
        };

//        Thread t1 = () -> {
//            System.out.println(Thread.currentThread().getName());
//        };


    }
}
```
## Lambda表达式简化Runnable接口的匿名内部类写法
```java
/**
@FunctionalInterface函数式接口的注解：
            注释的接口有且仅能有一个抽象方法。
            这个注解是可以使用Lambda简化的标志。
 */
public class LambdaDemo {
    public static void main(String[] args) {
        Runnable target = new Runnable() {
            @Override
            public void run() {
                System.out.println(Thread.currentThread().getName());
            }
        };
        Thread t = new Thread(target);
        t.start();

        Runnable target1 = () -> {
            System.out.println(Thread.currentThread().getName());
        };
        Thread t1 = new Thread(target1);
        t1.start();


        new Thread(() -> {
            System.out.println(Thread.currentThread().getName());
        }).start();


        new Thread(() ->System.out.println(Thread.currentThread().getName())  ).start();



    }
}
```
## Lambda简化Comparator接口匿名内部类写法
```java
public class CollectionsDemo02 {
    public static void main(String[] args) {
        List<Student> lists = new ArrayList<>();
        Student s1 = new Student("李铭",18,'男');
        Student s2 = new Student("冯龙",23,'男');
        Student s3 = new Student("王乐乐",21,'男');
        Collections.addAll(lists , s1 , s2 , s3);

        /**
            参数一：被排序集合
            参数二：匿名的比较器对象。
                  比较器对象会自动提取集合的两两对象让程序员来定制规则排序！！
         */
        Collections.sort(lists, new Comparator<Student>() {
            @Override
            public int compare(Student o1, Student o2) {
                return o1.getAge() - o2.getAge();
            }
        });

        Collections.sort(lists, (Student o1, Student o2) -> {
                return o1.getAge() - o2.getAge();
        });

        Collections.sort(lists, (Student o1, Student o2) -> o1.getAge() - o2.getAge());

        Collections.sort(lists, ( o1,  o2) -> o1.getAge() - o2.getAge());



        System.out.println(lists);
    }
}
public class Student {
    private String name ;
    private int age ;
    private char sex ;

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Student student = (Student) o;
        return age == student.age &&
                sex == student.sex &&
                Objects.equals(name, student.name);
    }

    @Override
    public int hashCode() {
        // 只要内容一样，结果地址也一定是一样的！
        return Objects.hash(name, age, sex);
    }

    public Student() {
    }

    public Student(String name, int age, char sex) {
        this.name = name;
        this.age = age;
        this.sex = sex;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public char getSex() {
        return sex;
    }

    public void setSex(char sex) {
        this.sex = sex;
    }

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", sex=" + sex +
                '}';
    }
}
```
## Lambda表达式的省略写法
```java
/**（1）如果Lambda表达式的方法体代码只有一行代码。可以省略大括号不写,同时要省略分号！
 （2）如果Lambda表达式的方法体代码只有一行代码。可以省略大括号不写。
 此时，如果这行代码是return语句，必须省略return不写，同时也必须省略";"不写
 （3）参数类型可以省略不写。
 （4）如果只有一个参数，参数类型可以省略，同时()也可以省略。
 */
public class LambdaDemo01 {
    public static void main(String[] args) {
        List<String> lists = new ArrayList<>();
        lists.add("java1");
        lists.add("java2");
        lists.add("java3");

        lists.forEach(new Consumer<String>() {
            @Override
            public void accept(String s) {
                System.out.println(s);
            }
        });

        lists.forEach((String s) -> {
            System.out.println(s);
        });

        lists.forEach( (s) -> {
            System.out.println(s);
        });

        lists.forEach(s -> {
            System.out.println(s);
        });

        lists.forEach(s ->   System.out.println(s) );

        // 方法引用：简化Lambda表达式的写法
        // 必须前后参数一样才可以。
        lists.forEach(System.out::println );
    }
}
```
# Stream流
## 什么是Stream流？
```markdown
在Java 8中，得益于Lambda所带来的函数式编程，
引入了一个全新的Stream流概念 ，用于解决已有集合/数组类库既有的弊端。
```
## Stream流能解决什么问题?
```markdown
        可以解决已有集合类库或者数组API的弊端。
        Stream认为集合和数组操作的API很不好用，所以采用了Stream流简化集合和数组的操作！！
    小结：
        Stream流的核心思想：把集合或者数组转成一个Stream流（传送带）
        然后使用Stream流的强大功能进行元素的处理!
```

```java
public class StreamDemo01 {
    public static void main(String[] args) {
        // 需求：从集合中筛选出所有姓张的人出来。然后再找出姓名长度是3的人。
        List<String> list = new ArrayList<>();
        list.add("张无忌");
        list.add("周芷若");
        list.add("赵敏");
        list.add("张强");
        list.add("张三丰");

      /*  // 创建一个新集合存储姓张的人
        List<String> zhangNames = new ArrayList<>();
        for(String name : list){
            if(name.startsWith("张")){
                zhangNames.add(name);
            }
        }
        System.out.println(zhangNames);

        // 找出长度为3的名字
        List<String> threeNames = new ArrayList<>();
        for(String name : zhangNames){
            if(name.length() == 3){
                threeNames.add(name);
            }
        }
        System.out.println(threeNames);*/

      list.stream().filter(s -> s.startsWith("张"))
              .filter(s -> s.length() == 3).forEach(s -> System.out.println(s));

    }
}
```
## Stream流的获取
```markdown
Stream流式思想的核心：
    是先得到集合或者数组的Stream流（就是一根传送带）
    然后就在用这个Stream流操作集合或者数组的元素。
    然后用Stream流简化替代集合操作的API.

集合获取流的API:
     (1) default Stream<E> stream();
```

```java
public class StreamDemo01 {
    public static void main(String[] args) {
        /** --------------------Collection集合获取流-------------------------------   */
        // Collection集合如何获取Stream流。
        Collection<String> lists = new ArrayList<>();
        Stream<String> ss = lists.stream();

        /** --------------------Map集合获取流-------------------------------   */
        Map<String, Integer> map = new HashMap<>();
        // 先获取键的Stream流。
        Stream<String> keyss = map.keySet().stream();
        // 在获取值的Stream流
        Stream<Integer> valuess = map.values().stream();
        // 获取键值对的Stream流（key=value： Map.Entry<String,Integer>）
        Stream<Map.Entry<String,Integer>> keyAndValues = map.entrySet().stream();

        /** ---------------------数组获取流------------------------------   */
        // 数组也有Stream流。
        String[] arrs = new String[]{"Java", "JavaEE" ,"Spring Boot"};
        Stream<String> arrsSS1 = Arrays.stream(arrs);
        Stream<String> arrsSS2 = Stream.of(arrs);

    }
}
```
## Stream流的常用API
```java
           -- Stream<T> filter(Predicate<? super T> predicate)
         forEach : 逐一处理(遍历)
         count：统计个数
            -- long count();
         filter : 过滤元素
         limit : 取前几个元素
         skip : 跳过前几个
         map : 加工方法.
         concat : 合并流
```

```java
public class StreamDemo01 {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        list.add("张无忌");
        list.add("周芷若");
        list.add("赵敏");
        list.add("张强");
        list.add("张三丰");
        list.add("张三丰");

        list.stream().filter(s -> s.startsWith("张")).forEach(System.out::println);
        System.out.println("---------------------");
        list.stream().filter(s -> s.startsWith("张"))
                .limit(2).forEach(System.out::println);
        System.out.println("---------------------");
        list.stream().filter(s -> s.startsWith("张"))
                .skip(2).forEach(System.out::println);

    }
}
public class StreamDemo02 {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        list.add("张无忌");
        list.add("周芷若");
        list.add("赵敏");
        list.add("张强");
        list.add("张三丰");
        list.add("张三丰");

        // 需求：给每个元素都加上前缀： 黑马的："姓名"
        list.stream().map(s -> "黑马的："+s).forEach(System.out::println);

        // 需求：把每个名称变成对应的学生对象！
        list.stream().map(name -> new Student(name)).forEach(System.out::println);


    }
}
public class StreamDemo03 {
    public static void main(String[] args) {

        List<String> list = new ArrayList<>();
        list.add("张无忌");
        list.add("周芷若");
        list.add("赵敏");
        list.add("张强");
        list.add("张三丰");
        list.add("张三丰");

        // 数组流
        Stream<String> s1 = Stream.of("10", "12", "18");

        // 集合流
        Stream<String> s2 = list.stream();

        // 合并流
        Stream<String> allStream = Stream.concat(s1 , s2 );
        System.out.println(allStream.count());
    }
}
public class Student {
    private String name ;

    public Student(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                '}';
    }
}
```
## Stream流的综合应用
```java
public class StreamDemo {
    public static void main(String[] args) {
        List<String> one = new ArrayList<>();
        one.add("迪丽热巴");
        one.add("宋远桥");
        one.add("苏星河");
        one.add("老子");
        one.add("庄子");
        one.add("孙子");
        one.add("洪七公");

        List<String> two = new ArrayList<>();
        two.add("古力娜扎");
        two.add("张无忌");
        two.add("张三丰");
        two.add("赵丽颖");
        two.add("张二狗");
        two.add("张天爱");
        two.add("张三");

        /**
         * 1. 第一个队伍只要名字为3个字的成员姓名；
         * 2. 第一个队伍筛选之后只要前3个人；
         */
        Stream<String> oneStream = one.stream().filter(s->s.length()==3).limit(3);
        /**
         * 3. 第二个队伍只要姓张的成员姓名；
         * 4. 第二个队伍筛选之后不要前2个人；
         * 5. 将两个队伍合并为一个队伍；
         */
        Stream<String> twoStream = two.stream().filter(s -> s.startsWith("张")).skip(2);
        Stream<String> allStream = Stream.concat(oneStream , twoStream);

        /**
         * 6. 根据姓名创建`Student`对象；
         * 7. 打印整个队伍的Student对象信息。
         */
        allStream.map(name -> new Student(name)).forEach(System.out::println);

    }
}
public class Student {
    private String name ;

    public Student(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                '}';
    }
}
```
## Stream流的终结与非终结方法
```java
/**
    目标：终结与非终结方法。

    终结方法：一旦Stream调用了终结方法，流的操作就全部终结了，不能继续使用，
        只能创建新的Stream操作。
    终结方法： foreach , count。

    非终结方法：每次调用完成以后返回一个新的流对象，可以继续使用，支持链式编程！


 */
public class StreamDemo {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        list.add("张无忌");
        list.add("周芷若");
        list.add("赵敏");
        list.add("张强");
        list.add("张三丰");
        list.add("张三丰");

        list.stream().filter(s -> s.startsWith("张"))
                .forEach( s -> System.out.println(s));


    }
}
```
## 收集Stream流
```markdown
引入：
    Stream的作用是：把集合转换成一根传送带，借用Stream流的强大功能进行的操作。
    但是实际开发中数据最终的形式还是应该是集合，最终Stream流操作完毕以后还是要转换成集合。
    这就是收集Stream流。
    Stream流：手段。
    集合：才是目的。

    流：只能使用一次。

    小结：
        开发中Stream流用于操作集合，最终还是要把结果数据转换回集合或者数组。
```

```java
public class StreamDemo {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        list.add("张无忌");
        list.add("周芷若");
        list.add("赵敏");
        list.add("张强");
        list.add("张三丰");
        list.add("张三丰");

        // 需求：姓张。
        Stream<String> s1 = list.stream().filter(s -> s.startsWith("张"));
        // 1.把流转回成List集合
        List<String> list1 = s1.collect(Collectors.toList());
        System.out.println(list1);

        // 2.把流转回成Set集合
        Stream<String> s2 = list.stream().filter(s -> s.startsWith("张"));
        Set<String> sets = s2.collect(Collectors.toSet());
        System.out.println(sets);

        // 3.把流转成数组
        Stream<String> s3 = list.stream().filter(s -> s.startsWith("张"));
        //Object[] arrs = s3.toArray();
        String[] arrs = s3.toArray(String[]::new);// 指定转的数组类型！
        System.out.println("数组："+ Arrays.toString(arrs));

    }
}
```
# File类
```markdown
    File类：代表当前操作系统的文件对象。
    File类：是用来操作操作系统的文件对象的，删除文件，获取文件信息，创建文件（文件夹）...

    File类的创建文件对象的API:
         包：java.io.File
        （1）构造器：
            -- public File(String pathname):根据路径获取文件对象
            -- public File(String parent , String child):根据父路径和文件名称获取文件对象！
            -- public File(File parent , String child)

    File类创建文件对象的格式:
        a.File f = new File("绝对路径/相对路径");
            绝对路径：从磁盘的的盘符一路走到目的位置的路径。
                -- 绝对路径依赖具体的环境，一旦脱离环境，代码可能出错！！
            相对路径：不带盘符的。
                -- 默认是直接相对到工程目录下寻找文件的。
                -- 相对路径只能用于寻找工程下的文件，
                -- 能用相对路径就应该尽量使用，可以跨平台！

        File f = new File("文件对象/文件夹对象");
            广义来说：文件是包含文件和文件夹的。
    小结：
        File类代表了文件或者文件夹对象。
        File类创建文件对象可以用绝对路径/相对路径
        相对路径：默认是直接相对到工程目录下寻找文件的。
```

```java
public class FileDemo01 {
    public static void main(String[] args) {
        // a.定位绝对路径
        /**
            路径分隔符：3种
                1、正斜杆：/
                2、反斜杠：需要转义。\\
                3、API :File.separator获取当前操作系统的分隔符，可以跨平台。
         */
        File f1 = new File("D:/itcast/图片资源/meinv.jpg");
        File f11 = new File("D:\\itcast\\图片资源\\meinv.jpg");
        File f111 = new File("D:"+File.separator+"itcast"+File.separator+"图片资源"+File.separator+"meinv.jpg");
        System.out.println(f1.length()); // 获取文件的大小：字节大小。

        // b.定位相对路径
        File f2 = new File("dlei.txt");
        System.out.println(f2.length());

        File f4 = new File("src/dlei02.txt");
        System.out.println(f4.length());

        // c.File f = new File("文件对象/文件夹对象");
        File f3 = new File("D:/itcast/图片资源/");
        System.out.println(f3.exists()); // true
    }
}
```
## File类的获取功能的方法
```java
public String getAbsolutePath()  ：返回此File的绝对路径名字符串。
public String getPath()  ： 获取创建文件对象的时候用的路径
public String getName()  ： 返回由此File表示的文件或目录的名称。
public long length()  ：    返回由此File表示的文件的长度。
```

```java
public class FileDemo {
    public static void main(String[] args) {
        // 1.绝对路径创建一个文件对象
        File file1 = new File("D:/itcast/图片资源/meinv.jpg");
        // a.获取它的绝对路径
        System.out.println(file1.getAbsolutePath());
        // b.获取文件定义的时候使用的路径
        System.out.println(file1.getPath());
        // c.获取文件的名称：带后缀。
        System.out.println(file1.getName());
        // d.获取文件的大小：字节个数。
        System.out.println(file1.length());

        System.out.println("-------------------");

        // 2.相对路径
        File file2 = new File("src/dlei02.txt");
        // a.获取它的绝对路径
        System.out.println(file2.getAbsolutePath());
        // b.获取文件定义的时候使用的路径
        System.out.println(file2.getPath());
        // c.获取文件的名称：带后缀。
        System.out.println(file2.getName());
        // d.获取文件的大小：字节个数。
        System.out.println(file2.length());

        System.out.println("---------拓展----------");
        // 返回的是一个时间毫秒值
        long time = file1.lastModified(); // 文件最后修改时间！
        SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMdd HH:mm:ss");
        System.out.println(sdf.format(time));

    }
}
```
## File类的判断功能的方法
```java
public boolean exists() ：此File表示的文件或目录是否实际存在。
public boolean isDirectory() ：此File表示的是否为目录。
public boolean isFile() ：此File表示的是否为文件
```

```java
public class FileDemo {
    public static void main(String[] args) {
        // 1.文件对象。
        File f1 = new File("D:\\itcast\\图片资源\\meinv.jpg");
        // a.判断文件路径是否存在
        System.out.println(f1.exists()); // true
        // b.判断文件对象是否是文件,是文件返回true ,反之
        System.out.println(f1.isFile()); // true
        // c.判断文件对象是否是文件夹,是文件夹返回true ,反之
        System.out.println(f1.isDirectory()); // false

        // 1.文件对象。
        File f2 = new File("D:\\itcast\\图片资源");
        // a.判断文件路径是否存在
        System.out.println(f2.exists()); // true
        // b.判断文件对象是否是文件,是文件返回true ,反之
        System.out.println(f2.isFile()); // false
        // c.判断文件对象是否是文件夹,是文件夹返回true ,反之
        System.out.println(f2.isDirectory()); // true

    }
}
```
## File类的创建和删除的方法
```java
public boolean createNewFile() ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。 （几乎不用的，因为以后文件都是自动创建的！）
public boolean delete() ：删除由此File表示的文件或目录。 （只能删除空目录）
public boolean mkdir() ：创建由此File表示的目录。（只能创建一级目录）
public boolean mkdirs() ：可以创建多级目录（建议使用的）

//小结：
         //删除文件或者空文件夹，但是不能直接删除非空文件夹。
         //mkdirs可以创建多级目录。
```

```java
public class FileDemo {
    public static void main(String[] args) throws IOException {
        File f = new File("src/dlei03.txt");
        System.out.println(f.exists()); // false
        // a.创建新文件，创建成功返回true ,反之
        System.out.println(f.createNewFile());

        // b.删除文件或者空文件夹
        System.out.println(f.delete());
        File f1 = new File("D:\\itcast\\班级\\Java就业班123期\\aaa");
        System.out.println(f1.delete());

        // c.创建一级目录
        File f2 = new File("D:\\itcast\\班级\\Java就业班123期\\bbb");
        System.out.println(f2.mkdir());

        // d.创建多级目录
        File f3 = new File("D:\\itcast\\班级\\Java就业班123期\\ccc\\dddd\\d\\f\\f\\ff\\fv");
        System.out.println(f3.mkdirs());
    }
}
```
## File目录的遍历
```java
public String[] list()：获取当前目录下所有的"一级"文件名称到一个字符串数组中去返回。
public File[] listFiles()(常用)：获取当前目录下所有的一级文件对象到一个文件对象数组中去返回（重点）
```

```java
public class FileDemo {
    public static void main(String[] args) {
        File dir = new File("D:\\itcast\\班级");
        // a.获取当前目录对象下的全部一级文件名称到一个字符串数组返回。
        String[] names = dir.list();
        for(String name : names){
            System.out.println(name);
        }

        // b.获取当前目录对象下的全部一级文件对象到一个File类型的数组返回。
        File[] files = dir.listFiles();
        for(File f : files){
            System.out.println(f.getAbsolutePath());
        }
    }
}
```
# 递归
```markdown
    递归：方法在方法中又调用了自己。

    递归：
        直接递归：自己的方法调用自己。
        间接递归：自己的方法调用别的方法，别的方法又调用自己。
    小结：
         递归是自己调用自己。
         递归如果控制的不恰当，会形成递归的死循环，从而导致栈内存溢出错误！！
         递归应该防止进入递归的死循环！

```

```java
public class RecursionDemo01 {
    public static void main(String[] args) {
        testA();
    }

    public static void testA(){
        System.out.println("--A--");
        testA();
    }
}

```
## 递归的核心算法思想和执行流程
```java
    已知：f(x) = f(x - 1) + 1  （恒等式）
    已知：f(1) = 1
    求：  f(10) = ?

    计算流程：
         f(10) = f(9) +  1
         f(9)  = f(8) +  1
         f(8)  = f(7) +  1
         f(7)  = f(6) +  1
         f(6)  = f(5) +  1
         f(5)  = f(4) +  1
         f(4)  = f(3) +  1
         f(3)  = f(2) +  1
         f(2)  = f(1) +  1
         f(1)  = 1

    递归的三要素：
        （1）递归的公式：f(x) = f(x - 1) + 1
        （2）终结点： f(1)  = 1
        （3）递归的方向：必须走向终结点
```

```java
public class RecursionDemo02 {
    public static void main(String[] args) {
        System.out.println(f(10));
    }

    public static int f(int x){
        if(x == 1){
            return 1;
        }else{
            return f(x - 1) + 1;
        }
    }
}
```
## 递归的核心思想-公式转换
```markdown
    已知：f(x) = f(x + 1) + 2
         f(1) = 1
    求：  f(10) = ?

    公式转换：
         f(x-1) = f(x) + 2
         f(x) = f(x-1) - 2

    递归算法的三要素：
         （1）递归的公式：   f(x) = f(x-1) - 2
         （2）递归的终结点： f(1) = 1
         （3）递归的方向：必须走向终结点
```

```java
public class RecursionDemo03 {
    public static void main(String[] args) {
        System.out.println(f(10));
    }

    public static int f(int x){
        if(x == 1){
            return 1 ;
        }else {
            return f(x-1) - 2;
        }
    }
}
```
## 递归的经典案例
```markdown
    猴子吃桃：
        猴子第一天摘了若干个桃子，当即吃了一半，觉得好不过瘾，然后又多吃了一个。
        第二天又吃了前一天剩下的一半，觉得好不过瘾，然后又多吃了一个。
        以后每天都是如此
        等到第十天再吃的时候发现只有1个桃子，请问猴子第一天总共摘了多少个桃子。

    公式：
        f(x+1) = f(x) - f(x)/2 - 1
        2f(x +1) = 2f(x) - f(x) - 2
        f(x) = 2f(x+1)+2
        求：f(1)= ?

    递归的三要素：
        （1）公式： f(x) = 2f(x+1)+2
        （2）终结点：f(10) = 1
        （3）递归的方向：
```

```java
public class RecursionDemo04 {
    public static void main(String[] args) {
        System.out.println(f(1));
    }

    public static int f(int x){
        if(x == 10){
            return 1 ;
        }else {
            return  2*f(x+1)+2;
        }
    }
}
```
## 1-n的和
```markdown
    f(n) = 1 + 2 + 3 + 4 + 5 + ....n-1 + n
    f(n) = f(n-1) + n

    流程：
        f(5) = f(4)  + 5  = 1 + 2 + 3 + 4 + 5
        f(4) = f(3)  + 4  = 1 + 2 + 3 + 4
        f(3) = f(2)  + 3  = 1 + 2 + 3
        f(2) = f(1)  + 2  = 1 + 2
        f(1) = 1

    递归的核心三要素：
        （1）递归的终点接： f(1) = 1
        （2）递归的公式：   f(n) = f(n-1) + n
        （3）递归的方向必须走向终结点：
```

```java
public class RecursionDemo05 {
    public static void main(String[] args) {
        System.out.println(f(5));
    }

    public static int f(int n){
        if(n==1){
            return 1;
        }else{
            return  f(n-1) + n;
        }
    }
}
```

## n的阶乘
```markdown
     n!= 1*2*3*4*5*6*...*(n-1)*n
     f(n) = 1*2*3*4*5*6*...*(n-1)*n
     f(n) = f(n-1)*n

     f(5) = ?

     流程：
        f(5) = f(4) * 5 ;
        f(4) = f(3) * 4 ;
        f(3) = f(2) * 3 ;
        f(2) = f(1) * 2 ;
        f(1) = 1

     递归的核心三要素：
        （1）递归的终点接： f(1) = 1
        （2）递归的公式   f(n) = f(n-1)*n
        （3）递归的方向必须走向终结点
    ---------------------------------------------------------
    以上理论只能针对于规律化递归，如果是非规律化是不能套用以上公式的！
    非规律化递归的问题：文件搜索，啤酒问题。
    非规律化就看你的水平了！自己看着办！！
```

```java
public class RecursionDemo06 {
    public static void main(String[] args) {
        System.out.println(f(5));
    }

    public static int f(int n){
        if(n == 1){
            return 1 ;
        }else{
            return f(n-1)*n;
        }
    }
}
```
# 文件搜索
```markdown
去某个目录下，遍历所有的文件对象，找出自己想要的那个文件。Java默认只能支持一级文件对象的遍历，如果要搜索所有文件必须用递归思想。
```

```java
public class FileSearchDemo01 {
    public static void main(String[] args) {
        // 1.定义搜索的目录
        File f = new File("D:/soft");
        // 3.开始的调用方法进行搜索
        searchFiles(f,"eclipse.exe");
    }

    // 2.定义一个搜索方法：
    /**
     * 搜索文件的方法
     * @param dir  搜索的目录
     * @param fileName 搜索的文件名称
     */
    public static void searchFiles(File dir , String fileName){
         // 4.判断是否是目录，是否存在该目录
        if(dir!=null&&dir.exists()&&dir.isDirectory()){
            // 5.提取当前目录下的全部一级文件对象到一个File数组中去
            File[] files = dir.listFiles();
            // 6.判断是否存在一级文件对象（判断是否dir不为空）
            if(files!=null && files.length > 0){
                // 7.遍历全部的一级文件对象
                for(File f : files){
                    // 8.判断是否是文件。是文件判断是否是自己要找的。
                    if(f.isFile()){
                        // 拿文件的名称判断是否是包含了搜索的文件名称
                        if(f.getName().contains(fileName)){
                            System.out.println("找到了："+f.getAbsolutePath());
                        }
                    }else if(f.isDirectory()){
                        // 9.如果当前文件对象是否文件夹，应该进入递归继续寻找
                        searchFiles(f,fileName);
                    }
                }
            }
        }
    }
}
```
# 字符集/编码集
```markdown
     字符集：各个国家为自己国家的字符取的一套编号规则。
     计算机的底层是不能直接存储字符的。
     计算机的底层只能存储二进制。010101
     二进制就是可以转成10进制的。10进制就是整数编号。
     结论：计算机的底层可以存储编号。

     101 = 1*2^0 + 0*2^1 + 1*2^2 = 5

     美国人：
         8个开关一组就可以编码字符。 1个字节。
         2^8 = 256
         一个字节存储一个字符完全够用了。

         a  97
         b  98

         A  65
         B  66

         0  48
         1  49
         这套编码是ASCII编码。

         英文和数字在底层存储的时候都是采用1个字节存储的。

     中国人：
         中国人的字符很多：几十万个字符。
         中国人采用2个字节编码一个中文字符。
         这套编码叫：GBK编码。
         它也必须兼容ASCII编码表。
         ....

     美国人：
         我来收集全球所有的字符，统一编号。这套编码叫 Unicode编码（万国码）
         UTF-8就是变种形式。
         UTF-8一个中文一般占3个字节。
         它也必须兼容ASCII编码表。

     小结：
         英文和数字在任何编码集中都是一样的，都占1个字节。
         GBK编码中，1个中文字符一般占2个字节。
         UTF-8编码中，1个中文字符一般占3个字节。
         技术人员都应该使用UTF-8编码！

         编码前与编码后的编码集必须一致才不会乱码!!

         GBK   我爱你     GBK     不会乱码！
         GBK   我爱你     UTF-8   会乱码！

         英文和数字在任何编码集中可以通用，不会乱码！
```
# IO流
```markdown
    IO流：输入/输出流。
        Input:输入。
        Output:输出。

    引入：
        File类只能操作文件对象本身，不能读写文件对象的内容。
        读写数据内容，应该使用IO流。

    IO流是一个水流模型：IO理解成水管，把数据理解成水流。

    IO流的分类:
        按照流的方向分为：输入流，输出流。
           （1）输出流：以内存为基准，把内存中的数据写出到磁盘文件或者网络介质中去的流称为输出流。
                    输出流的作用：写数据到文件，或者写数据发送给别人。

           （2）输入流：以内存为基准，把磁盘文件中的数据或者网络中的数据读入到内存中去的流称为输入流。
                    输入流的作用：读取数据到内存。

        按照流的内容分为: 字节流，字符流。
           （1）字节流：流中的数据的最小单位是一个一个的字节，这个流就是字节流。
           （2）字符流：流中的数据的最小单位是一个一个的字符，这个流就是字符流。(针对于文本内容)


    所以流大体分为四大类:
        字节输入流：以内存为基准，把磁盘文件中的数据或者网络中的数据以一个一个的字节的形式读入到内存中去的流称为字节输入流。
        字节输出流：以内存为基准，把内存中的数据以一个一个的字节写出到磁盘文件或者网络介质中去的流称为字节输出流。
        字符输入流：以内存为基准，把磁盘文件中的数据或者网络中的数据以一个一个的字符的形式读入到内存中去的流称为字符输入流。
        字符输出流：以内存为基准，把内存中的数据以一个一个的字符写出到磁盘文件或者网络介质中去的流称为字符输出流。
    小结：
        IO流是读写传输数据的，IO流有很多种，每种流有自己的功能特点。
```
## 字节输入流
```markdown
    IO流的体系：
                    字节流                               字符流
    字节输入流               字节输出流            字符输入流       字符输出流
    InputStream             OutputStream        Reader          Writer     (抽象类)
    FileInputStream         FileOutputStream    FileReader      FileWriter (实现类)

    a.文件字节输入流：FileInputStream
        -- 作用：以内存为基准，把磁盘文件中的数据以字节的形式读入到内存中。读文件数据的。
        -- 构造器：
           public FileInputStream(File file)：创建字节输入流管道通向文件对象。
           public FileInputStream(String pathName)：创建字节输入流管道通向文件路径。
        -- 方法：
           public int read():每次读取一个字节返回，读取完毕返回-1.
           public int read(byte[] buffer):每次读取字节数据到一个字节数组中去，返回读取的字节总数，读取完毕返回-1
    小结：
        使用字节数组循环读取数据输出，也是无法避免中文乱码的可能性。
```

```java
public class InputStreamDemo01 {
    public static void main(String[] args) throws Exception {
        // 1.定位源文件
        File file = new File("src/dlei02.txt");
        // 2.创建一个字节输入流管道与源文件接通
        InputStream is = new FileInputStream(file);
        // 3.读取一个字节数据。
        int by = is.read(); // 读取一个字节返回
        System.out.println((char)by);

        int by1 = is.read();
        System.out.println((char)by1);

        int by2 = is.read();
        System.out.println((char)by2);

        int by3 = is.read();
        System.out.println(by3);
    }
}
public class InputStreamDemo02 {
    public static void main(String[] args) throws Exception {
        // 1.定位源文件
        // File file = new File("src/dlei02.txt");
        // 2.创建一个字节输入流管道与源文件接通
        // InputStream is = new FileInputStream(file);

        // 简化写法：字节输入流通向文件。
        InputStream is = new FileInputStream("src/dlei03.txt");

        // 1.定义一个字节数组（表示一个桶）
        byte[] buffer = new byte[3];
        // 读取is流中的字节装入到字节数组buffer中去，返回读取的字节数量。
        int len = is.read(buffer);
        System.out.println("读取的字节数："+len); // 3
        // 把字节数组转换成字符串数据返回。
        String rs = new String(buffer);
        System.out.println(rs);


        // 2.定义一个字节数组（表示一个桶）
        byte[] buffer1 = new byte[3];
        // 读取is流中的字节装入到字节数组buffer1中去，返回读取的字节数量。
        int len1 = is.read(buffer1);
        System.out.println("读取的字节数："+len1); // 2
        // 把字节数组转换成字符串数据返回。
        // 必须：读取多少就倒出多少。
        String rs1 = new String(buffer1 , 0 , len1);
        System.out.println(rs1);

        // 3.读取第三桶水
        byte[] buffer2 = new byte[3];
        // 读取is流中的字节装入到字节数组buffer2中去，返回读取的字节数量。
        int len2 = is.read(buffer2);
        System.out.println(len2); // -1读取完毕了。没有数据可读取了
    }
}
public class InputStreamDemo03 {
    public static void main(String[] args) throws Exception {
        // 1.定义一个字节输入流管道与源文件接通
        InputStream is = new FileInputStream("src/dlei04.txt");
        // 2.定义一个字节数组读取数据
        byte[] buffer = new byte[6];
        // 定义一个变量存储每次读取了多少字节数.   字节数据：6+6+3
        int len ;
        while((len = is.read(buffer))!=-1){
            String rs = new String(buffer , 0 , len);
            System.out.print(rs);
        }
    }
}
```
## 字节输入流读取文本文件内容输出避免乱码的方案
```markdown
思想: 可以使用字节数组一桶水把整个文件的字节全部刚刚装满，如此便可避免中文读取输出乱码。
弊端：如果文件过大，定义的字节数组可能超过限制。

小结：
    从这里来看，字节流根本不适合读取文本文件内容输出。
    读写文本文件内容应该采用字符流。
```

```java
public class InputStreamDemo04 {
    public static void main(String[] args) throws Exception {
        File srcFile = new File("src/dlei05.txt");
        // 1.定义一个字节输入流管道与源文件接通
        InputStream is = new FileInputStream(srcFile);

        // 2.定义一个字节数组与文件的大小一样大。
//        byte[] buffer = new byte[(int)srcFile.length()];
//        int len = is.read(buffer);
//        System.out.println("读取的字节数："+len);
//        System.out.println("文件大小："+srcFile.length());
//        String rs = new String(buffer);
//        System.out.println(rs);

        // 直接读取一桶字节数组返回：sun公司提供好的API.
        // 只支持低于8kb的文件数据。
        byte[] buffer = is.readAllBytes();
        String rs = new String(buffer);
        System.out.println(rs);
    }
}
```

## 字节输出流
```markdown
     b.文件字节输出流：FileOutputStream
        -- 作业：以内存为基准，把内存中的数据以字节的形式写出到磁盘文件中去。写数据到文件中去。
        -- 构造器：
           public FileOutputStream(File file)
           public FileOutputStream(String pathName)
           public FileOutputStream(File file ,boolean append)
           public FileOutputStream(String pathName ,boolean append)
        -- 方法：
           public void write(int b):写一个字节出去。
           public void write(byte[] buffer):写一个字节数组出去。
           public void write(byte[] buffer,int pos,int len):写一个字节数组的一部分出去。
                参数一：字节数组。
                参数二：从哪个字节索引开始
                参数三：写多少个字节出去
     字节输出流：默认写数据的时候会覆盖之前全部的数据。
     字节输出流追加数据的管道：第二个参数填写true即可。
            OutputStream os = new FileOutputStream("src/dlei07.txt",true);
     换行：  os.write("\r\n".getBytes()); // 换行！
```

```java
public class FileOutputStreamDemo01 {
    public static void main(String[] args) throws Exception {
        // 1.创建一个目标文件对象
        File f = new File("src/dlei06.txt");
        // 2.创建一个字节输出流管道与目标文件接通
        OutputStream os = new FileOutputStream(f);
        // 3.写一个字节出去。
        os.write(97); // 字节a
        os.write('b'); // 字节b

        // 4.写一个字节数组出去
        // 把字符串按照当前默认代码编码转换成字节数组。
        byte[] buffer = "我爱你中国abc".getBytes();
        // 按照指定的编码把中文转换成字节数组。
        //byte[] buffer = "我爱你中国abc".getBytes("GBK");
        os.write(buffer);

        // 5.写一个字节数组的一部分出去。
        byte[] buffer1 = "我爱你中国abc".getBytes();
        os.write(buffer1,0,15);

        // os.flush(); // 刷新数据，让数据立即进入文件中去！刷新后管道可以继续使用。
        os.close(); // 关闭管道，关闭包含刷新，关闭后流不可再使用。
    }
}
public class FileOutputStreamDemo02 {
    public static void main(String[] args) throws Exception {
        // 1.创建一个字节输出流管道与目标文件路径接通
        // 简化写法：
        // OutputStream os = new FileOutputStream("src/dlei07.txt");

        /**
         * 参数一：文件路径
         * 参数二：true 追加管道，写数据不会覆盖，只会在文件后面追加数据。
         */
        OutputStream os = new FileOutputStream("src/dlei07.txt",true);
        // 2.写一个字节出去。
        os.write(97); // 字节a
        os.write('b'); // 字节b
        os.write("\r\n".getBytes()); // 换行！

        // 3.写一个字节数组出去
        // 把字符串按照当前默认代码编码转换成字节数组。
        byte[] buffer = "我爱你中国abc".getBytes();
        // 按照指定的编码把中文转换成字节数组。
        //byte[] buffer = "我爱你中国abc".getBytes("GBK");
        os.write(buffer);
        os.write("\r\n".getBytes()); // 换行！

        // 4.写一个字节数组的一部分出去。
        byte[] buffer1 = "我爱你中国abc".getBytes();
        os.write(buffer1,0,15);
        os.write("\r\n".getBytes()); // 换行！

        // os.flush(); // 刷新数据，让数据立即进入文件中去！刷新后管道可以继续使用。
        os.close(); // 关闭管道，关闭包含刷新，关闭后流不可再使用。
    }
}
```
## 字节流做文件复制
```markdown
    因为计算机所有的文件底层都是字节。
    字节流很适合做一切文件数据的复制：因为它是把源文件的字节一字不漏的转移给目标文件
    只要文件前后的格式一样就不会出问题。

    分析：
        （1）创建一个字节输入流管道与源文件接通。
        （2）创建一个字节输出流管道与目标文件接通。
        （3）定义一个字节数组。
        （4）定义一个循环从字节输入流读取数据倒出到字节输出流管道。

    源文件：‪D:\itcast\图片资源\meinv.jpg
    目标文件：D:\itcast\dlei.jpg
```

```java
public class CopyDemo01 {
    public static void main(String[] args) {
        InputStream is = null;
        OutputStream os = null;
        try {
            //（1）创建一个字节输入流管道与源文件接通。
            is = new FileInputStream("D:\\itcast\\图片资源\\meinv.jpg");
            //（2）创建一个字节输出流管道与目标文件接通。
            os = new FileOutputStream("D:\\itcast\\dlei.jpg");
            //（3）定义一个字节数组。
            byte[] buffer = new byte[1024];
            //（4）定义一个循环从字节输入流读取数据倒出到字节输出流管道。
            int len ;
            while((len = is.read(buffer))!=-1){
                // 读取多少倒出多少。
                os.write(buffer,0,len);
            }
            System.out.println("复制完成！");
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            try {
                // 释放资源。
                if(os!=null) os.close();
                if(is!=null) is.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
/**
 目录：JDK 1.7开始关闭资源的新方式：try-with-resources.

 try(
 这里只能放置资源，用完会自动调用资源的close方法关闭资源。
 ){

 }catch (Exception e) {
 e.printStackTrace();
 }

 什么是资源：Java认为一个类只要实现了Closeable接口就是资源。
 */
public class CopyDemo02 {
    public static void main(String[] args) {

        try (
                //（1）创建一个字节输入流管道与源文件接通。
                InputStream is = new FileInputStream("D:\\itcast\\图片资源\\meinv.jpg");
                //（2）创建一个字节输出流管道与目标文件接通。
                OutputStream os = new FileOutputStream("D:\\itcast\\dlei.jpg");
        ){

            //（3）定义一个字节数组。
            byte[] buffer = new byte[1024];
            //（4）定义一个循环从字节输入流读取数据倒出到字节输出流管道。
            int len ;
            while((len = is.read(buffer))!=-1){
                // 读取多少倒出多少。
                os.write(buffer,0,len);
            }
            System.out.println("复制完成！");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```
## 字符输入流
```markdown
     IO流的体系：
                字节流                               字符流
     字节输入流               字节输出流            字符输入流       字符输出流
     InputStream             OutputStream        Reader          Writer     (抽象类)
     FileInputStream         FileOutputStream    FileReader      FileWriter (实现类)

     文件字符输入流：FileReader
        -- 作用：以内存为基准，把磁盘文件的数据按照一个一个的字符读入到内存中去。
        -- 构造器：
           public FileReader(File file)
           public FileReader(String filePath)
        -- 方法：
           public int read(): 读取一个字符的编号返回,读取完毕返回-1
           public int read(char[] buffer):读取字符数据装入到字符数组中去，返回装了多少个字符数，读取完毕返回-1
     小结：
        可以使用字符流实现一个一个字符的读取文本内容。性能差！
        字符输入流按照字符数组循环读取文本文件内容输出：很合适。
```

```java
public class FileReaderDemo01 {
    public static void main(String[] args) throws Exception {
        // 1.创建一个文件字符输入流管道与源文件接通
        Reader fr = new FileReader("src/dlei08.txt");
        // 2.读取字符：读取一个字符编号返回！
       /* char ch = (char) fr.read();
        System.out.println(ch);

        char ch1 = (char) fr.read();
        System.out.println(ch1);*/

        // 拓展：一个一个字符循环的读取
        // 定义一个变量存储一个字符
        int ch ;
        while((ch = fr.read())!=-1){
            System.out.print((char)ch);
        }

    }
}
public class FileReaderDemo02 {
    public static void main(String[] args) throws Exception {
        // 1.创建一个文件字符输入流管道与源文件接通
        Reader fr = new FileReader("src/dlei08.txt");
        // 2.定义一个字符数组读取数据。
        /*char[] buffer = new char[32];
        int len = fr.read(buffer);
        System.out.println("读取了多少个字符："+len);
        String rs = new String(buffer,0,len);
        System.out.println(rs);*/

        // 定义一个循环读取数据输出： 1024 +1024 + 3
        char[] buffer = new char[1024];
        int len; // 记录每次读取了多少个字符。
        while((len = fr.read(buffer)) != -1 ){
            String rs = new String(buffer,0,len);
            System.out.print(rs);
        }

    }
}
```
## 字符输出流
```markdown
     IO流的体系：
                字节流                               字符流
     字节输入流               字节输出流            字符输入流       字符输出流
     InputStream             OutputStream        Reader          Writer     (抽象类)
     FileInputStream         FileOutputStream    FileReader      FileWriter (实现类)

     文件字符输出流：FileWriter
         -- 作用：以内存为基准，把内存中的数据按照一个一个的字符写出到磁盘文件中去。写数据到文件。
         -- 构造器：
             public FileWriter(File file)
             public FileWriter(String filePath)
             public FileWriter(File file,boolean append)
             public FileWriter(String filePath,boolean append)

         -- 方法：
             public void writer(int ch):写一个字符
             public void writer(String str):写一个字符串出去
             public void writer(String str,int pos ,int len):写一个字符串的一部分出去
             public void writer(char[] chars):写一个字符数组出去
             public void writer(char[] chars,int pos ,int len):写一个字符数组的一部分出去
     追加管道：
         Writer fw = new FileWriter("src/dlei09.txt" , true);
     换行：
         fw.write("\r\n"); // 换行！
```

```java
public class FileWriterDemo01 {
    public static void main(String[] args) throws Exception {
        // 1.创建一个字符输出流管道与目标文件接通。
        // Writer fw = new FileWriter("src/dlei09.txt"); // 覆盖管道
        // 追加数据管道：参数二写成true
        Writer fw = new FileWriter("src/dlei09.txt" , true);
        // 2.写字符数据出去
        // a.写一个字符出去
        fw.write(97); // 写一个字符a.
        fw.write('a'); // 写一个字符a.
        fw.write('徐'); // 写一个字符徐
        fw.write("\r\n"); // 换行！

        // b.写一个字符串出去
        fw.write("我爱你中国！");
        fw.write("此生不悔入华夏，来世还做中国人！");
        fw.write("\r\n");

        // c.写一个字符数组出去
        char[] chars = "我爱你五星红旗".toCharArray();
        fw.write(chars);
        fw.write("\r\n");

        // d.写一个字符串的一部分出去
        fw.write("Java是最好的语言！",0,8);
        fw.write("\r\n");

        // e.写字符数组的一部分出去
        char[] chars1 = "我爱你五星红旗".toCharArray();
        fw.write(chars1,0,3);
        fw.write("\r\n");


        // fw.flush(); // 刷新，流可以继续使用
        fw.close(); // 关闭包含刷新，但是流死了！

    }
}
```
# 删除文件夹
```markdown
Java默认只能删除文件和空文件夹。
如果要删除一切文件对象那么怎么办呢？Java说你自己解决。
```

```java
public class DeleteDirsDemo01 {
    public static void main(String[] args) {
        deleteFiles(new File("D:\\"));
    }

    /**
     * 删除文件夹：无论是否为空
     * @param dir
     */
    public static void deleteFiles(File dir){
        // 1.判断这个文件夹是否存在。
        if(dir.exists()){
            // 2.提取当前目录下的全部一级文件对象
            File[] files = dir.listFiles();
            // 3.判断是否存在一级文件对象
            if(files!=null&&files.length > 0){
                // 4.存在一级文件对象了，遍历这些一级文件对象。
                for(File f : files){
                    // 5.判断是否是文件还是文件夹
                    if(f.isFile()){
                        // 是文件，直接干掉
                        f.delete();
                    }else{
                        // 是文件夹了，递归寻找删除
                        deleteFiles(f);
                    }
                }

            }
            // 前面都是删除文件夹里面的内容，最终要删除自己！！
            dir.delete();
        }
    }
}
```
# 非规律化递归
```markdown
啤酒2元一瓶，2个空瓶换一瓶，4个盖子换一瓶，问10元可以喝多少，剩余的情况？
```

```java
public class PiJiuDemo02 {
    // 定义一个变量存储买酒的数量。只需一个变量即可。
    public static int totalNum ;
    public static int lastPingNums ; // 剩余的瓶子数量
    public static int lastGaiZiNums; // 剩余的盖子数量

    public static void main(String[] args) {
        // 1.拿钱买酒。
        buyBeer(10000);
    }

    /**
     * 拿钱买酒。
     * @param money
     */
    public static void buyBeer(int money){
        int nums = money / 2 ;
        totalNum += nums ; // 累加此轮买酒的数量。

        // 计算出本轮总的盖子数量和瓶子数量。
        int currentGaiZiNums = nums + lastGaiZiNums;
        int currentPingZiNums = nums + lastPingNums;

        // 把盖子和瓶子换算成钱。
        int allMoney = 0 ;
        if(currentGaiZiNums >= 4){
            allMoney += (currentGaiZiNums/4)*2;
        }
        // 计算出当前剩余的盖子
        lastGaiZiNums = currentGaiZiNums % 4;

        if(currentPingZiNums >= 2){
            allMoney += (currentPingZiNums/2)*2;
        }
        // 计算出当前剩余的盖子
        lastPingNums = currentPingZiNums % 2;

        // 当换算的钱大于等于2才可以继续买酒
        if(allMoney >= 2){
            buyBeer(allMoney);
        }else {
            // 买完了
            System.out.println("总数："+totalNum);
            System.out.println("剩余盖子："+lastGaiZiNums);
            System.out.println("剩余瓶子："+lastPingNums);
        }
    }
}
```
# 缓冲流
```markdown
    字节流                                          字符流
    字节输入流               字节输出流              字符输入流         字符输出流
    InputStream             OutputStream          Reader            Writer   (抽象类)
    FileInputStream         FileOutputStream      FileReader        FileWriter(实现类,低级流，原始流)
    BufferedInputStream     BufferedOutStream     BufferedReader    BufferedWriter(实现类，缓冲流)

    什么是缓冲流：缓冲流可以提高字节流和字符流的读写数据的性能。
    缓冲流分为四类：
        （1）BufferedInputStream：字节缓冲输入流，可以提高字节输入流读数据的性能。
        （2）BufferedOutStream：  字节缓冲输出流，可以提高字节输出流写数据的性能。
        （3）BufferedReader：  字符缓冲输入流，可以提高字符输入流读数据的性能。
        （4）BufferedWriter：  字符缓冲输出流，可以提高字符输出流写数据的性能。
    小结：
        缓冲流的作用。提高字节流和字符流读写数据的性能。
        缓冲流有时候也叫高级流，基本的字节流也叫低级流（原始流）。
```
## 缓冲字节输入流
```markdown
        字节缓冲输入流：BufferedInputStream
            -- 作用：可以把低级的字节输入流包装成一个高级的缓冲字节输入流管道,
                    从而提高字节输入流读数据的性能。
            -- 构造器: public BufferedInputStream(InputStream in)

            -- 原理：缓冲字节输入流管道包装了低级的字节输入流管道以后
                就自带一个缓冲池，缓冲池是内存的一块区域，一次可以直接提取8KB数据到内存
                以后程序直接在内存的缓冲池中读取数据，性能是很快的！
     小结：
        缓冲字节输入流提高了字节输入流读数据的性能，功能几乎一样
```

```java
public class BufferedInputStreamDemo01 {
    public static void main(String[] args) throws Exception {
        // 1.定义一个低级的字节输入流管道与源文件接通
        InputStream is = new FileInputStream("src/dlei01.txt");
        // 3.把低级的字节输入流管道包装成一个高级的缓冲字节输入流管道。
        BufferedInputStream bis = new BufferedInputStream(is);

        // 2.定义一个字节数组读取数据输出
        byte[] buffer = new byte[32];
        int len = 0;
        while((len = bis.read(buffer)) != -1){
            System.out.print(new String(buffer,0,len));
        }
    }
}
```
## 缓冲字节输出流
```markdown
     字节缓冲输出流：BufferedOutputStream
         -- 作用：可以把低级的字节输出流包装成一个高级的缓冲字节输出流，从而提高写数据的性能。
         -- 构造器：public BufferedOutputStream(OutputStream os)
         -- 原理：缓冲字节输出流自带了8KB缓冲池,数据就直接写入到缓冲池中去，性能极高了！
     小结：
        缓冲字节输出流可以包装低级的字节输出流提高写数据的性能，功能几乎不变。
```

```java
public class BufferedInputStreamDemo02 {
    public static void main(String[] args) throws Exception {
        // 1.定义一个低级的字节输出流管道与目标文件接通
        OutputStream os = new FileOutputStream("src/dlei02.txt");
        // 3.把低级的字节输出流管道包装成一个高级的缓冲字节输出流管道
        BufferedOutputStream bos = new BufferedOutputStream(os);

        // 2.写数据出去
        bos.write(97);
        bos.write('A');
        bos.write("我爱你中国".getBytes());
        bos.close();

    }
}
```
## 性能统计
```java
/**
    目标：利用字节流的复制统计各种写法形式下缓冲流的性能执行情况。

    复制流：
        （1）使用低级的字节流按照一个一个字节的形式复制文件。
        （2）使用低级的字节流按照一个一个字节数组的形式复制文件。
        （3）使用高级的缓冲字节流按照一个一个字节的形式复制文件。
        （4）使用高级的缓冲字节流按照一个一个字节数组的形式复制文件。

    源文件：D:\itcast\班级\Java就业班123期\就业班-day10-属性集，缓冲流、转换流、序列化流\01.知识回顾.wmv
    目标文件：D:\itcast\班级\

    小结：
        缓冲字节流按照数组读写数据性能真的很好：以后建议使用。
 */
public class CopyDemo {
    public static final String SRC_FILE = "D:\\itcast\\班级\\Java就业班123期\\就业班-day10-属性集，缓冲流、转换流、序列化流\\01.知识回顾.wmv";
    public static final String DEST_FIlE = "D:\\itcast\\班级\\";
    public static void main(String[] args) {
        // copy01(); // 低级流一个一个字节的复制慢的简直让人无法忍受，直接淘汰！！
        copy02(); // 低级的字节流按照一个一个字节数组复制:速度还可以勉强接受
        copy03(); // 高级的字节缓冲流按照一个一个字节复制:速度也不太能接受，比较慢！
        copy04(); // 高级的字节缓冲流按照一个一个字节数组复制: 非常好！建议使用！
    }

    /**
     *（4）使用高级的缓冲字节流按照一个一个字节数组的形式复制文件。
     */
    public static void copy04(){
        long startTimer = System.currentTimeMillis();
        try(
                // a.定义一个低级的字节输入流与源文件接通
                InputStream is = new FileInputStream(SRC_FILE);
                BufferedInputStream bis = new BufferedInputStream(is);
                // b.定义一个低级的字节输出流与目标文件接通
                OutputStream os = new FileOutputStream(DEST_FIlE+"04.wmv");
                BufferedOutputStream bos = new BufferedOutputStream(os);
        ){
            // 定义一个字节数组进行文件数据的复制
            byte[] buffer = new byte[1024];
            int len ;
            while((len = bis.read(buffer))!=-1){
                bos.write(buffer,0,len);
            }

        }catch (Exception e){
            e.printStackTrace();
        }
        long endTimer = System.currentTimeMillis();
        System.out.println("高级的字节缓冲流按照一个一个字节数组复制："+(endTimer - startTimer)/1000.0 +"s");
    }

    /**
     *（3）使用高级的缓冲字节流按照一个一个字节的形式复制文件。
     */
    public static void copy03(){
        long startTimer = System.currentTimeMillis();
        try(
                // a.定义一个低级的字节输入流与源文件接通
                InputStream is = new FileInputStream(SRC_FILE);
                BufferedInputStream bis = new BufferedInputStream(is);
                // b.定义一个低级的字节输出流与目标文件接通
                OutputStream os = new FileOutputStream(DEST_FIlE+"03.wmv");
                BufferedOutputStream bos = new BufferedOutputStream(os);
        ){
            // c.定义一个变量存储一个字节
            int bt ;
            while((bt = bis.read())!=-1){
                bos.write(bt);
            }
        }catch (Exception e){
            e.printStackTrace();
        }
        long endTimer = System.currentTimeMillis();
        System.out.println("高级的字节缓冲流按照一个一个字节复制："+(endTimer - startTimer)/1000.0 +"s");
    }


    /**
     *（2）使用低级的字节流按照一个一个字节数组的形式复制文件。
     */
    public static void copy02(){
        long startTimer = System.currentTimeMillis();
        try(
                // a.定义一个低级的字节输入流与源文件接通
                InputStream is = new FileInputStream(SRC_FILE);
                // b.定义一个低级的字节输出流与目标文件接通
                OutputStream os = new FileOutputStream(DEST_FIlE+"02.wmv");
        ){
            // 定义一个字节数组进行文件数据的复制
            byte[] buffer = new byte[1024];
            int len ;
            while((len = is.read(buffer))!=-1){
                os.write(buffer,0,len);
            }

        }catch (Exception e){
            e.printStackTrace();
        }
        long endTimer = System.currentTimeMillis();
        System.out.println("低级的字节流按照一个一个字节数组复制："+(endTimer - startTimer)/1000.0 +"s");
    }

    /**
     *（1）使用低级的字节流按照一个一个字节的形式复制文件。
     */
    public static void copy01(){
        long startTimer = System.currentTimeMillis();
        try(
                // a.定义一个低级的字节输入流与源文件接通
                InputStream is = new FileInputStream(SRC_FILE);
                // b.定义一个低级的字节输出流与目标文件接通
                OutputStream os = new FileOutputStream(DEST_FIlE+"01.wmv");
                ){
            // c.定义一个变量存储一个字节
            int bt ;
            while((bt = is.read())!=-1){
                os.write(bt);
            }
        }catch (Exception e){
            e.printStackTrace();
        }
        long endTimer = System.currentTimeMillis();
        System.out.println("低级的字节流按照一个一个字节复制："+(endTimer - startTimer)/1000.0 +"s");
    }
}
```
# 字符缓冲流
## 字符缓冲输入流
```java
/**

 目标：字符缓冲输入流的使用。

            字节流                                     字符流
 字节输入流               字节输出流              字符输入流         字符输出流
 InputStream             OutputStream          Reader            Writer   (抽象类)
 FileInputStream         FileOutputStream      FileReader        FileWriter(实现类)
 BufferedInputStream     BufferedOutputStream  BufferedReader    BufferedWriter(实现类，缓冲流)

 字符缓冲输入流：BufferedReader
      -- 作用：字符缓冲输入流可以把字符输入流包装成一个高级的缓冲字符输入流，
               可以提高字符输入流读数据的性能。
      -- 构造器：public BufferedReader(Reader reader):
      -- 原理：缓冲字符输入流默认会有一个8K的字符缓冲池,可以提高读字符的性能。
      -- 缓冲字符输入流除了提高了字符输入流的读数据性能，还多了一个按照行读取数据的功能（重点）
         public String readLine(): 读取一行数据返回，读取完毕返回null;
 小结：
        缓冲字符输入流提高了字符输入流读取文本文件内容的性能，同时
        它还多了一个按照行读取内容的方法，建议使用。
 */
public class BufferedReaderDemo01 {
    public static void main(String[] args) throws Exception {
        // 1.定义一个低级的字符输入流与源文件接通
        Reader fr = new FileReader("src/dlei03.txt");

        // 3.把低级的字符输入流包装成一个高级的缓冲字符输入流(经典代码)
        BufferedReader br = new BufferedReader(fr);
        // 定义一个字符串变量存储行数据
        String line ;
        while((line = br.readLine())!=null){
            System.out.println(line);
        }


        // 2.定义一个字符数组读取文本内容
//        char[] buffer = new char[1024];
//        int len = 0 ;
//        while((len = br.read(buffer)) != -1 ) {
//            System.out.print(new String(buffer,0,len));
//        }

    }
}
```
## 字符缓冲输出流
```java
/**
     目标：字符缓冲输出流的使用。

            字节流                              字符流
     字节输入流               字节输出流              字符输入流         字符输出流
     InputStream             OutputStream          Reader            Writer   (抽象类)
     FileInputStream         FileOutputStream      FileReader        FileWriter(实现类)
     BufferedInputStream     BufferedOutputStream  BufferedReader    BufferedWriter(实现类，缓冲流)

     字符缓冲输出流：BufferedWriter
            -- 作用：把字符输出流包装成一个高级的缓冲字符输出流，提高写字符数据的性能。
            -- 构造器：public BufferedWriter(Writer writer):
            -- 原理：高级的字符缓冲输出流多了一个8k的字符缓冲池，写数据性能极大提高了!
            -- 字符缓冲输出流除了提高字符输出流写数据的性，还多了一个换行的特有功能：
                 public void newLine()：新建一行。
     小结：
         字符缓冲输出流除了提高字符输出流写数据的性，还多了一个换行的特有功能：
         public void newLine()：新建一行。

 */
public class BufferedWriterDemo02 {
    public static void main(String[] args) throws Exception {
        // 1.定义一个低级的字符输出流通向目标文件。
        Writer fw = new FileWriter("src/dlei04.txt");

        // 3.把低级的字符输出流包装成一个高级的缓冲字符输出流。
        BufferedWriter bw = new BufferedWriter(fw);

        // 2.写数据出去
        bw.write("我爱中国");
        bw.newLine(); // 换行！
        bw.write("黑马");

        bw.close();
    }
}
```
## 案例
```java
/**
    目标：题目练习。

    需求：把《出师表》的文章顺序进行恢复。

    分析：
        （1）定义一个List集合存储文章的每段内容。
        （2）开始定义一个缓冲字符输入流读取文章的每行内容，添加到List集合中。
        （3）对List集合中的每个元素按照首字符排序。
        （4）遍历List集合中的每个元素。
        （5）定义一个缓冲字符输出流把每个元素写出去。
 */
public class ExecDemo {
    public static void main(String[] args) throws Exception {
        // （1）定义一个List集合存储文章的每段内容。
        List<String> datas = new ArrayList<>();

        // （2）开始定义一个缓冲字符输入流读取文章的每行内容，添加到List集合中。
        BufferedReader br = new BufferedReader(new FileReader("src/csb"));


        //  开始循环按照行读取文章的每段内容
        String line ;
        while((line = br.readLine())!=null){
            datas.add(line);
        }
        System.out.println(datas);

        // 自定义大小比较规则。
        List<String> cnSizes = new ArrayList<>();
        Collections.addAll(cnSizes,"零","一","二","三","四","五","六","七","八","九","十");


        // （3）对List集合中的每个元素按照首字符排序。
        Collections.sort(datas, new Comparator<String>() {
            @Override
            public int compare(String o1, String o2) {
                // o1 : 三,.....
                // o2 : 七,.....
                return cnSizes.indexOf(o1.charAt(0)+"") - cnSizes.indexOf(o2.charAt(0)+"");
            }
        });
        System.out.println(datas);

        // （5）定义一个缓冲字符输出流把每个元素写出去。
        BufferedWriter bw = new BufferedWriter(new FileWriter("src/csb"));
        // （4）遍历List集合中的每个元素。
        for(String ln : datas){
            bw.write(ln);
            bw.newLine(); // 换行
        }

        br.close();
        bw.close();
    }
}
```
## 字符流不同编码读取乱码的问题
```markdown
字符流读取文本文件内容如果代码编码与文件编码不一致，一定会乱码！
```

```java
public class ReaderDemo {
    public static void main(String[] args) throws Exception {
        // 不会乱码：代码编码：UTF-8   文件编码：UTF-8
        //  会乱码： 代码编码：UTF-8   文件编码：GBK

        // 1.定义一个低级的字符输入流与源文件接通
        Reader fr = new FileReader("D:\\itcast\\网络编程公开课\\Netty.txt");

        // 2.把低级的字符输入流包装成一个高级的缓冲字符输入流(经典代码)
        BufferedReader br = new BufferedReader(fr);
        // 定义一个字符串变量存储行数据
        String line ;
        while((line = br.readLine())!=null){
            System.out.println(line);
        }
    }
}
```
# 转换流
## 字符输入转换流
```java
/**
     目标：字符输入转换InputStreamReader流的使用。

             字节流                                     字符流
     字节输入流               字节输出流              字符输入流            字符输出流
     InputStream             OutputStream          Reader               Writer   (抽象类)
     FileInputStream         FileOutputStream      FileReader           FileWriter(实现类)
     BufferedInputStream     BufferedOutputStream  BufferedReader       BufferedWriter(实现类，缓冲流)
                                                   InputStreamReader    OutputStreamWriter
     字符输入转换InputStreamReader:
          -- 作用：可以把原始的字节流按照当前默认的代码编码转换成字符输入流。
                  可以把原始的字节流按照指定编码转换成字符输入流
          -- 构造器：
                public InputStreamReader(InputStream is)：可以使用当前代码默认编码转换成字符流，几乎不用！
                public InputStreamReader(InputStream is,String charset):可以指定编码把字节流转换成字符流
     小结：
           字符输入转换流可以指定编码把字节流转换成字符输入流从而
           解决了：不同编码读取乱码的问题。

           只要保证了读字符没有乱码，那么以后就永远不会乱码！！


 */
public class InputStreamReaderDemo01 {
    public static void main(String[] args) throws Exception {
        // 我爱你：oo oo oo
        InputStream is = new FileInputStream("D:\\itcast\\网络编程公开课\\Netty.txt");
        // 把原始的字节流按照当前默认的代码编码转换成字符输入流:UTF-8
        // Reader fr = new InputStreamReader(is);

        // 可以把原始的字节流按照指定编码转换成字符输入流
        Reader fr = new InputStreamReader(is,"GBK");

        // 把字符输入流包装成缓冲字符输入流
        BufferedReader br = new BufferedReader(fr);
        // 定义一个字符串变量存储行数据
        String line ;
        while((line = br.readLine())!=null){
            System.out.println(line);
        }
    }
}

```
## 字符转换输出流
```java
/**
     目标：字符输出转换OutputStreamWriter流的使用。

                字节流                                     字符流
     字节输入流               字节输出流              字符输入流            字符输出流
     InputStream             OutputStream          Reader               Writer   (抽象类)
     FileInputStream         FileOutputStream      FileReader           FileWriter(实现类)
     BufferedInputStream     BufferedOutputStream  BufferedReader       BufferedWriter(实现类，缓冲流)
                                                   InputStreamReader    OutputStreamWriter

     字符输出转换流：OutputStreamWriter
           -- 作用：可以指定编码把字节输出流转换成字符输出流。
           -- 构造器：
                public OutputStreamWriter(OutputStream os):用当前默认编码UTF-8把字节输出流转换成字符输出流
                public OutputStreamWriter(OutputStream os,String charset):指定编码把字节输出流转换成字符输出流
     小结：
        OutputStreamWriter字符输出转换流可以指定编码把字节输出流转换成字符输出流
        从而可以实现：指定编码写内容出去。
 */
public class OutputStreamWriterDemo02 {
    public static void main(String[] args) throws Exception {
        // 写数据
        OutputStream os = new FileOutputStream("src/dlei06.txt");
        // 用当前默认编码UTF-8把字节输出流转换成字符输出流
        // Writer fw = new OutputStreamWriter(os);

        // 指定编码把字节输出流转换成字符输出流
        Writer fw = new OutputStreamWriter(os,"GBK");

        fw.write("我在黑马快乐的黑老师！");
        fw.close();

    }
}
```
# 序列化
```java
/**
     目标:对象序列化技术。

     对象序列化：就是把Java对象数据直接存储到文件中去。           对象 => 文件中
     对象反序列化：把Java对象的文件数据恢复到Java对象中。         文件中 => 对象

                   字节流                                   字符流
     字节输入流               字节输出流              字符输入流          字符输出流
     InputStream             OutputStream          Reader             Writer   (抽象类)
     FileInputStream         FileOutputStream      FileReader         FileWriter(实现类)
     BufferedInputStream     BufferedOutputStream  BufferedReader     BufferedWriter(实现类，缓冲流)
                                                   InputStreamReader  OutputStreamWriter
     ObjectInputStream       ObjectOutputStream

     对象序列化流（对象字节输出流）：ObjectOutputStream
         -- 作用：把对象数据保存到文件中去。
         -- 构造器：    public ObjectOutputStream(OutputStream out)
         -- 序列化方法： public final void writeObject(Object obj)
         注意：如果对象要序列化，对象必须实现序列化接口：implements Serializable

     小结：
        对象序列化是把Java对象存储到文件中去。
        对象序列化使用的流：对象字节输出流ObjectOutputStream
        如果对象要序列化，对象必须实现序列化接口：implements Serializable
 */
public class SerializeDemo01 {
    public static void main(String[] args) throws Exception {
        // 1.创建一个User对象
        User user = new User("泷泽萝拉","dongjing-lzll","15longze",21);
        // 2.定义一个低级的字节输出流通向目标文件对象
        OutputStream os = new FileOutputStream("src/obj.dat");
        // 3.把低级的字节输出流包装成一个高级的对象字节输出流
        ObjectOutputStream oos = new ObjectOutputStream(os);
        // 4.开始序列化对象
        oos.writeObject(user);

        System.out.println("序列化完成！！");
    }
}
```
# 反序列化
```java
/**
     目标:对象序反列化技术。

     序列化：就是把Java对象数据直接存储到文件中去。           对象 => 文件中
     反序列化：把Java对象的文件数据恢复到Java对象中。         文件中 => 对象

                   字节流                                   字符流
     字节输入流               字节输出流              字符输入流          字符输出流
     InputStream             OutputStream          Reader             Writer   (抽象类)
     FileInputStream         FileOutputStream      FileReader         FileWriter(实现类)
     BufferedInputStream     BufferedOutputStream  BufferedReader     BufferedWriter(实现类，缓冲流)
                                                   InputStreamReader  OutputStreamWriter
     ObjectInputStream       ObjectOutputStream

     对象反序列化（对象字节输入流）：ObjectInputStream
            -- 作用：读取序列化的对象文件恢复到Java对象中。
            -- 构造器：public ObjectInputStream(InputStream is)
            -- 方法：public final Object readObject()
            注意：transient:修饰的成员变量将不参与序列化！！
             // 对象加入序列版本号
             private static final long serialVersionUID = 2L;
             反序列化使用的对象版本号必须与序列化使用的版本号一致才不会报错

 */
public class SerializeDemo02 {
    public static void main(String[] args) throws Exception {
        // 1.定义一个字节输入流与Java对象的源文件接通
        InputStream is = new FileInputStream("src/obj.dat");

        // 2.把低级的字节输入流包装成高级的对象字节输入流
        ObjectInputStream ois = new ObjectInputStream(is);

        // 3.反序列对象出来
        User user = (User) ois.readObject();

        System.out.println(user);
    }
}
public class User implements Serializable {

    // 加入序列版本号
    private static final long serialVersionUID = 2L;

    private String name;
    private String loginName;
    // transient:修饰的成员变量将不参与序列化！！
    private transient String passWord ;
    private int age ;

    public User() {
    }

    public User(String name, String loginName, String passWord, int age) {
        this.name = name;
        this.loginName = loginName;
        this.passWord = passWord;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getLoginName() {
        return loginName;
    }

    public void setLoginName(String loginName) {
        this.loginName = loginName;
    }

    public String getPassWord() {
        return passWord;
    }

    public void setPassWord(String passWord) {
        this.passWord = passWord;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "User{" +
                "name='" + name + '\'' +
                ", loginName='" + loginName + '\'' +
                ", passWord='" + passWord + '\'' +
                ", age=" + age +
                '}';
    }
}
```
# 打印流
```java
/**
    目标：打印流PrintStream/PrintWriter

    作用：可以“方便且高效”的写数据出去。

    PrintStream/PrintWriter:
        构造器：public PrintStream(OutputStream os):
        构造器：public PrintStream(String filePath):
        方法：public void println(Xxx x):打印各种类型的数据

    PrintStream：不仅可以打印数据出去，可以写字节数据出去。
    PrintWriter：不仅可以打印数据出去，可以写字符数据出去。

    小结：
         PrintStream/PrintWriter在打印数据的功能上是一样的：高效且方便。
         PrintStream：不仅可以打印数据出去，可以写字节数据出去。
         PrintWriter：不仅可以打印数据出去，可以写字符数据出去。

 */
public class PrintStreamDemo01 {
    public static void main(String[] args) throws Exception {
        //OutputStream os = new FileOutputStream("src/dlei07.txt");
        //PrintStream ps = new PrintStream(os);
        // 简化写法：直接通向文件打印数据，更方便。
        PrintStream ps = new PrintStream("src/dlei07.txt");

        // 打印数据出去
        ps.println(97); // 打印整数97.
        ps.println(false);
        ps.println("我爱你中国");
        ps.println('a');
        ps.println(100000L);
        ps.close();
    }
}
```
## 打印流实现重定向
```java
/**
    目标：打印流实现重定向。
 */
public class PrintStreamDemo02 {
    public static void main(String[] args) throws Exception {
        System.out.println("---itheima欢度国庆--");
        System.out.println("---游泳，注意安全--");

        PrintStream ps = new PrintStream("src/log.txt");
        // 让系统的输出流向打印流
        System.setOut(ps);

        System.out.println("---itheima欢度国庆--");
        System.out.println("---游泳，注意安全--");
        System.out.println("---游泳，注意安全--");
        System.out.println("---游泳，注意安全--");
        System.out.println("---打代码----");
    }
}
```
# 属性集对象
```java
/**

    目标：Properties的概述和使用。（保存数据到属性文件）

    Properties：属性集对象。
    其实就是一个Map集合。也就是一个键值对集合。但是我们一般不会当集合使用，因为有HashMap。
    Properties核心作用：
         Properties代表的是一个属性文件，可以把键值对的数据存入到一个属性文件中去。
         属性文件：后缀是.properties结尾的文件,里面的内容都是 key=value。

    大家在后期学的很多大型框架技术中，属性文件都是很重要的系统配置文件。

    需求：生成一个属性文件，里面存入用户名和密码信息。

     Properties的方法：
     -- public Object setProperty(String key, String value) ： 保存一对属性。
     -- public String getProperty(String key) ：使用此属性列表中指定的键搜索属性值
     -- public Set<String> stringPropertyNames() ：所有键的名称的集合
     -- public void store(OutputStream out, String comments):保存数据到属性文件中去
     -- public void store(Writer fw, String comments):保存数据到属性文件中去
 */
public class PropertiesDemo01 {
    public static void main(String[] args) throws Exception {
        // 1.创建一个属性集对象
        Properties pro = new Properties();
        // 2.存入用户名和密码
        pro.setProperty("user","dlei");
        pro.setProperty("password","003197");
        System.out.println(pro);

        // 3.把属性对象pro中的键值对数据存储到一个属性文件中去：生成配置文件。
        /**
         * 参数一：被保存的字节输出流管道
         * 参数二：保存心得
         */
        pro.store(new FileOutputStream("src/users.properties"),"我在国庆前快乐的保存了一个密码，I am very happy!!");
        System.out.println("保存完成!");
    }
}
```
## 读取属性文件中的键值对信息
```java
/**
    目标：Properties读取属性文件中的键值对信息。（读取）

    Properties的方法：
        -- public Object setProperty(String key, String value) ： 保存一对属性。
        -- public String getProperty(String key) ：使用此属性列表中指定的键搜索属性值
        -- public Set<String> stringPropertyNames() ：所有键的名称的集合
        -- public void store(OutputStream out, String comments):保存数据到属性文件中去
        -- public synchronized void load(InputStream inStream):加载属性文件的数据到属性集对象中去
        -- public synchronized void load(Reader fr):加载属性文件的数据到属性集对象中去

 */
public class PropertiesDemo02 {
    public static void main(String[] args) throws Exception {
        // 1.创建一个属性集对象
        Properties pro = new Properties();
        // 2.加载属性文件中的键值对数据到属性集对象pro中去。
        pro.load(new FileInputStream("src/users.properties"));
        // 3.输出
        System.out.println(pro);
        System.out.println(pro.getProperty("user"));
        System.out.println(pro.getProperty("password"));
    }
}
```
# Socket网络通信
## 软件结构
```java
/**
    目标：软件结构。

    通信一定是基于软件结构实现的:
        1.C/S结构 ：全称为Client/Server结构，是指客户端和服务器结构。
            常见程序有ＱＱ、迅雷等软件。

        2.B/S结构 ：全称为Browser/Server结构，是指浏览器和服务器结构。
            常见浏览器有谷歌、火狐等、博学谷、京东、淘宝。
            （开发中的重点，基于网页设计界面，界面效果可以更丰富,Java Web开发）

    两种架构各有优势，但是无论哪种架构，都离不开网络的支持。网络编程，
        就是在一定的协议下，实现两台计算机的通信的技术。

    小结：
        软件结构离不开通信和协议。

 */
```
## 网络通信的三要素
```java
/**
    目标：网络通信的三要素。

    1.协议
        协议：计算机网络客户端与服务端通信必须事先约定和彼此遵守的通信规则。
        HTTP , FTP , TCP , UDP , SSH , SMTP。


    2.IP地址：指互联网协议地址（Internet Protocol Address），俗称IP。
            IP地址用来给一个网络中的计算机设备做唯一的编号.

      IPv4:4个字节，32位组成。  192.168.98.79
            局域网，
            城域网
            广域网（公网）

            局域网：公司内部用。
            公网：可以在任何地方访问。


      IPv6: 可以实现为所有设备分配IP  128位

      ipconfig：查看本机的IP
      ping:检查本机与某个IP指定的机器是否联通，或者说是检测对方是否在线。
      ping 空格 IP地址
      ping 220.181.57.216
      ping www.baidu.com

      注意：特殊的IP地址： 本机IP地址  127.0.0.1 == localhost。

    3.端口：
        端口号就可以唯一标识设备中的进程（应用程序）了
        端口号：
        用两个字节表示的整数，它的取值范围是0~65535。
        0~1023之间的端口号用于一些知名的网络服务和应用。
        普通的应用程序需要使用1024以上的端口号。
        如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败。报出端口被占用异常！！

        利用`协议`+`IP地址`+`端口号` 三元组合，
        就可以标识网络中的进程了，那么进程间的通信就可以利用这个标识与其它进程进行交互。

    小结：
        通信的三要素：协议，IP，端口。
 */
```
## 网络通信分层和协议
```java
/**
    目标：网络通信的分层和协议。

    网络通信协议：通信协议是对计算机必须遵守的规则，
    只有遵守这些规则，计算机之间才能进行通信。

    -------------------------------------------------------------------------------
    应用层  ：应用程序（QQ,微信,浏览器）,可能用到的协议（HTTP,FTP,SMTP）   通常程序员只需要关心这一层
    ------------------------------------------------------------------------------
    传输层  ：TCP/IP协议 - UDP协议    计算机网络工程师需要精通的协议，有些技术我们也需要精通这一层协议，
                                    以后再学习！
    --------------------------------------------------------------
    网络层  ：IP协议  封装自己的IP和对方的IP和端口
    --------------------------------------------------------------
    数据链路层 ： 进入到硬件（网）
    物理层
    --------------------------------------------------------------

    TCP/IP协议：传输控制协议 (Transmission Control Protocol)。
        TCP协议是面向连接的安全的可靠的传输通信协议。
        1.在通信之前必须确定对方在线并且连接成功才可以通信。
        2.例如下载文件、浏览网页等(可靠传输)

    UDP：用户数据报协议(User Datagram Protocol)。
        UDP协议是一个面向无连接的不可靠传输的协议。
        1.直接发消息给对象，不管对方是否在线，发消息后也不需要确认。
        2.无线（视频会议，通话），性能好，丢失一些数据！！

 */
```
## InetAddress类
```java
/**
    目标：InetAddress类概述
         一个该类的对象就代表一个IP地址对象。

    InetAddress类成员方法
         static InetAddress getLocalHost()
            * 获得本地主机IP地址对象
         static InetAddress getByName(String host)
            * 根据IP地址字符串或主机名获得对应的IP地址对象

         String getHostName();获得主机名
         String getHostAddress();获得IP地址字符串
 */
public class InetAddressDemo01 {
    public static void main(String[] args) throws Exception {
        // 1.获取本机IP地址
        InetAddress ip1 = InetAddress.getLocalHost();
        System.out.println(ip1.getHostName());
        System.out.println(ip1.getHostAddress());

        // 2.获取指定主机的IP
        InetAddress ip2 = InetAddress.getByName("www.baidu.com");
        System.out.println(ip2.getHostName());
        System.out.println(ip2.getHostAddress());

        // 3.测试与该IP主机是否可联通
        // 在5s内测试本机与该IP地址是否可以联通。
        System.out.println(ip1.isReachable(5000));  // ping ip1
        System.out.println(ip2.isReachable(5000)); // ping  ip2
    }
}
```
## UDP通信
```java
/**
     目标：UDP通信的使用介绍(了解即可)

     UDP协议的特点
         * 面向无连接的协议
         * 发送端只管发送，不确认对方是否能收到。
         * 基于数据包进行数据传输。
         * 发送数据的包的大小限制64KB以内
         * 因为面向无连接，速度快，但是不可靠。会丢失数据！

     UDP协议的使用场景
         * 在线视频
         * 网络语音电话

     UDP协议相关的两个类
         * DatagramPacket
             * 数据包对象
             * 作用：用来封装要发送或要接收的数据，比如：集装箱
         * DatagramSocket
             * 发送对象
             * 作用：用来发送或接收数据包，比如：码头

     DatagramPacket类构造器
         DatagramPacket(byte[] buf, int length, InetAddress address, int port)
              创建发送端数据包对象
         * buf：要发送的内容，字节数组
         * length：要发送内容的长度，单位是字节
         * address：接收端的IP地址对象
         * port：接收端的端口号

         DatagramPacket(byte[] buf, int length)
         * 创建接收端的数据包对象
         * buf：用来存储接收到内容
         * length：能够接收内容的长度

     DatagramPacket类常用方法
         * int getLength() 获得实际接收到的字节个数

     DatagramSocket类构造方法
         * DatagramSocket() 创建发送端的Socket对象，系统会随机分配一个端口号。
         * DatagramSocket(int port) 创建接收端的Socket对象并指定端口号

     DatagramSocket类成员方法
         * void send(DatagramPacket dp) 发送数据包
         * void receive(DatagramPacket p) 接收数据包

     需求：使用UDP实现客户端发，服务端收。

 */
public class UDPClientDemo01 {
    public static void main(String[] args) throws Exception {
        // 1.创建一个码头对象，发送数据包的对象。 DatagramSocket
        // DatagramSocket() 创建发送端的Socket对象，系统会随机分配一个端口号。
        DatagramSocket socket = new DatagramSocket(7777);

        // 2.创建一个集装箱对象,一个发送的数据包
        //  DatagramPacket(byte[] buf, int length, InetAddress address, int port)
        /**
         * 参数一：封装的发送数据的字节数组。
         * 参数二：发送数据的大小。
         * 参数三：对方服务器的IP地址。
         * 参数四：对方的端口号码。
         */
        byte[] msg = "今晚约吗？吃小龙虾".getBytes();
        DatagramPacket packet = new DatagramPacket(msg
                ,msg.length , InetAddress.getLocalHost() , 9999);

        // 3.发送集装箱
        socket.send(packet);

        socket.close();
    }
}
/**
 * 服务器
 */
public class UDPServerDemo02 {
    public static void main(String[] args) throws Exception {
        // 1.创建一个接收数据包的socket对象:码头对象
        // 必须注册端口：9999
        DatagramSocket socket = new DatagramSocket(9999);

        // 2.创建一个数据包对象：集装箱对象收客户端发来的数据包数据。
        //  DatagramPacket(byte[] buf, int length)
        byte[] buffer = new byte[64*1024];
        /**
         * 参数一：接收数据的桶
         * 参数二：接收数据的桶的大小
         */
        DatagramPacket packet = new DatagramPacket(buffer , buffer.length);

        // 3.正式接收客户端的数据
        socket.receive(packet);

        // 4.获取本次接收了多少数据
        int len = packet.getLength();

        // 5.把桶中的数据转换成字符串输出即可
        // 收多少倒出多少
        String rs = new String(buffer,0,len);
        System.out.println(rs);

        // 6.知道对方客户端的信息。
        int port = packet.getPort();
        String ip = packet.getSocketAddress().toString();
        System.out.println(ip+"->"+port);
    }
}
```
## Socket网络编程入门案例
```java
/**
    目标：Socket网络编程入门案例。

    只要Java代码是基于Socket类开发的，那么底层就是基于TCP可以传输通信。

    客户端类：Socket:通信管道，套接字（端到端）
        包：java.net.Socket.
        构造器：
            public Socket(String ip , int port):
        方法：
            public OutputStream getOutputStream()
            public InputStream getInputStream()

    服务端类：ServerSocket
        构造器：public ServerSocket(int port)：注册端口
        方法：public Socket accept()：接收客户端的Socket连接，返回一个管道Socket对象。

    需求1：实现客户端发送，服务端接收。

    客户端开发流程：
         1.先请求于服务端的Socket通信管道连接。
         2.从Socket通信管道中得到一个字节输出流。
         3.通过字节输出流写数据出去。

    服务端的开发流程：
         1.注册端口
         2.开始接收客户端的Socket管道连接。
         3.从Socket管道中得到一个字节输入流。
         4.从字节输入流读取客户端发来的数据。

    小结：
        客户端：Socket
        服务端：ServerSocket.
        通信是很严格的：对方怎么发，你就必须怎么收，对方的Socket管道挂了，你与对方想好的Socket管道也会挂。
 */
public class ClientDemo01 {
    public static void main(String[] args) throws Exception {
        System.out.println("启动客户端。。。。。");
        //  1.先请求于服务端的Socket通信管道连接。
        Socket socket = new Socket("192.168.98.79" , 9999);
        //  2.从Socket通信管道中得到一个字节输出流。
        OutputStream os = socket.getOutputStream();
        //  3.把低级的字节输出流包装成高级的打印流
        PrintStream ps = new PrintStream(os);
        //  4.发送消息
        ps.println("服务端你好，我是客户端，我想泡你很久了！！");
        ps.flush(); // 刷新
    }
}
```

```java
/**
 * 服务端开发.
 *          1.注册端口
 *          2.开始接收客户端的Socket管道连接。
 *          3.从Socket管道中得到一个字节输入流。
 *          4.从字节输入流读取客户端发来的数据。
 */
public class ServerDemo02 {
    public static void main(String[] args) throws Exception {
        System.out.println("服务端启动。。。。");
        // 1.注册端口
        ServerSocket ss = new ServerSocket(9999);
        // 2.开始等待接收客户端的Socket管道连接。
        Socket socket = ss.accept();
        // 3.从Socket管道中得到一个字节输入流。
        InputStream is = socket.getInputStream();
        // 4.从字节输入流读取客户端发来的数据。
        BufferedReader br = new BufferedReader(new InputStreamReader(is));
        String line ;
        if((line = br.readLine())!=null){
            System.out.println("收到："+socket.getRemoteSocketAddress()+":"+line);
        }
    }
}
```
## 实现客户端可以反复发消息，服务端可以反复的接收消息
```java
/**
    目标：实现客户端可以反复发消息，服务端可以反复的接收消息。

    这种架构下：只能接收一个客户端的连接。
 */
public class ClientDemo01 {
    public static void main(String[] args) throws Exception {
        System.out.println("启动客户端。。。。。");
        //  1.先请求于服务端的Socket通信管道连接。
        Socket socket = new Socket("192.168.98.79" , 9999);
        //  2.从Socket通信管道中得到一个字节输出流。
        OutputStream os = socket.getOutputStream();
        //  3.把低级的字节输出流包装成高级的打印流
        PrintStream ps = new PrintStream(os);
        //  4.定义一个循环让用户输入消息发送
        Scanner sc = new Scanner(System.in);
        while(true){
            System.out.print("说：");
            String msg = sc.nextLine();
            ps.println(msg);
            ps.flush();
        }
    }
}
```

```java
/**
 * 服务端开发.
 *          1.注册端口
 *          2.开始接收客户端的Socket管道连接。
 *          3.从Socket管道中得到一个字节输入流。
 *          4.从字节输入流读取客户端发来的数据。
 */
public class ServerDemo02 {
    public static void main(String[] args) throws Exception {
        System.out.println("服务端启动。。。。");
        // 1.注册端口
        ServerSocket ss = new ServerSocket(9999);
        // 2.开始等待接收客户端的Socket管道连接。
        Socket socket = ss.accept();
        // 3.从Socket管道中得到一个字节输入流。
        InputStream is = socket.getInputStream();
        // 4.从字节输入流读取客户端发来的数据。
        BufferedReader br = new BufferedReader(new InputStreamReader(is));
        String line ;
        while((line = br.readLine())!=null){
            System.out.println("收到："+socket.getRemoteSocketAddress()+":"+line);
        }
    }
}
```

## 实现一个服务端可以接收多个客户端
```java
/**
    目标：实现一个服务端可以接收多个客户端。

    解决思路：服务端每接收到一个客户端管道以后就交给一个独立的线程来处理。
        如此即可接收多个客户端的通信。
 */
public class ClientDemo01 {
    public static void main(String[] args) throws Exception {
        System.out.println("启动客户端。。。。。");
        //  1.先请求于服务端的Socket通信管道连接。
        Socket socket = new Socket("192.168.98.79" , 8888);
        //  2.从Socket通信管道中得到一个字节输出流。
        OutputStream os = socket.getOutputStream();
        //  3.把低级的字节输出流包装成高级的打印流
        PrintStream ps = new PrintStream(os);
        //  4.定义一个循环让用户输入消息发送
        Scanner sc = new Scanner(System.in);
        while(true){
            System.out.print("说：");
            String msg = sc.nextLine();
            ps.println(msg);
            ps.flush();
        }
    }
}
```

```java
public class ServerDemo02 {
    public static void main(String[] args) throws Exception {
        System.out.println("服务端启动。。。。");
        // 1.注册端口
        ServerSocket ss = new ServerSocket(8888);
        while(true){
            // 2.开始等待接收客户端的Socket管道连接。
            Socket socket = ss.accept();
            // 3.为当前客户端管道管道创建一个独立的线程来处理与它的通信。
            new ServerReaderThread(socket).start();
            // 有人上线
            System.out.println(socket.getRemoteSocketAddress()+"上线了！");
        }
    }
}

class ServerReaderThread extends Thread{
    private Socket socket;
    public ServerReaderThread(Socket socket){
        this.socket = socket;
    }
    @Override
    public void run() {
        try{
            // 3.从Socket管道中得到一个字节输入流。
            InputStream is = socket.getInputStream();
            // 4.从字节输入流读取客户端发来的数据。
            BufferedReader br = new BufferedReader(new InputStreamReader(is));
            String line ;
            while((line = br.readLine())!=null){
                System.out.println("收到："+socket.getRemoteSocketAddress()+":"+line);
            }
        }catch (Exception e){
            System.out.println(socket.getRemoteSocketAddress()+"下线了！");
        }
    }
}
```

## 引入线程池，解决通信架构（伪异步通信）
```java
/**
 	拓展：引入线程池，解决通信架构（伪异步通信）

 	我们之前是采用一个客户端对应一个线程：N-N的模型。
 	这样在高并发下，用户越多，系统死的越快。这种架构：不合适。

 	可以在服务端引入线程池来解决处理多个客户端的消息。
	这样服务端的线程将受到控制，不会因为创建过多线程而引起系统死机：比较合适。具有一定的使用价值。


 */
public class Client {
	public static void main(String[] args) {
		try {
			// 1.简历一个与服务端的Socket对象：套接字
			Socket socket = new Socket("127.0.0.1", 7878);
			// 2.从socket管道中获取一个输出流，写数据给服务端 
			OutputStream os = socket.getOutputStream() ;
			// 3.把低级的字节输出流包装成高级的打印流
			PrintStream ps = new PrintStream(os);
			// 4.定义一个循环让用户输入消息发送
			Scanner sc = new Scanner(System.in);
			while(true){
				System.out.print("说：");
				String msg = sc.nextLine();
				ps.println(msg);
				ps.flush();
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}
// 线程池处理类
public class HandlerSocketThreadPool {

    // 线程池 
    private ExecutorService executor;


    // 线程池：最大保存数量，最大支持线程数量,最大任务数量。
    public HandlerSocketThreadPool(int maxPoolSize, int queueSize){
        this.executor = new ThreadPoolExecutor(
                maxPoolSize, // 3
                maxPoolSize, // 3
                120L,
                TimeUnit.SECONDS,
                new ArrayBlockingQueue<Runnable>(queueSize) );// 100
    }

    public void execute(Runnable task){
        this.executor.execute(task);
    }
}
class ReaderClientRunnable implements Runnable{
    private Socket socket ;

    public ReaderClientRunnable(Socket socket) {
        this.socket = socket;
    }

    @Override
    public void run() {
        try {
            // 读取一行数据
            InputStream is = socket.getInputStream() ;
            // 转成一个缓冲字符流
            Reader fr = new InputStreamReader(is);
            BufferedReader br = new BufferedReader(fr);
            // 一行一行的读取数据
            String line = null ;
            while((line = br.readLine())!=null){ // 阻塞式的！！
                System.out.println("服务端收到了数据："+line);
            }
        } catch (Exception e) {
            System.out.println("有人下线了");
        }
    }
}
// 提供了线程池：
public class Server {
    public static void main(String[] args) {
        try {
            System.out.println("----------服务端启动成功------------");
            ServerSocket ss = new ServerSocket(7878);

            // 一个服务端只需要对应一个线程池
            HandlerSocketThreadPool handlerSocketThreadPool =
                    new HandlerSocketThreadPool(3, 100);

            // 客户端可能有很多个
            while(true){
                Socket socket = ss.accept() ; // 阻塞式的！
                System.out.println("有人上线了！！");
                // 每次收到一个客户端的socket请求，都需要为这个客户端分配一个
                // 独立的线程 专门负责对这个客户端的通信！！
                handlerSocketThreadPool.execute(new ReaderClientRunnable(socket));
            }

        } catch (Exception e) {
            e.printStackTrace();
        }
    }

}
```
# 文件上传
```java
/**
     目标：实现客户端上传图片给服务端保存起来。

     开发客户端：本地图片 ‪D:\itcast\图片资源\meinv.jpg
     开发服务端：服务器路径：D:\itcast\陌陌图片服务器

 */
public class ClientDemo {
    public static final String SRC_IMAGE = "D:\\itcast\\图片资源\\meinv.jpg";
    public static void main(String[] args) throws Exception {
        // 1.请求与服务端的Socket连接
        Socket socket = new Socket("192.168.98.79", 8080);
        // 2.获取一个字节输出流管道，给服务端发送图片数据。
        OutputStream os = socket.getOutputStream();
        // 3.把低级的字节输出流包装成一个高级的缓冲字节输出流
        BufferedOutputStream bos = new BufferedOutputStream(os);
        // 4.把本地图片数据复制给bos管道
        // 5.定义一个缓冲字节输入流管道与本地源文件接通
        BufferedInputStream bis =
                new BufferedInputStream(new FileInputStream(SRC_IMAGE));
        // 6.定义一个字节数组
        byte[] buffer = new byte[1024];   // 1024 + 1024 + 58
        int len ;
        while((len = bis.read(buffer))!=-1){
            bos.write(buffer,0,len);
        }
        bis.close();
        bos.flush();
        socket.shutdownOutput(); // 告诉服务端我的数据到此已经发送完毕，请不要再等我!!
        System.out.println("客户端发送图片文件完毕！");

        // 接收服务端响应数据！！
        // 7.获取socket管道的字节输入流转换成字符输入流包装成缓冲字符输入流。
        BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream()));
        System.out.println(br.readLine());
    }
}
/**
 * 功能点：
 * 1.接收多个客户端传输来的图片数据存储到服务器路径：D:\itcast\陌陌图片服务器
 * 2.响应一个成功的消息给当前客户端。
 */
public class ServerDemo {
    public static final String SERVER_FILE = "D:\\itcast\\陌陌图片服务器\\";
    public static void main(String[] args) throws Exception {
        System.out.println("服务端启动。。。。");
        // 1.注册端口
        ServerSocket ss = new ServerSocket(8080);
        while(true){
            // 2.开始等待接收客户端的Socket管道连接。
            Socket socket = ss.accept();
            // 3.为当前客户端管道管道创建一个独立的线程来处理与它的通信。
            new ServerReaderThread(socket).start();
            // 有人上线
            System.out.println(socket.getRemoteSocketAddress()+"上线了！");
        }
    }
}

class ServerReaderThread extends Thread{
    private Socket socket;
    public ServerReaderThread(Socket socket){
        this.socket = socket;
    }
    @Override
    public void run() {
        try{
            // 客户端的socket执行到此！
            // 1.接收客户端传输来的图片数据存储到服务器路径：D:\itcast\陌陌图片服务器
            InputStream is = socket.getInputStream();
            // 2.把字节输入流包装成高级的缓冲字节输入流
            BufferedInputStream bis = new BufferedInputStream(is);
            // 3.定义一个缓冲字节输出流通向服务器路径：
            // 注意：每张图片都要随机生成一个新的名称。
            BufferedOutputStream bos =
                    new BufferedOutputStream(new FileOutputStream(ServerDemo.SERVER_FILE+ UUID.randomUUID().toString() +".jpg"));
            byte[] buffer = new byte[1024];
            int len ;
            while((len = bis.read(buffer))!=-1){
                bos.write(buffer,0,len);
            }
            bos.close();
            System.out.println("成功接受且保存了："+socket.getRemoteSocketAddress()+"传来的图片!");

            // 响应成功消息给客户端。
            PrintStream ps = new PrintStream(socket.getOutputStream());
            ps.println("客户端，我是服务端已经成功接收你的图片，你可以安心的去了！");

            Thread.sleep(10000);

        }catch (Exception e){
            System.out.println(socket.getRemoteSocketAddress()+"下线了！");
        }
    }
}
```
# BS模拟
```java
/**
    目标：模拟网站服务器，使用浏览器访问自己编写的服务端程序，查看网页效果

    B/S架构：浏览器。服务器。
    客户端就是浏览器，只需要开发服务端即可。

    需求：通过浏览器访问我们的服务端，响应一行“欢度国庆！”给浏览器显示。

 */
public class ServerDemo01 {
    public static void main(String[] args) throws Exception {
        System.out.println("服务端启动。。。。");
        // 1.注册端口
        ServerSocket ss = new ServerSocket(8080);
        while(true){
            // 2.开始等待接收客户端的Socket管道连接。
            Socket socket = ss.accept();
            // 3.为当前客户端管道管道创建一个独立的线程来处理与它的通信。
            new ServerReaderThread(socket).start();
            // 有人上线
            System.out.println(socket.getRemoteSocketAddress()+"上线了！");
        }
    }
}

class ServerReaderThread extends Thread{
    private Socket socket;
    public ServerReaderThread(Socket socket){
        this.socket = socket;
    }
    @Override
    public void run() {
        try{
            // 响应“欢度国庆”给客户端浏览器。
            // HTTP协议，有一定的响应格式要求。
            PrintStream ps = new PrintStream(socket.getOutputStream());
            ps.println("HTTP/1.1 200 OK"); // 协议头。响应的消息是成功的！
            ps.println("Content-Type:text/html;charset=UTF-8");// 告诉浏览器，我的内容是文本或者网页。
            ps.println(); // 换行，下一行就是主体数据内容了!
            ps.println("<span style='color:red;font-size:100px;font-family:楷体;'>欢度国庆</span>");
            ps.flush();

            ps.close();
        }catch (Exception e){
            System.out.println(socket.getRemoteSocketAddress()+"下线了！");
        }
    }
}
```
# 单元测试
```java
/**
     目标：单元测试的概念和操作步骤。

     单元测试是指程序员写的测试代码给自己的类中的方法进行预期正确性的验证。
     单元测试一旦写好了这些测试代码，就可以一直使用，可以实现一定程度上的自动化测试。

     单元测试一般要使用框架进行。
     什么是框架？
            -- 框架是前人或者一些牛逼的技术公司在实战或者研发中设计的一些优良的设计方案
                或者成型的 代码功能，作为一个完整的技术体系发行出来称为框架。

            -- 框架可以让程序员快速拥有一个强大的解决方案，可以快速的开发功能，提高效率
               并且直接就有了很好的性能。

     单元测试的经典框架：Junit.

     Junit是什么
         *  Junit是Java语言编写的第三方单元测试框架
         *  Junit框架的方案可以帮助我们方便且快速的测试我们的代码的正确性。

     单元测试概念
         * 单元：在Java中，一个类就是一个单元
         * 单元测试：程序猿用Junit编写的一小段代码，用来对某个类中的某个方法进行功能测试或业务逻辑测试。

     Junit单元测试框架的作用
         * 用来对类中的方法功能进行有目的的测试，以保证程序的正确性和稳定性。
         * 能够独立的测试某个方法或者所有方法的预期正确性。

     Junit框架的使用步骤:
        （1） 下载这个框架。（别人设计好的技术体系）
            框架一般是jar包的形式，jar包里面都是class文件。（Java工程的最终形式）
            class文件就是我们调用的核心代码。

            -- 现在不需要大家去官网下载，因为很多知名框架其实IDEA工具早就整合好了，
                        程序员可以直接使用。

            Junit已经被IDEA下载好了，可以直接导入到项目使用的。

        （2）直接用Junit测试代码即可
            a.先模拟业务代码
            b.写测试类
                    测试类的命名规范：以Test开头，以业务类类名结尾，使用驼峰命名法
                    业务名称是：UserService
                    测试这个业务类的测试类：TestUserService/UserServiceTest
            c.在测试类中写测试方法
                     测试方法的命名规则：以test开头，以业务方法名结尾
                     比如被测试业务方法名为：login，那么测试方法名就应该叫：testLogin

            d.测试方法注意事项
                     必须是public修饰的，没有返回值，没有参数
                     必须使注解@Test修饰

         (3)如何运行测试方法
                 * 选中方法名 --> 右键 --> Run '测试方法名'  运行选中的测试方法
                 * 选中测试类类名 --> 右键 --> Run '测试类类名'  运行测试类中所有测试方法
                 * 选中模块名 --> 右键 --> Run 'All Tests'  运行模块中的所有测试类的所有测试方法


         如何查看测试结果
             * 绿色：表示测试通过
             * 红色：表示测试失败，有问题

         Junit常用注解(Junit 4.xxxx版本)
             * @Test 测试方法！
             * @Before：用来修饰实例方法，该方法会在每一个测试方法执行之前执行一次。
             * @After：用来修饰实例方法，该方法会在每一个测试方法执行之后执行一次。
             * @BeforeClass：用来静态修饰方法，该方法会在所有测试方法之前只执行一次。
             * @AfterClass：用来静态修饰方法，该方法会在所有测试方法之后只执行一次。

                初始化资源：开始执行的方法。
                释放资源：执行完之后的方法。

         Junit常用注解(Junit5.xxxx版本)
             * @Test 测试方法！
             * @BeforeEach：用来修饰实例方法，该方法会在每一个测试方法执行之前执行一次。
             * @AfterEach：用来修饰实例方法，该方法会在每一个测试方法执行之后执行一次。
             * @BeforeAll：用来静态修饰方法，该方法会在所有测试方法之前只执行一次。
             * @AfterAll：用来静态修饰方法，该方法会在所有测试方法之后只执行一次。
 */
/**
 * 用户功能的业务类。
 */
public class UserService {

    /**
     * 登录功能
     * @param loginName
     * @param passWord
     * @return
     */
    public String login(String loginName , String passWord){
        if("admin".equals(loginName)&&"003197".equals(passWord)){
            return "success";
        }else{
            return "登录名称或者密码错误！";
        }
    }

    public void chu(int a , int  b){
        System.out.println(a/b);
    }
}
/**
 * 测试类
 */
public class UserServiceTest {

    public static UserService userService ;

    //@BeforeClass：用来静态修饰方法，该方法会在所有测试方法之前只执行一次。
    // 初始化静态资源
    @BeforeClass
    public static void beforeClass(){
        userService = new UserService();
        System.out.println("===BeforeClass===");
    }

    //@AfterClass：用来静态修饰方法，该方法会在所有测试方法之后只执行一次。
    @AfterClass
    public static void afterClass(){
        System.out.println("===AfterClass===");
    }

    // @Before：用来修饰实例方法，该方法会在每一个测试方法执行之前执行一次
    // 做实例资源的初始化操作
    @Before
    public void before(){
        System.out.println("===before===");
    }

    // @After：用来修饰实例方法，该方法会在每一个测试方法执行之后执行一次。
    // 做资源的回收操作。
    @After
    public void after(){
        System.out.println("=====after===");
    }


    /*测试方法注意事项
    必须是public修饰的，没有返回值，没有参数
    必须使注解@Test修饰*/
    @Test // 测试代码的关键注解。注解来源与Junit框架！
    public void testLogin(){
        String rs = userService.login("admin","003197");
        // 预期登录的结果是 success 意味着这个方法测试通过！！
        /**
         * assertEquals(String message, Object expected, Object actual)
         * 参数一：断言失败后的提示信息。
         * 参数二：期望值。
         * 参数三：实际值。
         */
        Assert.assertEquals("您的登录业务方法可能出错了！","success",rs);
    }

    @Test
    public void testChu(){
        userService.chu(10 , 2);
    }
}
```
# 反射
```markdown
/**
    目标：反射的概念。

    反射：是Java的高级技术，是Java独有的技术。是Java技术显著的特点。

    反射是指对于任何一个类，在"运行的时候"都可以直接得到这个类全部成分。
        在运行时,可以直接得到这个类的构造器对象。（Constructor）
        在运行时,可以直接得到这个类的成员变量对象。（Field）
        在运行时,可以直接得到这个类的成员方法对象。（Method）

    反射的核心思想和关键就是得到：编译以后的class文件对象。

    反射提供了一个Class类型，就是可以得到编译以后的class类对象。
        HelloWorld.java -> javac -> HelloWorld.class

        Class c = HelloWorld.class;

    注意：反射是工作在运行时的技术，因为只有运行之后才会有class类对象。

    小结：
        反射是在运行时获取类的字节码文件对象：然后可以解析类中的全部成分。
 */
```
## 反射获取Class类对象
```java
/**
    目标：反射获取Class类对象。

    引入：
        反射是通过先得到编译以后的Class类对象：字节码文件。
        然后才可以得到类中的全部成分，进行一些功能设计。

    反射为一个类的全部成分都设计了一个类型来代表这个对象：
        Class : 字节码文件的类型
        Constructor : 构造器的类型
        Field : 成员变量的类型
        Method : 方法的类型

    反射技术的第一步永远是先得到Class类对象:有三种方式获取
        （1） 类名.class
        （2） 通过类的对象.getClass()方法
        （3） Class.forName("类的全限名")
                -- public static Class<?> forName(String className)

    Class类下的方法：
         String getSimpleName(); 获得类名字符串：类名
         String getName();  获得类全名：包名+类名
         T newInstance() ;  创建Class对象关联类的对象,其实底层也是调用无参数构造器，已经被淘汰。
    小结：
        1.获取Class类对象方式有三种：
        2.Class类提供了或者类的简名和全名的API.
 */
public class ReflectDemo01 {
    public static void main(String[] args) throws Exception {
        // 反射的第一步永远是先得到类的Class文件对象：字节码文件。
        // 1.类名.class
        Class c1 = Student.class;
        System.out.println(c1);

        // 2.对象.getClass()
        Student s = new Student();
        Class c2 = s.getClass();
        System.out.println(c2);

        // 3.Class.forName("类的全限名")
        Class c3 = Class.forName("com.itheima._03反射_获取Class类对象.Student");
        System.out.println(c3);

        System.out.println("----------Class类的常用API----------");
        System.out.println(c3.getSimpleName()); // 取类名称，简名
        System.out.println(c3.getName()); // 全名
        // 直接创建一个类的对象：底层还是调用类的无参数构造器。
        // 此方式被淘汰了！
        Student s1 = (Student) c3.newInstance();

    }
}
public class Student {
}
```
## 反射\_获取Constructor构造器对象
```java
/**
    目标：反射_获取Constructor构造器对象.

    反射的第一步是先得到Class类对象。

    反射中Class类型获取构造器提供了很多的API:
         1. Constructor getConstructor(Class... parameterTypes)
            根据参数匹配获取某个构造器，只能拿public修饰的构造器，几乎不用！
         2. Constructor getDeclaredConstructor(Class... parameterTypes)
            根据参数匹配获取某个构造器，只要申明就可以定位，不关心权限修饰符，建议使用！
         3. Constructor[] getConstructors()
            获取所有的构造器，只能拿public修饰的构造器。几乎不用！！太弱了！
         4. Constructor[] getDeclaredConstructors()
            获取所有申明的构造器，只要你写我就能拿到，无所谓权限。建议使用！！
    小结：
        Constructor[] getDeclaredConstructors()：获取全部构造器对象，无所谓权限。
        Constructor getDeclaredConstructor(Class... parameterTypes)：
            获取某个指定参数类型和个数的构造器对象，无所谓权限。
 */
public class TestStudent {
    // 1.获取全部的构造器：只能获取public修饰的构造器。
    @Test
    public void getConstructors(){
        // a.先得到类的Class文件对象
        Class c = Student.class;
        // b.得到Class文件中全部的构造器对象:只能获取public修饰的构造器。
        // 返回的是一个构造器类型的数组对象，里面可能有很多个构造器
        Constructor[] cons = c.getConstructors();
        // c.遍历这些构造器。
        for(Constructor con : cons){
            // 构造器名称+参数个数
            System.out.println(con.getName() + "--->"+con.getParameterCount());
        }

    }

    // 2.获取全部的构造器：只要你敢写，这里就能拿到，无所谓权限是否可及。
    @Test
    public void getDeclaredConstructors(){
        // a.先得到类的Class文件对象
        Class c = Student.class;
        // b.得到Class文件中全部的构造器对象:
        // 返回的是一个构造器类型的数组对象，里面可能有很多个构造器
        Constructor[] cons = c.getDeclaredConstructors();
        // c.遍历这些构造器。
        for(Constructor con : cons){
            // 构造器名称+参数个数
            System.out.println(con.getName() + "--->"+con.getParameterCount());
        }

    }

    // 3.获取某个构造器：只能拿public修饰的某个构造器
    @Test
    public void getConstructor() throws Exception {
        // a.先得到类的Class文件对象
        Class c = Student.class;
        // b.定位某个构造器:只能拿public修饰的
        // 根据参数类型个个数去匹配某个构造器。
        Constructor con = c.getConstructor(String.class , int.class);
        System.out.println(con.getName()+"--->"+con.getParameterCount());
    }

    // 4.获取某个构造器：只要你敢写，这里就能拿到，无所谓权限是否可及。
    @Test
    public void getDeclaredConstructor() throws Exception {
        // a.先得到类的Class文件对象。
        Class c = Student.class;
        // b.定位某个构造器:只要你敢写，这里就能拿到，无所谓权限是否可及。
        // 根据参数类型个个数去匹配某个构造器。
        // c.Constructor con = c.getDeclaredConstructor(String.class , int.class);
        // 根据参数定位无参数构造器。
        Constructor con = c.getDeclaredConstructor();
        System.out.println(con.getName()+"--->"+con.getParameterCount());
    }
}
/**
 目标: 反射_获取Constructor构造器然后通过这个构造器创建对象。

 反射获取Class中的构造器对象Constructor作用也是初始化并得到类的一个对象返回。

 Constructor的API:
 1. T newInstance(Object... initargs)
 创建对象，注入构造器需要的数据。
 2. void setAccessible(true)
 修改访问权限，true代表暴力攻破权限，false表示保留不可访问权限(暴力反射)
 小结：
 Constructor作用可以调用自己的newInstance初始化一个对象，底层还是调用构造器的。
 反射可以破坏封装性，可以暴力打开权限。
 */
public class TestStudent02 {
    // 1.调用无参数构造器得到一个类的对象返回。
    @Test
    public void createObj01() throws Exception {
        // a.反射的第一步：先得到类的Class文件对象
        Class c = Student.class;
        // b.定位类中的无参数构造器。
        Constructor con = c.getDeclaredConstructor();
        // c.暴力打开权限。
        con.setAccessible(true);
        // d.构造器对象调用自己的newInstance方法初始化并得到类的一个对象返回。
        // 底层原理：还是触发无参数构造器执行。
        Student s = (Student) con.newInstance();
        System.out.println(s);
    }

    // 2.调用有参数构造器得到一个类的对象返回。
    @Test
    public void createObj02() throws Exception {
        // a.反射的第一步：先得到类的Class文件对象
        Class c = Student.class;
        // b.定位类中的有参数构造器。
        Constructor con = c.getDeclaredConstructor(String.class , int.class);
        // c.调用有参数构造器厨初始化类的一个对象返回
        Student s = (Student) con.newInstance("铁扇公主",40);
        System.out.println(s);

    }
}
public class Student {
    private String name ;
    private int age ;

    private Student(){
        System.out.println("无参数构造器被执行~~~~");
    }

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}
```
## 反射\_获取Field成员变量
```java
/**
     目标：反射_获取Field成员变量

     反射的第一步是先得到Class类对象。

     1、Field getField(String name);
            根据成员变量名获得对应Field对象，只能获得public修饰
     2.Field getDeclaredField(String name);
            根据成员变量名获得对应Field对象，只要申明了就可以得到
     3.Field[] getFields();
            获得所有的成员变量对应的Field对象，只能获得public的
     4.Field[] getDeclaredFields();
            获得所有的成员变量对应的Field对象，只要申明了就可以得到
 */
public class FieldDemo {
    /**
     * 1.获取全部的成员变量。
     */
    @Test
    public void getDeclaredFields(){
        // a.先得到类的Class文件对象
        Class c = Dog.class;
        // b.得到Class类文件对象中全部的成员变量
        Field[] fields = c.getDeclaredFields();
        // c.遍历全部成员变量
        for(Field f : fields){
            System.out.println(f.getName()+"--->"+f.getType());
        }
    }

    /**
        2.获取某个成员变量对象
     */
    @Test
    public void getDeclaredField() throws Exception {
        // a.先得到类的Class文件对象
        Class c = Dog.class;
        // b.定位某个成员变量
        Field f = c.getDeclaredField("name");
        System.out.println(f.getName()+"--->"+f.getType());
    }

}
/**
 目标：反射获取成员变量: 取值和赋值。

 Field的方法：给成员变量赋值和取值
 void set(Object obj, Object value)：给对象注入某个成员变量数据
 Object get(Object obj):获取对象的成员变量的值。
 void setAccessible(true);暴力反射，设置为可以直接访问私有类型的属性。
 Class getType(); 获取属性的类型，返回Class对象。
 String getName(); 获取属性的名称。

 */
public class FieldDemo02 {
    @Test
    public void setField() throws Exception {

        // 1.反射先获取Class对象
        Class c = Dog.class;

        // 2.定位age成员变量
        Field ageF = c.getDeclaredField("age");

        // 3.为这个成员变量赋值。
        Dog dog = new Dog();

        // 4.暴力打开age的访问权限赋值
        ageF.setAccessible(true);
        // 为当前对象赋值
        ageF.set(dog, 100);

        System.out.println(dog);

        // 5.取值
        int rs = (int) ageF.get(dog);
        System.out.println(rs);
    }
}
public class Dog {
    private String name;
    private int age ;
    private String color ;
    public static String school;
    public static final String school1 = "黑马";

    @Override
    public String toString() {
        return "Dog{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", color='" + color + '\'' +
                '}';
    }

    public Dog() {
    }

    public Dog(String name, int age, String color) {
        this.name = name;
        this.age = age;
        this.color = color;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getColor() {
        return color;
    }

    public void setColor(String color) {
        this.color = color;
    }
}
```
## 反射\_获取Method方法对象
```java
/**
    目标：反射——获取Method方法对象

    反射获取类的Method方法对象：
         1、Method getMethod(String name,Class...args);
             根据方法名和参数类型获得对应的方法对象，只能获得public的

         2、Method getDeclaredMethod(String name,Class...args);
             根据方法名和参数类型获得对应的方法对象，包括private的

         3、Method[] getMethods();
             获得类中的所有成员方法对象，返回数组，只能获得public修饰的且包含父类的

         4、Method[] getDeclaredMethods();
            获得类中的所有成员方法对象，返回数组,只获得本类申明的方法。

    Method的方法
        Object invoke(Object obj, Object... args)
          参数一：触发的是哪个对象的方法执行。
          参数二： args：调用方法时传递的实际参数
 */
public class MethodDemo01 {
    /**  1.获得类中的所有成员方法对象 */
    @Test
    public void getDeclaredMethods(){
        // a.获取class文件对象
        Class c = Dog.class;
        // b.获取类中的全部方法
        Method[] methods = c.getDeclaredMethods();
        // c.遍历方法
        for(Method m : methods){
            System.out.println(m.getName() +"--->"+m.getParameterCount());
        }
    }

    /**
     * 2. 获取某个方法对象
     */
    @Test
    public void getDeclardMethod() throws Exception {
        // a.获取class文件对象
        Class c = Dog.class;
        // b.定位某个方法 :无参数的eat方法。
        Method eat = c.getDeclaredMethod("eat");
        // c.定位某个方法 :有参数的eat方法。
        // 根据方法名称和对应的参数类型和个数定位方法
        Method eat1 = c.getDeclaredMethod("eat",String.class);
        // d.触发方法的执行。先暴力打开权限
        eat.setAccessible(true);
        eat1.setAccessible(true);

        Dog dog = new Dog();
        // 触发对象的该方法执行，返回方法执行的结果，如果方法没有返回值，返回null
        Object rs1 = eat.invoke(dog); // 不需要参数。无参数的方法
        Object rs2 = eat1.invoke(dog,"肉");

        System.out.println(rs1);
        System.out.println(rs2);
    }
}
public class Dog {

    private String name ;

    public Dog(){
    }

    public Dog(String name) {
        this.name = name;
    }

    public void run(){
        System.out.println("狗跑的贼快~~");
    }

    private void eat(){
        System.out.println("狗吃骨头");
    }

    private void eat(String name){
        System.out.println("狗吃"+name);
    }

    public static void inAddr(){
        System.out.println("在吉山区有一只单身狗！");
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

}
```
## 暴力攻击集合泛型
```java
/**
 *  拓展
 */
public class ReflectDemo {
    public static void main(String[] args) throws Exception {
        List<Double> scores = new ArrayList<>();
        scores.add(99.3);
        scores.add(199.3);

        // 泛型只能约束编译阶段，一旦到了运行时，泛型就被擦除：泛型擦除。
        // 反射工作在运行时，此时泛型已经消失了，所以反射可以暴力加入其它类型的元素进去。
        Class c = scores.getClass();
        // 获取c类中的add方法
        Method add = c.getDeclaredMethod("add",Object.class);
        add.invoke(scores,false);
        add.invoke(scores,"dlei");


        System.out.println(scores);
    }
}
```
## 反射的作用
```java
/**
 * 保存数据到文本中的主体框架：必须用反射技术实现可以保存一切对象数据。
 */
public class Mybatis {
    public static void save(Object ele) throws Exception {
        OutputStream os = new FileOutputStream("datas.txt",true);
        PrintStream ps = new PrintStream(os);
        // ele 可能是老师，学生，等任何对象数据。保存字段
        // 1.得到当前对象的class文件对象
        Class c = ele.getClass();
        ps.println("======="+c.getSimpleName()+"======");
        // 2.获取当前对象的类中的全部的成员变量（字段）
        Field[] fields = c.getDeclaredFields();
        // 3.遍历这些成员变量并保存起来
        for(Field f : fields){
            String name = f.getName();
            // 4.获取当前对象中该字段的值
            f.setAccessible(true);
            String value = f.get(ele)+"";
            ps.println(name+"="+value);
        }
        ps.close();
    }
}
public class Pig {
    private String name ;
    private double weight;
    private String color;
    private String onwer ;
    private String sex ;

    public Pig(String name, double weight, String color, String onwer, String sex) {
        this.name = name;
        this.weight = weight;
        this.color = color;
        this.onwer = onwer;
        this.sex = sex;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public double getWeight() {
        return weight;
    }

    public void setWeight(double weight) {
        this.weight = weight;
    }

    public String getColor() {
        return color;
    }

    public void setColor(String color) {
        this.color = color;
    }

    public String getOnwer() {
        return onwer;
    }

    public void setOnwer(String onwer) {
        this.onwer = onwer;
    }

    public String getSex() {
        return sex;
    }

    public void setSex(String sex) {
        this.sex = sex;
    }
}
/**
 拓展：反射的作用

 可以在运行时得到一个类的全部成分然后操作。
 可以破坏封装性。

 更重要的用途是适合：做Java高级框架，基本上主流框架都会基于反射设计一些通用技术功能。

 Mybatis框架。
 你给任何一个对象数据我都可以直接帮你解析字段并且把对应数据保存起来。
 Student (注册，把信息字段都存储起来)
 Teacher (注册，把信息字段都存储起来)
 Manager (注册，把信息字段都存储起来)

 我现在用反射技术开发一个框架实现：
 任何对象只要给我，我就可以把信息和字段都解析并存储起来。

 小结：
 反射是做大型框架的底层技术的，是很强大，一般属于架构师层面的技术。
 */
public class ReflectDemo01 {
    public static void main(String[] args) throws Exception {
        // (int id, String name, int age, char sex, String address, String tel)
        Student s1 = new Student(1,"赵敏",26,'女',"光明顶","110");
        Mybatis.save(s1);

        // Pig(String name, double weight, String color, String onwer, String sex)
        Pig peiQi = new Pig("乔治",500.0 , "粉色","小红","母猪");
        Mybatis.save(peiQi);
    }
}
public class Student {
    private int id ;
    private String name ;
    private int age ;
    private char sex ;
    private String address ;
    private String tel ;

    public Student(){

    }

    public Student(int id, String name, int age, char sex, String address, String tel) {
        this.id = id;
        this.name = name;
        this.age = age;
        this.sex = sex;
        this.address = address;
        this.tel = tel;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public char getSex() {
        return sex;
    }

    public void setSex(char sex) {
        this.sex = sex;
    }

    public String getAddress() {
        return address;
    }

    public void setAddress(String address) {
        this.address = address;
    }

    public String getTel() {
        return tel;
    }

    public void setTel(String tel) {
        this.tel = tel;
    }
}
```
# 注解
```java
/**
     目标：注解的概念。

     注解：
        用在类上，方法上，成员变量方法，构造器，...上对成分进行编译约束等操作的。
        注解是JDK1.5的新特性。
        注解相当一种标记，是类的组成部分，可以给类携带一些额外的信息。
        注解是给编译器或JVM看的，编译器或JVM可以根据注解来完成对应的功能。

     注解作用：
        1.标记。
        2.方法重写约束 @Override
        3.函数式接口约束。 @FunctionalInterface.
        4.现今最牛逼的框架技术多半都是在使用注解和反射。都是属于框架的基础技术。

     我们之前用的注解都是别人写好的，今天我们自己来定义一下注解。

 */
public class AnnotationDemo01 {
}

@FunctionalInterface
interface A{
    void test();
}
```
## 自定义注解
```java
/**

 目标：我们之前都是用别人写好的注解，今天我们自己来做注解。

 自定义注解的格式：
     [修饰符] @interface 注解名{
          // 注解属性
     }

 小结：
     1.注解的定义是@interface
     2.注解可以注释类的成分，可以使用多个注解注释同一个成分。

 */
@Dlei
@Book
public class MyBook {
    @Dlei
    @Book
    private String name ;

    @Dlei
    @Book
    public static void main(@Dlei String[] args) {
        @Dlei
        int age = 12 ;
    }
}
// 自定义注解
@interface Dlei{

}
// 自定义注解
@interface Book{

}
```
## 注解的属性
```java
/**
     目标：注解的属性：

     属性的格式
            - 格式1：数据类型 属性名();
            - 格式2：数据类型 属性名() default 默认值;

     属性适用的数据类型:
            八种数据数据类型(int，short，long，double，byte
             ，char，boolean，float)
            String，Class，注解类型。
            以上类型的数组形式都支持

     小结：
        注解可以申明各种类型的属性，属性必须有值，有默认值的属性可以不给值！
 */
@MyBook(name="从入门到精通", author = {"波仔","Dlei"})
public class AnnotationDemo01 {
    @MyBook(name="MySQL入门到精通", author = {"波仔","Dlei","啥啥啥"} , age = 23)
    public static void main(String[] args) {

    }
}

// 自定义一个注解
@interface MyBook{
    String name(); // name属性。
    String[] author(); // 数组
    int age() default 18;
}

```
## 注解的特殊属性
```java
/**
     目标：注解的属性：

     属性的格式
            - 格式1：数据类型 属性名();
            - 格式2：数据类型 属性名() default 默认值;

     属性适用的数据类型:
            八种数据数据类型(int，short，long，double，byte
             ，char，boolean，float)
            String，Class，注解类型。
            以上类型的数组形式都支持

     小结：
        注解可以申明各种类型的属性，属性必须有值，有默认值的属性可以不给值！
 */
@MyBook(name="从入门到精通", author = {"波仔","Dlei"})
public class AnnotationDemo01 {
    @MyBook(name="MySQL入门到精通", author = {"波仔","Dlei","啥啥啥"} , age = 23)
    public static void main(String[] args) {

    }
}

// 自定义一个注解
@interface MyBook{
    String name(); // name属性。
    String[] author(); // 数组
    int age() default 18;
}
```
## 元注解
```java
/**

     目标：元注解

     元注解是sun公司提供的。
     元注解是用在自定义注解上的注解。
     元注解是用来注解自定义注解的。

     元注解有两个：
         @Target:约束自定义注解只能在哪些地方使用，
             -- 但是默认的注解可以在类，方法，构造器，成员变量，... 使用。

         @Retention：申明注解的生命周期
             -- 申明注解的作用范围：编译时，运行时。

     @Target
          * 作用：用来标识注解使用的位置，如果没有使用该注解标识，则自定义的注解可以使用在任意位置。
          * 可使用的值定义在ElementType枚举类中，常用值如下
             TYPE，类，接口
             FIELD, 成员变量
             METHOD, 成员方法
             PARAMETER, 方法参数
             CONSTRUCTOR, 构造器
             LOCAL_VARIABLE, 局部变量

     @Retention
         作用：用来标识注解的生命周期(有效存活范围)
          * 可使用的值定义在RetentionPolicy枚举类中，常用值如下
          * SOURCE：注解只作用在源码阶段，生成的字节码文件中不存在
          * CLASS：注解作用在源码阶段，字节码文件阶段，运行阶段不存在，默认值.
          * RUNTIME：注解作用在源码阶段，字节码文件阶段，运行阶段（开发常用）

 */
public class AnnotationDemo01{
    @Dlei
    private String name ;
    @Dlei
    public static void main(String[] args) {

    }
}

@Target({ ElementType.FIELD , ElementType.METHOD}) // 注解成员变量和方法
@Retention(RetentionPolicy.RUNTIME) // 本注解永远存在
@interface Dlei  {

}
```
## 注解的解析
```java
/**

 目标：注解的解析

 我们会使用注解注释一个类的成分，那么就设计到要解析出这些注解的数据。
 开发中经常要知道一个类的成分上面到底有哪些注解，注解有哪些属性数据，这都需要进行注解的解析。

 与注解解析相关的接口
      1. Annotation: 注解类型，该类是所有注解的父类。注解都是一个Annotation的对象

      AnnotatedElement:该接口定义了与注解解析相关的方法
        所有的类成分Class, Method , Field , Constructor:都实现了AnnotatedElement接口
        他们都拥有解析注解的能力：
         1.T getAnnotation(Class<T> annotationClass)
            根据注解类型获得对应注解对象，会拿父类的注解
         2.Annotation[]	getAnnotations()
            获得当前对象上使用的所有注解，返回注解数组.
         3.Annotation[]	getDeclaredAnnotations()
            获得当前对象上使用的所有注解，返回注解数组,只包含本类的
         5.T getDeclaredAnnotation(Class<T> annotationClass)
             根据注解类型获得对应注解对象
         4.boolean isAnnotationPresent(Class<Annotation> annotationClass)
            判断当前对象是否使用了指定的注解，如果使用了则返回true，否则false

 解析注解数据的原理
     * 注解在哪个成分上，我们就先拿哪个成分对象。
     * 比如注解作用成员方法，则要获得该成员方法对应的Method对象，再来拿上面的注解
     * 比如注解作用在类上，则要该类的Class对象，再来拿上面的注解
     * 比如注解作用在成员变量上，则要获得该成员变量对应的Field对象，再来拿上面的注解

 需求：（了解即可）
     1. 定义注解Book，要求如下：
         - 包含属性：String value()   书名
         - 包含属性：double price()  价格，默认值为 100
         - 包含属性：String[] authors() 多位作者
         - 限制注解使用的位置：类和成员方法上
         - 指定注解的有效范围：RUNTIME
     2. 定义BookStore类，在类和成员方法上使用Book注解
     3. 定义AnnotationDemo01测试类获取Book注解上的数据

 */
public class AnnotationDemo01 {
    @Test
    public void parseType(){
        // 需求：解析类上的注解。
        // a.获取当前类的Class对象
        Class c = BookStore.class;
        // b.判断类上是否有这个Book注解
        if(c.isAnnotationPresent(Book.class)){
            // c.获取该注解对象
            Book book = (Book) c.getDeclaredAnnotation(Book.class);
            System.out.println(book.value());
            System.out.println(book.price());
            System.out.println(Arrays.toString(book.authors()));
        }
    }

    @Test
    public void parseMethod() throws Exception {
        // 需求：解析类上的注解。
        // a.获取当前类的Class对象
        Class c = BookStore.class;
        // b.得到该方法对象
        Method go = c.getDeclaredMethod("go");
        // c.判断go方法上是否有这个Book注解
        if(go.isAnnotationPresent(Book.class)){
            // d.获取该注解对象
            Book book = (Book) go.getDeclaredAnnotation(Book.class);
            System.out.println(book.value());
            System.out.println(book.price());
            System.out.println(Arrays.toString(book.authors()));
        }
    }
}

@Book(value = "《精通Java思想》" , price = 99.9 , authors = {"Dlei","波仔"})
class BookStore{
    @Book(value = "《深入MySQL数据库》" , authors = {"苍老师","网易","小泽"})
    public void go(){

    }
}

@Target({ElementType.TYPE,ElementType.METHOD}) //  限制注解使用的位置：类和成员方法上
@Retention(RetentionPolicy.RUNTIME)  // 指定注解的有效范围：RUNTIME
@interface Book{
    String value() ; // 书名
    double price() default 100.0; // 价格，默认值为 100
    String[] authors(); // 多位作者
}
```
## 注解模拟Junit框架
```java
/**
    目标：自定义注解模拟写一个Junit框架的基本使用。

    需求：定义若干个方法，只要加了MyTest注解，就可以被自动触发执行。

    分析：
        （1）定义一个自定义注解MyTest.
                -- 只能注解方法。
        （2）定义若干个方法，只要有@MyTest注解的方法就能被触发执行！！
            没有这个注解的方法不能执行！！
    小结：
        反射+注解是一些框架实现的底层技术，很多通用技术都是通过反射+注解+泛型设计出来的。
 */
public class TestDemo {
    @MyTest
    public void test01(){
        System.out.println("==test01==");
    }
    @MyTest
    public void test02(){
        System.out.println("==test02==");
    }

    //@MyTest
    public void test03(){
        System.out.println("==test03==");
    }

    // 模拟那个测试启动按钮，只要有MyTest注解就调用它
    public static void main(String[] args) throws Exception {
        TestDemo t = new TestDemo();
        // 1.先得到类对象Class文件
        Class c = TestDemo.class;
        // 2.获取全部的方法
        Method[] methods = c.getDeclaredMethods();
        // 3.遍历这些方法看是否有注解，有就触发它执行。
        for(Method m : methods){
            // 4.判断方法上是否存在MyTest注解
            if(m.isAnnotationPresent(MyTest.class)){
                // 5.触发m执行
                m.invoke(t);
            }
        }
    }
}

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@interface MyTest{
}
```
# 动态代理
## 动态代理的案例引入
```java
/**
    目标：使用动态代理之前的案例。

    需求：
        提供一个业务对象可以实现，出国，回国的功能。
           出国的方法：goAbroad
                  买票办理护照签证。
                      开始愉快的出国玩耍。
                  注销行程。

           回国的方法：goHome
                  买票办理护照签证。
                      开始完满的回国吹水。
                  注销行程。

    引出问题：
        我们发现我们的业务功能方法，前后的逻辑代码几乎都是一样，只是中间部分不一样

        如果能够让业务功能只处理自己的核心逻辑，其他的不用写就可以完成，
        这时候需要用动态代理了！！
 */
public class TestMain {
    public static void main(String[] args) {
        UserService user = new UserServiceImpl();
        user.goAbroad();
        user.goHome();
    }
}
public interface UserService {
    void goAbroad();
    void goHome();
}
public class UserServiceImpl implements UserService {
    @Override
    public void goAbroad() {
        System.out.println("买票办理护照签证");
        System.out.println("开始愉快的出国玩耍");
        System.out.println("注销行程");
    }

    @Override
    public void goHome() {
        System.out.println("买票办理护照签证");
        System.out.println("开始完满的回国吹水");
        System.out.println("注销行程");
    }
}
```
## 动态代理的使用
```java
/**
    目标：动态代理的使用

    业务对象：现在功能完全是自己去实现的。
    业务对象能否找到一个代理，相同的东西交给代理集中解决，需要自己完成的就自己去做！

    动态代理的核心：把业务对象  -> 转成被代理的业务对象

    做一个代理：（完成出国签证办理，通知别人做自己的操作，最后注销）
        1.把业务对象包装成一个被代理的业务对象返回。
        2.以后调用业务对象的方法，会先找代理进行代理操作，然后代理通知真正执行
            自己的业务功能方法，然后代理再做收尾操作。

 */
public class TestMain {
    public static void main(String[] args) {
        // 把自己的业务对象交给了代理：返回一个被代理的业务对象。
        UserService user = UserProxy.getProxy(new UserServiceImpl());
        user.goAbroad();
        user.goHome();
        user.goTaiWan();
    }
}
/**
 * 代理类：代表了旅行社。
 *
 * 做代理的类：java.lang.reflect.Proxy
 * 返回代理对象的方法：public static Object
 *      newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h)
 *
 */
public class UserProxy {
    /**
     * 传入被代理的业务对象，返回一个真正被代理的业务对象。
     * @param service
     * @return
     */
    public static UserService getProxy(UserService service){
        /**
         * 参数一：类加载器，用于加载被代理的业务对象。
         * 参数二：被代理对象的全部实现的接口。从而可以为当前业务对象的全部方法做代理。
         * 参数三：真正的代理处理方法。
         */
        return (UserService) Proxy.newProxyInstance(service.getClass().getClassLoader(),
                service.getClass().getInterfaces(), new InvocationHandler() {
                    @Override
                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                        /**
                         * method : 当前被代理的方法，正在执行的方法。
                         * args: 代表当前执行方法的参数。
                         */
                        System.out.println("买票办理护照签证");
                        // 真正触发真实的业务对象方法执行。
                        Object rs = method.invoke(service);

                        System.out.println("注销行程");
                        // 返回方法执行的结果。
                        return rs;
                    }
                });
    }
}
public interface UserService {
    void goAbroad();
    void goHome();
    void goTaiWan();
}
public class UserServiceImpl implements UserService {
    @Override
    public void goAbroad() {
        System.out.println("开始愉快的出国玩耍");
    }

    @Override
    public void goHome() {
        System.out.println("开始完满的回国吹水");
    }

    @Override
    public void goTaiWan() {
        System.out.println("去台湾走走~~");
    }
}

```
## 动态代理的案例
```java
/**

 需求：统计每个方法执行的性能！！

 小结：
 我们可以为业务功能的每个方法做代理。把方法执行之前的时间和执行之后的时间
 交给代理来统计。这样业务功能就无需关心性能时间的统计，代码架构简洁，优雅！！

 动态代理非常的灵活，可以为任意的接口实现类对象做代理：只能为接口的实现类对象做代理！！
 动态代理可以为被代理对象的所有接口的所有方法做代理，
 动态代理可以在不改变方法源码的情况下，实现对方法功能的增强. AOP编码。
 动态代理类不仅简化了编程工作，而且提高了软件系统的可扩展性，
 因为Java 反射机制可以生成任意类型的动态代理类。
 动态代理同时也提高了开发效率。
 缺点：只能针对接口的实现类做代理对象，普通类是不能做代理对象的。
 */
public class TestMain {
    public static void main(String[] args) {
        BookService bookService = TimerProxy.getProxy(new BookServiceImpl());
        bookService.add(); // 走代理
        System.out.println(bookService.delete()); // 走代理
        bookService.query(); // 走代理
        bookService.update(); // 走代理
        bookService.queryDatas(); // 走代理
    }
}
public interface BookService {
    void add();
    boolean delete();
    boolean update();
    void query();
    void queryDatas();
}
public class BookServiceImpl implements BookService {
    @Override
    public void add() {
        try{
            Thread.sleep(1000);
            System.out.println("添加书本！");
        }catch (Exception e){
            e.printStackTrace();
        }

    }

    @Override
    public boolean delete() {
        try{
            Thread.sleep(2000);
            System.out.println("删除书本！");
        }catch (Exception e){
            e.printStackTrace();
        }
        return true;
    }

    @Override
    public boolean update() {
        try{
            Thread.sleep(1500);
            System.out.println("修改书本！");
        }catch (Exception e){
            e.printStackTrace();
        }
        return true;
    }

    @Override
    public void query() {
        try{
            Thread.sleep(3000);
            System.out.println("查询书本！");
        }catch (Exception e){
            e.printStackTrace();
        }
    }

    @Override
    public void queryDatas() {
        try{
            Thread.sleep(4000);
            System.out.println("查询所有书本！");
        }catch (Exception e){
            e.printStackTrace();
        }
    }


}
public class TimerProxy {
    /**
     * 时间代理对象。返回一个被代理的业务对象。
     * @param obj
     * @param <T>
     * @return
     */
    public static <T> T getProxy(T obj){
        return (T) Proxy.newProxyInstance(obj.getClass().getClassLoader(),
                obj.getClass().getInterfaces(), new InvocationHandler() {
                    @Override
                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                        // method : 就是当前执行的被代理方法对象。
                        long startTimer = System.currentTimeMillis();

                        // 触发当前业务对象的方法真正执行
                        Object rs = method.invoke(obj);

                        long endTimer = System.currentTimeMillis();
                        System.out.println(method.getName()+"耗时："+(endTimer - startTimer)/1000.0 +"s");
                        return rs;
                    }
                });
    }
}
```
# 解析XML文档
## 解析XML文档根元素
```java
/**
    目标：dom4j: 获取Document对象和根元素

    dom4j安装步骤：
        a.去dom4j官网下载dom4j的框架：都是一些jar包。
        b.把dom4j的核心jar包导入到当前项目中去。
        c.在项目中创建一个文件夹：lib
        d.将dom4j-2.1.1.jar文件复制到 lib 文件夹
        e.在jar文件上点右键，选择 Add as Library -> 点击OK
        f.在类中导包使用

    Document文档：
         Element getRootElement()：获取根元素。
    小结：
        请记住API。
 */
public class Dom4JDemo01 {
    public static void main(String[] args) throws Exception {
        // 需求：解析Contact.xml文件
        // 1.创建一个dom4j框架的解析对象:代表了整个dom4j框架。
        SAXReader saxReader = new SAXReader();

        // 2.读取xml文件成为一个Document文档对象。 domcument对象==xml文件对象
        // 把文件读成一个字节输入流， /代表去当前模块所在的类路径src下寻找文件。
        InputStream is = Dom4JDemo01.class
                .getResourceAsStream("/Contact.xml");
        // 读取字节输入流直接转换成一个文档对象：document
        //  public Document read(InputStream in)
        Document document = saxReader.read(is);

        // 3.直接获取文档对象的根元素
        Element root = document.getRootElement();
        // 4.输出根元素的名称。
        System.out.println(root.getName());

    }
}

```
## 解析XML文档子元素
```java
/**
    目标：Dom4j解析XML的子元素
    Element元素的API:
        String getName():取元素的名称。
        List<Element> elements():获取当前元素下的全部子元素（一级）
        List<Element> elements(String name):获取当前元素下的指定名称的全部子元素（一级）
        Element element(String name):获取当前元素下的指定名称的某个子元素，默认取第一个（一级）

 */
public class Dom4JDemo {
    public static void main(String[] args) throws Exception {
        // 1.创建一个dom4j的解析对象
        SAXReader saxReader = new SAXReader();
        // 2.加载被解析的xml文件成为一个字节输入流
        InputStream is = Dom4JDemo.class.getResourceAsStream("/Contact.xml");
        // 3.把字节输入流通过解析对象读成一个document文档对象
        Document document = saxReader.read(is);
        // 4.得到当前文档的根元素对象
        Element root = document.getRootElement();
        // 5.输出根元素的名称
        System.out.println(root.getName());
        // 6.获取根元素下的全部子元素 。
        //List<Element> elements = root.elements();
        // 7.根据名称取一批子元素返回。
        //List<Element> elements = root.elements("contact");
        //for(Element ele : elements){
        //    System.out.println("\t"+ele.getName());
        //}

        // 取根元素下的一个子元素，默认取第一个返回。
        Element ele = root.element("contact");
        System.out.println(ele);
        System.out.println(ele.attributeValue("id")); // 取当前元素的id属性值
    }
}
```
## 解析XML的属性
```java
/**
    目标：Dom4j解析XML的属性;

    Element元素的API:
        List<Attribute> attributes(): 获取元素的全部属性对象。
        Attribute attribute(String name):根据名称获取某个元素的属性对象。
        String attributeValue(String var1)：直接获取某个元素的某个属性名称的值。
    Attribute对象的API:
        String getName(): 获取属性名称。
        String getValue:获取属性值。
 */
public class Dom4JDemo {
    public static void main(String[] args) throws Exception {
        // 1.创建一个dom4j的解析对象
        SAXReader saxReader = new SAXReader();
        // 2.加载被解析的xml文件成为一个字节输入流
        InputStream is = Dom4JDemo.class.getResourceAsStream("/Contact.xml");
        // 3.把字节输入流通过解析对象读成一个document文档对象
        Document document = saxReader.read(is);
        // 4.得到当前文档的根元素对象
        Element root = document.getRootElement();
        // 5.输出根元素的名称
        System.out.println(root.getName());
        // 6.定位第一个子元素
        Element oneEle = root.element("contact");
        // 7.直接获取第一个元素的全部属性对象
        List<Attribute> attributes = oneEle.attributes();
        for(Attribute attr : attributes){
            System.out.println(attr.getName()+"==>"+attr.getValue());
        }
        // 8.根据名称获取某个元素的属性对象
        Attribute attr1 = oneEle.attribute("desc");
        System.out.println(attr1.getName()+"----->"+attr1.getValue());
        // 9.直接获取元素的属性值
        System.out.println(oneEle.attributeValue("id"));
        System.out.println(oneEle.attributeValue("desc"));
    }
}
```
## Dom4j解析XML的文本
```java
/**
    目标：Dom4j解析XML的文本;

    Element:
        String elementText(String name): 可以直接获取当前元素的子元素的文本内容
        String elementTextTrim(String name): 去前后空格,直接获取当前元素的子元素的文本内容
        String getText():直接获取当前元素的文本内容。
        String getTextTrim():去前后空格,直接获取当前元素的文本内容。
 */
public class Dom4JDemo {
    public static void main(String[] args) throws Exception {
        // 1.创建一个dom4j的解析对象
        SAXReader saxReader = new SAXReader();
        // 2.加载被解析的xml文件成为一个字节输入流
        InputStream is = Dom4JDemo.class.getResourceAsStream("/Contact.xml");
        // 3.把字节输入流通过解析对象读成一个document文档对象
        Document document = saxReader.read(is);
        // 4.得到当前文档的根元素对象
        Element root = document.getRootElement();
        // 5.输出根元素的名称
        System.out.println(root.getName());
        // 6.定位第一个子元素
        Element oneEle = root.element("contact");
        System.out.println(oneEle.getName());
        // 7.可以直接获取当前元素的子元素的文本内容
        System.out.println(oneEle.elementText("name"));
        System.out.println(oneEle.elementText("gender"));
        System.out.println(oneEle.elementText("email"));
        System.out.println(oneEle.elementTextTrim("email")); // 去前后空格
        // 8.先获取子元素对象，再获取文本对象内容
        Element emailEle = oneEle.element("email");
        System.out.println(emailEle.getText());
        System.out.println(emailEle.getTextTrim());// 去前后空格
    }
}
```
## Dom4j解析案例
```java
/**
 *  目标：Dom4j解析XML文件:Contacts.xml成为一个Java的对象（集合对象）
 */
public class Dom4JDemo {
    public static void main(String[] args) throws Exception {
        // 1.创建一个dom4j的解析对象
        SAXReader saxReader = new SAXReader();
        // 2.加载被解析的xml文件成为一个字节输入流
        InputStream is = Dom4JDemo.class.getResourceAsStream("/Contacts.xml");
        // 3.把字节输入流通过解析对象读成一个document文档对象
        Document document = saxReader.read(is);
        // 4.得到当前文档的根元素对象
        Element root = document.getRootElement();
        // 5.获取当前根元素下的全部子元素对象
        List<Element> elements = root.elements();
        // 6.创建一个集合存储每个子元素对象的内容
        List<Contact> contacts = new ArrayList<>();
        // 7.遍历3个子元素
        for(Element ele : elements){
            // 8.每个子元素都必须创建一个联系人对象封装它的数据。
            Contact contact = new Contact();
            contact.setId(Integer.valueOf(ele.attributeValue("id")));
            contact.setVip(Boolean.valueOf(ele.attributeValue("vip")));
            contact.setEmail(ele.elementTextTrim("email"));
            contact.setName(ele.elementTextTrim("name"));
            contact.setGender(ele.elementTextTrim("gender"));
            contacts.add(contact); // 把元素对象的数据加入到集合中去存储
        }
        // 9.输出集合对象即可
        System.out.println(contacts);
    }
}
public class Contact {
    private int id ;
    private boolean vip;
    private String name;
    private String gender;
    private String email;

    public Contact() {
    }

    public Contact(int id, boolean vip, String name, String gender, String email) {
        this.id = id;
        this.vip = vip;
        this.name = name;
        this.gender = gender;
        this.email = email;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public boolean isVip() {
        return vip;
    }

    public void setVip(boolean vip) {
        this.vip = vip;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getGender() {
        return gender;
    }

    public void setGender(String gender) {
        this.gender = gender;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    @Override
    public String toString() {
        return "Contact{" +
                "id=" + id +
                ", vip=" + vip +
                ", name='" + name + '\'' +
                ", gender='" + gender + '\'' +
                ", email='" + email + '\'' +
                '}'+"\n";
    }
}
```
# XPath检索XML中的信息
```java
/**
    目标：XPath检索XML中的信息啊。

    引入：
        Dom4J可以用于解析整个XML的数据。
        但是如果要检索XML中的某些信息，建议使用XPath.
    XPath使用步骤：
        1.导入dom4j框架。（XPath依赖于Dom4j的）
        2.导入XPath独有的框架包。jaxen-1.1.2.jar
    XPath常用API:
        List<Node> selectNodes(String var1):检索出一批节点集合。
        Node selectSingleNode(String var1)：检索出一个节点返回。
 */
public class XPathDemo {
    private Document document;
    @Before
    public void before() throws Exception {
        //1. 得到SaxReader
        SAXReader reader = new SAXReader();
        //2. 得到文档对象
        document = reader.read(XPathDemo.class.getResourceAsStream("/Contacts.xml"));
    }

    // 1.绝对路径定位元素：/根元素/子元素/二级元素。
    @Test
    public void xpath01() throws Exception {
        //用绝对路径检索
        List<Node> nodes = document.selectNodes("/contactList/contact/name");
        for(Node node : nodes){
            System.out.println(node.getText());
        }
    }

    // 2.相对路径定位元素：./子元素/二级元素。(用处不算很大)
    @Test
    public void xpath02() throws Exception {
        // 通过绝对路径得到根节点：/contactList
        Node node = document.selectSingleNode("/contactList");
        // 相对于根节点继续检索: .是相对于当前根节点。
        List<Node> nodes = node.selectNodes("./contact/name");
        for(Node n : nodes){
            System.out.println(n.getText());
        }
    }

    // 3.全文检索
    //contact ： 在整个XML中检索contact元素。
    //contact/name：在整个XML中检索contact下的一级name元素。
    //contact//name：在整个XML中检索contact下的全部name元素。
    @Test
    public void xpath03() throws Exception {
        // List<Node> nodes = document.selectNodes("//contact");
        //List<Node> nodes = document.selectNodes("//contact/name");
        List<Node> nodes = document.selectNodes("//contact//name");
        for(Node node : nodes){
            System.out.println(node.getText());
        }
    }

    // 4.属性检索
    //@id  ： 在整个XML文件中检索id属性。
    //contact[@id] ： 在整个XML文件中检索全部contact中包含id属性。
    //contact[@id=2] ： 在整个XML文件中检索全部contact中的包含id属性，且id属性值为2的contact
    @Test
    public void xpath04() throws Exception {
//      List<Node> nodes = document.selectNodes("//@id");
//      for(Node node : nodes){
//            Attribute attr = (Attribute) node;
//            System.out.println(attr.getValue());
//      }

//      List<Node> nodes = document.selectNodes("//contact[@id]");
//      for(Node node : nodes){
//            System.out.println(node.getName());
//      }

        Node node = document.selectSingleNode("//contact[@id=2]");
        Element ele = (Element) node;
        System.out.println(ele.elementText("name"));
    }
}
```
## XML解析Mybatis框架的核心配置文件信息
```java
public class ParseXMLConfig {
    @Test
    public void parseXML() throws Exception {
        // 1.创建一个dom4j的解析对象
        SAXReader saxReader = new SAXReader();
        // 2.加载被解析的xml文件成为一个字节输入流
        InputStream is =
                Dom4JDemo.class.getResourceAsStream("/sqlMapConfig.xml");
        // 3.把字节输入流通过解析对象读成一个document文档对象
        Document document = saxReader.read(is);
        // 4.得到当前文档的根元素对象
        Element root = document.getRootElement();
        System.out.println(root.getName());
        // 5.得到environments元素对象
        Element environments = root.element("environments");
        // 6.得到environment子元素
        Element environment = environments.element("environment");
        // 7.得到dataSource子元素
        Element dataSource = environment.element("dataSource");
        // 8.获取dataSource下的四个子元素
        List<Element> properties = dataSource.elements();
        for(Element pro : properties){
            System.out.println(pro.attributeValue("name")+"="+pro.attributeValue("value"));
        }
        // 9.得到mappers元素
        Element mappers = root.element("mappers");
        Element pk = mappers.element("package");
        System.out.println(pk.attributeValue("name"));
    }
}
```

```xml
<?xml version="1.0" encoding="UTF-8"?>
<books>
    <book id="0001">
        <name>JavaWeb开发教程</name>
        <author>张孝祥</author>
        <sale>100.00元</sale>
    </book>
    <book id="0002">
        <name>三国演义</name>
        <author>罗贯中</author>
        <sale>100.00元</sale>
    </book>
</books>
```

```xml
<?xml version="1.0" encoding="UTF-8"?>
<contactList>
    <contact id="1" desc="第一个联系人">
        <name>潘金莲</name>
        <gender>女</gender>
        <email>   panpan@itcast.cn  </email>
    </contact>
    <contact id="2">
        <name>武松</name>
        <gender>男</gender>
        <email>wusong@itcast.cn</email>
    </contact>
    <contact id="3">
        <name>武大狼</name>
        <gender>男</gender>
        <email>wuda@itcast.cn</email>
    </contact>
</contactList>
```

```xml
<?xml version="1.0" encoding="UTF-8"?>
<contactList>
    <contact id="1" vip="true">
        <name>潘金莲</name>
        <gender>女</gender>
        <email>panpan@itcast.cn</email>
    </contact>
    <contact id="2" vip="false">
        <name>武松</name>
        <gender>男</gender>
        <email>wusong@itcast.cn</email>
    </contact>
    <contact id="3" vip="false">
        <name>武大狼</name>
        <gender>男</gender>
        <email>wuda@itcast.cn</email>
        <contact id="4" vip="false">
            <name>武大狼02</name>
            <gender>男</gender>
            <email>wuda@itcast.cn</email>
            <a>
                <name>西门庆</name>
            </a>
        </contact>
    </contact>
</contactList>
```

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
    <!--mybatis环境的配置-->
    <environments default="mysql">
        <!--通常我们只需要配置一个就可以了， id是环境的名字 -->
        <environment id="mysql">
            <!--事务管理器：由JDBC来管理-->
            <transactionManager type="JDBC"/>
            <!--配置连接池：数据源的配置：mybatis自带的连接池-->
            <dataSource type="POOLED">
                <property name="driver" value="com.mysql.jdbc.Driver"/>
                <property name="url" value="jdbc:mysql://127.0.0.1:3306/dlei"/>
                <property name="username" value="root"/>
                <property name="password" value="root"/>
            </dataSource>
        </environment>
    </environments>
    <mappers>
       <package name="com.itheima.dao"/>
    </mappers>
</configuration>
```







